#+TITLE: Literate Roam Clojure Emacs Config
#+AUTHOR: gas
#+STARTUP: overview
#+PROPERTY: header-args :cache yes :results output :mkdirp yes :padline :async
#+AUTO_TANGLE: yes

* About me

#+begin_src emacs-lisp :noweb-ref user-config
  (defconst IS-WORK (string-match "810989" (getenv "USER")))
  (if IS-WORK
      (setq
       user-full-name "Gas 810989"
       user-mail-address "gas_gasson@bnz.co.nz")
    (setq
     user-full-name "Andrés Gasson"
     user-mail-address "gas@tuatara.red"
     github-account-name "frap"))
#+end_src

** Where I am

#+begin_src emacs-lisp :noweb-ref user-config
  (setq calendar-location-name "Wellington, NZ"
        calendar-latitude -41.28
        calendar-longitude 174.78)
#+end_src

** Auth-sources

Here feels like as good a place as any to setup =auth-sources=.

#+begin_src emacs-lisp :noweb-ref user-config
  (setq-default auth-sources '("~/.local/state/authinfo.gpg")
                auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src
* Startup Performance

** Garbage Collection & File handlers
:PROPERTIES:
:header-args: :noweb-ref garbage-filehandler
:END:
Make startup faster by reducing the frequency of garbage collection and then use a hook to measure Emacs startup time.


#+begin_src emacs-lisp

  (message "Chargement en cours early-init.el...")

  (define-advice load (:before (feature &rest _))
    "Message the user when loading a library."
    (with-temp-message (format "En cours de chargement: '%s'" feature)))

  ;; Garbage collection slows down startup time, so we maximise the threshold for
  ;; it to run, and we will later reset it.
  (setq gc-cons-threshold most-positive-fixnum)

  ;; file-name-handler-alist is consulted on various I/O functions such as
  ;; REQUIRE, slowing down startup time, so we set it to NIL, and establish a hook
  ;; to restore when Emacs is finished starting.
  (unless (or (daemonp) noninteractive)
    (let ((file-name-handler-alist/old file-name-handler-alist))
      (setq file-name-handler-alist nil)
      (add-hook 'emacs-startup-hook
                (lambda ()
                  (let ((value (delete-dups
                                (append file-name-handler-alist
                                        file-name-handler-alist/old))))
                    (setq file-name-handler-alist value))))))

  (unless (daemonp)
    (advice-add #'tty-run-terminal-initialization :override #'ignore)
    (add-hook 'window-setup-hook
              (lambda ()
                (advice-remove #'tty-run-terminal-initialization #'ignore)
                (tty-run-terminal-initialization (selected-frame) nil t))))

#+end_src
** Initial frame setup
:PROPERTIES:
:header-args: :noweb-ref early-init-frame
:END:

I tangle this section to =early-init.el=, since that's evaluated
before GUI set-up.  Which, in turn, means Emacs will skip the "flash
of unstyled content" thing. Turned off for Termux.

*** Tool bar

#+begin_src emacs-lisp
  (unless IS-TERMUX
    (add-to-list 'default-frame-alist
                '(tool-bar-lines . 0))

   (tool-bar-mode -1)

#+end_src

*** Menu bar

#+begin_src emacs-lisp
   ;;(add-to-list 'default-frame-alist
   ;;             '(menu-bar-lines . 0))

  ;; (menu-bar-mode -1)

#+end_src

*** Scroll bars

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist
               '(vertical-scroll-bars . nil)
                 '(horizontal-scroll-bars . nil))

    (scroll-bar-mode -1)
    (horizontal-scroll-bar-mode -1)

#+end_src

*** Resizing

I don't want the frame to resize when I change fonts and stuff, and I
want it to resize by pixels -- we /are/ using a GUI, after all.

#+begin_src emacs-lisp
  (setq-default frame-inhibit-implied-resize t
                frame-resize-pixelwise t)
  (setq truncate-partial-width-windows nil)

#+end_src

*** Miscellaneous
setting some default settings on early-init
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Iosevka Slab 12"))
  (blink-cursor-mode 0)
  (column-number-mode 1)
  (display-time-mode 0)
  (fringe-mode '(4 . 0))
  (tooltip-mode 0)
  (window-divider-mode 1)
  ) ;; end of unless IS-TERMUX

#+end_src
** Directories
:PROPERTIES:
:header-args: :noweb-ref early-directories
:END:
Need to setup some constants and try to keep state in a "clean" directory structure
#+begin_src emacs-lisp
  ;; For the rest of the Emacs configuration, set this directory to something
  ;; inside the standard cache directory, so we do not pollute our emacs.d
  ;; directory with files that we would then have to ignore with Git.
  (setq user-emacs-directory
	(expand-file-name "emacs/" (or (getenv "XDG_CACHE_HOME") "~/.cache/")))

  ;; Add our custom lisp modules to the Emacs load path so they can be discovered.
  (push (expand-file-name "lisp/" (file-name-directory user-init-file)) load-path)

  ;; For the list of native compilation ELN cache directories, delete all but the
  ;; last element, which is always assumed to be the system path, and then cons a
  ;; new path in our cache directory to the front. This effectively removes the
  ;; entry for the original ~/.emacs.d/eln-cache/ and any others that are
  ;; unwanted.
  (if (fboundp 'native-comp-available-p)
       (setq native-comp-eln-load-path
	(cons (expand-file-name "eln-cache/" user-emacs-directory)
	      (last native-comp-eln-load-path))))

#+end_src

** Straight Package Management
:PROPERTIES:
:header-args: :noweb-ref early-straight
:END:
Use Straight for package Management. Also use setup.el for easy config of packages.
#+begin_src emacs-lisp
    ;; Pre-configure the package manager settings before it is loaded.
    (setq package-enable-at-startup nil)
    (setq package-quickstart nil)
    (setq straight-check-for-modifications '(check-on-save find-when-checking))

    ;; Bootstrap the straight.el package manager if it is not already installed,
    ;; then unconditionally load it. We use this rather than Emacs' built-in package
    ;; manager.
    (unless (featurep 'straight)
      ;; Bootstrap straight.el
      (defvar bootstrap-version)
      (let ((bootstrap-file
             (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
            (bootstrap-version 5))
        (unless (file-exists-p bootstrap-file)
          (with-current-buffer
              (url-retrieve-synchronously
               "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
               'silent 'inhibit-cookies)
            (goto-char (point-max))
            (eval-print-last-sexp)))
        (load bootstrap-file nil 'nomessage)))

    ;; Additional post-setup of straight.el.
    (require 'straight-x)
  ;;; Appendix

    ;; Get rid of a dumb alias.  straight-ಠ_ಠ-mode really slows down all
    ;; minibuffer completion functions.  Since it's a (rarely-used, even)
    ;; alias anyway, I just define it back to nil.  By the way, the alias
    ;; is `straight-package-neutering-mode'.
    (defalias 'straight-ಠ_ಠ-mode nil)
  (message "Chargement du early-init.el terminé!")

  #+end_src
** Emacs Package Manager Setup
:PROPERTIES:
:header-args: :noweb-ref setup-pkgmgr
:END:
Using [[https://www.emacswiki.org/emacs/SetupEl][setup.el]] by pkal to manage packages as alternative to use-package
#+begin_src emacs-lisp
  (require 'subr-x)
  (straight-use-package '(setup :type git :host nil :repo "https://git.sr.ht/~pkal/setup"))
  (require 'setup)

  ;; Uncomment this for debugging purposes
  (defun dw/log-require (&rest args)
    (with-current-buffer (get-buffer-create "*require-log*")
      (insert (format "%s\n"
                      (file-name-nondirectory (car args))))))
  (add-to-list 'after-load-functions #'dw/log-require)
  ;; added from  https://github.com/daviwil/dotfiles/blob/master/Emacs.org#org-mode

  (defmacro define-setup-macro (name signature &rest body)
    "Shorthand for 'setup-define'. NAME is the name of the local macro. SIGNATURE
                is used as the argument list for FN. If BODY starts with a string, use this as
                the value for :documentation. Any following keywords are passed as OPTS to
                'setup-define'."
    (declare (debug defun))
    (let (opts)
      (when (stringp (car body))
        (setq opts (nconc (list :documentation (pop body)) opts)))
      (while (keywordp (car body))
        (let ((prop (pop body))
              (val `',(pop body)))
          (setq opts (nconc (list prop val) opts))))
      `(setup-define ,name
         (cl-function (lambda ,signature ,@body))
         ,@opts)))

  #+end_src
*** Setup local macros
  :PROPERTIES:
:header-args: :noweb-ref setup-macros
:END:
 local-macros for setup.el
 #+begin_src emacs-lisp
   (define-setup-macro :pkg (recipe)
     "Install RECIPE with 'straight-use-package'. This macro can be used as HEAD,
                          and will replace itself with the first RECIPE's package."
     :repeatable t
     :shorthand (lambda (sexp)
                  (let ((recipe (cadr sexp)))
                    (if (consp recipe)
                        (car recipe)
                      recipe)))
     `(straight-use-package ',recipe))

   (defun +setup-warn (message &rest args)
     "Warn the user that something bad happened in `setup'."
     (display-warning 'setup (format message args)))

   (setup-define :face
     (lambda (face spec)
       `(custom-set-faces '(,face ,spec 'now "Customised by `setup'.")))
     :documentation "Customise FACE with SPEC using `custom-set-faces'."
     :repeatable t)

   (setup-define :pkg-when
     (lambda (recipe condition)
       `(if ,condition
            (straight-use-package ',recipe)
          ,(setup-quit)))
     :documentation
     "Install RECIPE with `straight-use-package' when CONDITION is met.
         If CONDITION is false, stop evaluating the body.  This macro can
         be used as HEAD, and will replace itself with the RECIPE's
         package.  This macro is not repeatable."
     :repeatable nil
     :indent 1
     :shorthand (lambda (sexp)
                  (let ((recipe (cadr sexp)))
                    (if (consp recipe) (car recipe) recipe))))

   (define-setup-macro :hide-mode (&optional mode)
     "Hide the mode-line lighter of the current mode. Alternatively, MODE can be
                      specified manually, and override the current mode."
     :after-loaded t
     (let ((mode (or mode (setup-get 'mode))))
       `(progn
          (setq minor-mode-alist
                (remq (assq ',(intern (format "%s-mode" mode)) minor-mode-alist)
                      minor-mode-alist))
          (setq minor-mode-alist
                (remq (assq ',mode minor-mode-alist)
                      minor-mode-alist)))))

   (define-setup-macro :load-after (features &rest body)
     "Load the current feature after FEATURES."
     :indent 1
     (let ((body `(progn
                    (require ',(setup-get 'feature))
                    ,@body)))
       (dolist (feature (nreverse (doom-enlist features)))
         (setq body `(with-eval-after-load ',feature ,body)))
       body))

   (define-setup-macro :disable ()
     "Unconditionally abort the evaluation of the current body."
     (setup-quit))

   (define-setup-macro :delay (seconds)
     "Require the current FEATURE after SECONDS of idle time."
     :indent 1
     `(run-with-idle-timer ,seconds nil #'require ',(setup-get 'feature) nil t))

   (define-setup-macro :with-idle-delay (seconds &rest body)
     "Evaluate BODY after SECONDS of idle time."
     :indent 1
     `(run-with-idle-timer ,seconds nil (lambda () ,@body)))

   (define-setup-macro :advise (symbol where arglist &rest body)
     "Add a piece of advice on a function. See 'advice-add' for more details."
     :after-loaded t
     :debug '(sexp sexp function-form)
     :indent 3
     (let ((name (gensym "setup-advice-")))
       `(progn
          (defun ,name ,arglist ,@body)
          (advice-add ',symbol ,where #',name))))

   (setup-define :needs
     (lambda (executable)
       `(unless (executable-find ,executable)
          ,(setup-quit)))
     :documentation "If EXECUTABLE is not in the path, stop here."
     :repeatable 1)


#+end_src
Sometimes it's good to clean up unused repositories if I've removed packages from my configuration.  Use =straight-remove-unused-repos= for this purpose.
** Emacs Startup Setup
:PROPERTIES:
:header-args: :noweb-ref emacs-startup
:END:
Show startup time
#+begin_src emacs-lisp
(setup show-startup-time
  (:with-hook emacs-startup-hook
    (:hook enfer/show-startup-time)))
#+end_src
*** Garbage collection automatic
Configure grabage collection
#+begin_src emacs-lisp
(setup (:pkg gcmh)
  (setq gcmh-auto-idle-delay-factor 10)
  (setq gcmh-high-cons-threshold (* 128 1024 1024))
  (setq gcmh-idle-delay 'auto)
  (gcmh-mode 1)
  (:hide-mode))
#+end_src

*** MAC PATH specific
#+begin_src emacs-lisp
  ;;(cua-mode 1)
  ;; load doom-path
  (if IS-MAC
      (doom-load-envars-file "~/.cache/emacs/env"))

  ;;    (setup (:pkg-when exec-path-from-shell IS-MAC)
  ;;      (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE" "GOPATH" "HOMEBREW_PREFIX"))
  ;;        (add-to-list 'exec-path-from-shell-variables var))
  ;;      (exec-path-from-shell-initialize)
  ;;      (add-to-list 'exec-path (expand-file-name "/bin" (getenv  "HOMEBREW_PREFIX")))
  ;;      )


#+end_src
*** Auto compile and Benchmarking
#+begin_src emacs-lisp

(setup (:pkg benchmark-init)
  (:disable) ; Disabled when not benchmarking.
  (define-advice define-obsolete-function-alias (:filter-args (ll))
    (let ((obsolete-name (pop ll))
          (current-name (pop ll))
          (when (if ll (pop ll) "1"))
          (docstring (if ll (pop ll) nil)))
      (list obsolete-name current-name when docstring)))
  (:require benchmark-init-modes)
  (:global-bind
   "<M-f2>" #'benchmark-init/show-durations-tabulated
   "<M-f3>" #'benchmark-init/show-durations-tree)
  (:with-hook after-init-hook
    (:hook benchmark-init/deactivate)))

(setup (:pkg auto-compile)
  (auto-compile-on-load-mode 1)
  (auto-compile-on-save-mode 1)
  (:hide-mode)
  (:hide-mode auto-compile-on-load))
#+end_src
*** Keep Emacs Directory clean
Use no-littering to automatically set common paths to the new user-emacs-directory
#+begin_src emacs-lisp
(setup (:pkg no-littering)
  (require 'no-littering))

#+end_src

* Emacs Sane defaults
Set Up Good Defaults. Taken from [[https://github.com/mfiano/dotfiles/blob/master/.emacs.d/lisp/mf-settings.el][mifano's emacs setup]]

Some constants that I use.
#+begin_src emacs-lisp :noweb-ref constants
(require 'subr-x)
;;; Initialise Constants
(defconst NATIVECOMP (if (fboundp 'native-comp-available-p) (native-comp-available-p)))
(defconst IS-MAC     (eq system-type 'darwin))
(defconst IS-LINUX   (eq system-type 'gnu/linux))
(defconst IS-TERMUX
  (string-suffix-p "Android" (string-trim (shell-command-to-string "uname -a"))))
#+end_src

* Emacs Packages
** Utility Functions & macros

These have been sucked from [[https://github.com/mfiano/dotfiles/blob/master/.emacs.d/lisp/mf-util.el][mifano]] and doom

*** Macros
:PROPERTIES:
:header-args: :noweb-ref macros
:END:
#+begin_src emacs-lisp
      (require 'cl-lib)

      (defmacro +with-message (message &rest body)
        "Execute BODY, with MESSAGE.
        If body executes without errors, MESSAGE...accomplie will be displayed."
        (declare (indent 1))
        (let ((msg (gensym)))
          `(let ((,msg ,message))
             (unwind-protect (progn (message "%s..." ,msg)
                                    ,@body)
               (message "%s...accomplie!" ,msg)))))

      (defmacro +define-dir (name directory &optional docstring inhibit-mkdir)
        "Define a variable and function NAME expanding to DIRECTORY.
      DOCSTRING is applied to the variable.  Ensure DIRECTORY exists in
      the filesystem, unless INHIBIT-MKDIR is non-nil."
        (declare (indent 2))
        (unless inhibit-mkdir
          (make-directory (eval directory) :parents))
        `(progn
           (defvar ,name ,directory
             ,(concat docstring (when docstring "\n")
                      "Defined by `/define-dir'."))
           (defun ,name (file &optional mkdir)
             ,(concat "Expand FILE relative to variable `" (symbol-name name) "'.\n"
                      "If MKDIR is non-nil, the directory is created.\n"
                      "Defined by `/define-dir'.")
             (let ((file-name (expand-file-name (convert-standard-filename file)
                                                ,name)))
               (when mkdir
                 (make-directory (file-name-directory file-name) :parents))
               file-name))))

      (defun +suppress-messages (oldfn &rest args) ; from pkal
        "Advice wrapper for suppressing `message'.
      OLDFN is the wrapped function, that is passed the arguments
      ARGS."
        (let ((msg (current-message)))
          (prog1
              (let ((inhibit-message t))
                (apply oldfn args))
            (when msg
              (message "%s" msg)))))

      (defmacro letenv! (envvars &rest body)
        "Lexically bind ENVVARS in BODY, like `let' but for `process-environment'."
        (declare (indent 1))
        `(let ((process-environment (copy-sequence process-environment)))
           (dolist (var (list ,@(cl-loop for (var val) in envvars
                                         collect `(cons ,var ,val))))
             (setenv (car var) (cdr var)))
           ,@body))

      (defmacro letf! (bindings &rest body)
        "Temporarily rebind function, macros, and advice in BODY.

          Intended as syntax sugar for `cl-letf', `cl-labels', `cl-macrolet', and
          temporary advice.

          BINDINGS is either:

            A list of, or a single, `defun', `defun*', `defmacro', or `defadvice' forms.
            A list of (PLACE VALUE) bindings as `cl-letf*' would accept.

          TYPE is one of:

            `defun' (uses `cl-letf')
            `defun*' (uses `cl-labels'; allows recursive references),
            `defmacro' (uses `cl-macrolet')
            `defadvice' (uses `defadvice!' before BODY, then `undefadvice!' after)

          NAME, ARGLIST, and BODY are the same as `defun', `defun*', `defmacro', and
          `defadvice!', respectively.

          \(fn ((TYPE NAME ARGLIST &rest BODY) ...) BODY...)"
        (declare (indent defun))
        (setq body (macroexp-progn body))
        (when (memq (car bindings) '(defun defun* defmacro defadvice))
          (setq bindings (list bindings)))
        (dolist (binding (reverse bindings) body)
          (let ((type (car binding))
                (rest (cdr binding)))
            (setq
             body (pcase type
                    (`defmacro `(cl-macrolet ((,@rest)) ,body))
                    (`defadvice `(progn (defadvice! ,@rest)
                                        (unwind-protect ,body (undefadvice! ,@rest))))
                    ((or `defun `defun*)
                     `(cl-letf ((,(car rest) (symbol-function #',(car rest))))
                        (ignore ,(car rest))
                        ,(if (eq type 'defun*)
                             `(cl-labels ((,@rest)) ,body)
                           `(cl-letf (((symbol-function #',(car rest))
                                       (fn! ,(cadr rest) ,@(cddr rest))))
                              ,body))))
                    (_
                     (when (eq (car-safe type) 'function)
                       (setq type (list 'symbol-function type)))
                     (list 'cl-letf (list (cons type rest)) body)))))))

      (defmacro fn (&rest body)
        `(lambda () ,@body))

      (defmacro fn! (&rest body)
        `(lambda () (interactive) ,@body))

                ;;; Closure factories
      (defmacro fn!! (arglist &rest body)
        "Returns (cl-function (lambda ARGLIST BODY...))
              The closure is wrapped in `cl-function', meaning ARGLIST will accept anything
              `cl-defun' will. Implicitly adds `&allow-other-keys' if `&key' is present in
              ARGLIST."
        (declare (indent defun) (doc-string 1) (pure t) (side-effect-free t))
        `(cl-function
          (lambda
            ,(letf! (defun* allow-other-keys (args)
                      (mapcar
                       (lambda (arg)
                         (cond ((nlistp (cdr-safe arg)) arg)
                               ((listp arg) (allow-other-keys arg))
                               (arg)))
                       (if (and (memq '&key args)
                                (not (memq '&allow-other-keys args)))
                           (if (memq '&aux args)
                               (let (newargs arg)
                                 (while args
                                   (setq arg (pop args))
                                   (when (eq arg '&aux)
                                     (push '&allow-other-keys newargs))
                                   (push arg newargs))
                                 (nreverse newargs))
                             (append args (list '&allow-other-keys)))
                         args)))
               (allow-other-keys arglist))
            ,@body)))

      (defmacro cmd! (&rest body)
        "Returns (lambda () (interactive) ,@body)
              A factory for quickly producing interaction commands, particularly for keybinds
              or aliases."
        (declare (doc-string 1) (pure t) (side-effect-free t))
        `(lambda (&rest _) (interactive) ,@body))

      (defmacro quiet! (&rest forms)
        `(cond
          (noninteractive
           (let ((old-fn (symbol-function 'write-region)))
             (cl-letf ((standard-output (lambda (&rest _)))
                       ((symbol-function 'load-file)
                        (lambda (file) (load file nil t)))
                       ((symbol-function 'message) (lambda (&rest _)))
                       ((symbol-function 'write-region)
                        (lambda (start end filename &optional append visit lockname
                                       mustbenew)
                          (unless visit (setq visit 'no-message))
                          (funcall old-fn start end filename append visit lockname
                                   mustbenew))))
               ,@forms)))
          ((or debug-on-error debug-on-quit)
           ,@forms)
          ((let ((inhibit-message t)
                 (save-silently t))
             (prog1 ,@forms (message ""))))))

            ;;; Mutation
      (defmacro appendq! (sym &rest lists)
        "Append LISTS to SYM in place."
        `(setq ,sym (append ,sym ,@lists)))

      (defmacro setq! (&rest settings)
        "A stripped-down `customize-set-variable' with the syntax of `setq'.

            This can be used as a drop-in replacement for `setq'. Particularly when you know
            a variable has a custom setter (a :set property in its `defcustom' declaration).
            This triggers setters. `setq' does not."
        (macroexp-progn
         (cl-loop for (var val) on settings by 'cddr
                  collect `(funcall (or (get ',var 'custom-set) #'set)
                                    ',var ,val))))

      (defmacro delq! (elt list &optional fetcher)
        "`delq' ELT from LIST in-place.

            If FETCHER is a function, ELT is used as the key in LIST (an alist)."
        `(setq ,list
               (delq ,(if fetcher
                          `(funcall ,fetcher ,elt ,list)
                        elt)
                     ,list)))

      (defmacro pushnew! (place &rest values)
        "Push VALUES sequentially into PLACE, if they aren't already present.
            This is a variadic `cl-pushnew'."
        (let ((var (make-symbol "result")))
          `(dolist (,var (list ,@values) (with-no-warnings ,place))
             (cl-pushnew ,var ,place :test #'equal))))

      (defmacro prependq! (sym &rest lists)
        "Prepend LISTS to SYM in place."
        `(setq ,sym (append ,@lists ,sym)))

  ;;; Loading
      (defmacro add-load-path! (&rest dirs)
        "Add DIRS to `load-path', relative to the current file.
            The current file is the file from which `add-to-load-path!' is used."
        `(let ((default-directory ,(dir!))
               file-name-handler-alist)
           (dolist (dir (list ,@dirs))
             (cl-pushnew (expand-file-name dir) load-path :test #'string=))))

 #+end_src
*** Variables
:PROPERTIES:
:header-args: :noweb-ref variables
:END:
#+begin_src emacs-lisp
(defvar enfer/ignored-directories
  `(,user-emacs-directory
    "eln-cache"))

(defvar enfer/ignored-suffixes
  '(".7z" ".bz2" ".db" ".dll" ".dmg" ".elc" ".exe" ".fasl" ".gz" ".iso" ".jar"
    ".o" ".pyc" ".rar" ".so" ".sql" ".sqlite" ".tar" ".tgz" ".xz" ".zip"))
#+end_src
*** Functions
:PROPERTIES:
:header-args: :noweb-ref functions
:END:
#+begin_src emacs-lisp
  (defun enfer/show-startup-time ()
    (message "Heure de démarrage d'Emacs: %.2fs (%d GCs (ramasse-miettes))"
             (float-time (time-subtract after-init-time before-init-time))
             gcs-done))

  (defun /etc-file (file-name)
    (expand-file-name (format "etc/%s" file-name) user-emacs-directory))

  (defun enfer/cache-dir-p (path)
    (string-prefix-p (getenv "XDG_CACHE_HOME") (expand-file-name path)))

  (+define-dir /etc (locate-user-emacs-file "etc")
    "Directory for all of Emacs's various files.
    See `no-littering' for examples.")

  (+define-dir sync/ (expand-file-name "~/Sync")
    "My Syncthing directory.")


  (defun mf/smarter-move-beginning-of-line (arg)
    (interactive "^p")
    (setq arg (or arg 1))
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))
    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  (defun mf/yank-primary-selection ()
    (interactive)
    (let ((primary (or (gui-get-primary-selection) (gui-get-selection))))
      (when primary
        (push-mark (point))
        (insert-for-yank primary))))

  (defun mf/delete-file (filename)
    (interactive "f")
    (when (and filename (file-exists-p filename))
      (let ((buffer (find-buffer-visiting filename)))
        (when buffer
          (kill-buffer buffer)))
      (delete-file filename)))

  (defun mf/rename-file ()
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' n'a ​​pas de fichier associé!" name)
        (let* ((dir (file-name-directory filename))
               (new-name (read-file-name "Nouveau nom de fichier: " dir)))
          (cond ((get-buffer new-name)
                 (error "Un Buffer nommé '%s' existe déjà!" new-name))
                (t
                 (let ((dir (file-name-directory new-name)))
                   (when (and (not (file-exists-p dir))
                              (yes-or-no-p (format "Créer le répertoire '%s'?"
                                                   dir)))
                     (make-directory dir t)))
                 (rename-file filename new-name 1)
                 (rename-buffer new-name)
                 (set-visited-file-name new-name)
                 (set-buffer-modified-p nil)
                 (when (fboundp 'recentf-add-file)
                   (recentf-add-file new-name)
                   (recentf-remove-if-non-kept filename))
                 (message "Fichier '%s' renommé avec succès en '%s'" name
                          (file-name-nondirectory new-name))))))))

  (defun doom-unquote (exp)
    "Return EXP unquoted."
    (declare (pure t) (side-effect-free t))
    (while (memq (car-safe exp) '(quote function))
      (setq exp (cadr exp)))
    exp)

  (defun doom-enlist (exp)
    "Return EXP wrapped in a list, or as-is if already a list."
    (declare (pure t) (side-effect-free t))
    (if (proper-list-p exp) exp (list exp)))

  (defun doom-keyword-intern (str)
    "Converts STR (a string) into a keyword (`keywordp')."
    (declare (pure t) (side-effect-free t))
    (cl-check-type str string)
    (intern (concat ":" str)))

  (defun doom-keyword-name (keyword)
    "Returns the string name of KEYWORD (`keywordp') minus the leading colon."
    (declare (pure t) (side-effect-free t))
    (cl-check-type keyword keyword)
    (substring (symbol-name keyword) 1))


  (defun doom-load-envvars-file (file &optional noerror)
    "Read and set envvars from FILE.
        If NOERROR is non-nil, don't throw an error if the file doesn't exist or is
        unreadable. Returns the names of envvars that were changed."
    (if (null (file-exists-p file))
        (unless noerror
          (signal 'file-error (list "No envvar file exists" file)))
      (with-temp-buffer
        (insert-file-contents file)
        (when-let (env (read (current-buffer)))
          (let ((tz (getenv-internal "TZ")))
            (setq-default
             process-environment
             (append env (default-value 'process-environment))
             exec-path
             (append (split-string (getenv "PATH") path-separator t)
                     (list exec-directory))
             shell-file-name
             (or (getenv "SHELL")
                 (default-value 'shell-file-name)))
            (when-let (newtz (getenv-internal "TZ"))
              (unless (equal tz newtz)
                (set-time-zone-rule newtz))))
          env))))

  (defun +ensure-after-init (function)
    "Ensure FUNCTION runs after init, or now if already initialised.
  If Emacs is already started, run FUNCTION.  Otherwise, add it to
  `after-init-hook'.  FUNCTION is called with no arguments."
    (if after-init-time
        (funcall function)
      (add-hook 'after-init-hook function)))

  ;;
      ;;; Sugars

  (defun dir! ()
    "Returns the directory of the emacs lisp file this macro is called from."
    (when-let (path (file!))
      (directory-file-name (file-name-directory path))))

  (defun file! ()
    "Return the emacs lisp file this macro is called from."
    (cond ((bound-and-true-p byte-compile-current-file))
          (load-file-name)
          ((stringp (car-safe current-load-list))
           (car current-load-list))
          (buffer-file-name)
          ((error "Cannot get this file-path"))))

#+end_src
** Setup if exists Executable
ripgrep and gist
#+begin_src emacs-lisp :noweb-ref pkg-utils
  (setup (:pkg rg)
    (:when-loaded
      (setq rg-group-result t)
      (setq rg-ignore-case 'smart)))

  (setup (:pkg gist)
  (setq gist-view-gist t)
  (:hide-mode))

(setup (:pkg link-hint)
  (:require link-hint))
#+end_src
** Emacs UI Appearance
:PROPERTIES:
:header-args: :noweb-ref pkg-ui
:END:
*** Default Appearance setting
Some Defaults for my preferred appearance
#+begin_src emacs-lisp
    (setup appearance
    (setq blink-matching-paren nil)
    (setq display-time-default-load-average nil)
    (setq echo-keystrokes 0.1)
    (setq highlight-nonselected-windows nil)
    (setq idle-update-delay 1.0)
    (setq inhibit-startup-echo-area-message t)
    (setq inhibit-startup-screen t)
    (setq use-dialog-box nil)
    (setq use-file-dialog nil)
    (setq visible-bell nil)
    (setq x-gtk-use-system-tooltips nil)
    (setq x-stretch-cursor nil)
    (setq-default bidi-display-reordering 'left-to-right)
    (setq-default bidi-paragraph-direction 'left-to-right)
    (setq-default cursor-in-non-selected-windows nil)
    (setq-default cursor-type 'hbar)
    (setq-default display-line-numbers-widen t)
    (setq-default display-line-numbers-width 3)
    (setq-default indicate-buffer-boundaries nil)
    (setq-default truncate-lines t)
    (:with-hook (prog-mode-hook text-mode-hook conf-mode-hook)
      (:hook display-line-numbers-mode))
    (:with-hook text-mode-hook
      (:hook visual-line-mode)))
#+end_src
*** Menu and Tool bars
#+begin_src elisp
(menu-bar-mode -1)            ; Disable the menu bar
(unless IS-TERMUX
  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room
  (menu-bar-mode 1))

;; Set up the visible bell
(setq visible-bell t)
#+end_src
*** Fonts & Emojis

On Linux, I have a custom build of Iosevka that I like.

#+begin_src emacs-lisp :noweb-ref pkg-ui
  (setup (:pkg all-the-icons)
    (:load-after marginalia
      (:pkg all-the-icons-completion)
      (all-the-icons-completion-mode 1)
      (:with-mode marginalia-mode
        (:hook all-the-icons-completion-marginalia-setup)))
    (:load-after dired
      (:pkg all-the-icons-dired)
      (:with-mode dired-mode
        (:hook all-the-icons-dired-mode))))

  (setup (:pkg emojify)
    (setq emojify-emoji-styles '(unicode))
    (global-emojify-mode 1))

  (setup (:pkg unicode-fonts)
    (unicode-fonts-setup))

  (setup (:pkg mixed-pitch)
      (:hook-into text-mode)

  ;; Set the font face based on platform
  (pcase system-type
    ((or 'gnu/linux 'windows-nt 'cygwin)
     (set-face-attribute 'default nil
                         :font "JetBrains Mono"
                         :weight 'light
                         :height 120
                         ))
    ('darwin (set-face-attribute 'default nil :font "Fira Mono" :height 130)))

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil
                      :font "JetBrains Mono"
                      :weight 'light
                      )

  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil
                      ;; :font "Cantarell"
                      :font "Iosevka Aile"
                      :weight 'light))

  ;; Required for proportional font in posframe
  (setup (:pkg company-posframe)
    (company-posframe-mode 1))

  (setup (:pkg default-text-scale)
    (:bind
     "M--" default-text-scale-decrease
     "M-+" default-text-scale-increase
     "M-=" default-text-scale-reset)
    (default-text-scale-mode 1))

  (setup (:pkg dimmer)
    (setq dimmer-fraction 0.3)
    (dimmer-mode 1))
#+end_src

*** Frame titles, sizes and mouse setup

#+begin_src emacs-lisp
  (setq-default frame-title-format
                (concat invocation-name "@" (system-name)
                        ": %b %+%+ %f"))

  (unless IS-TERMUX
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
    (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
    (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
    (setq scroll-step 1) ;; keyboard scroll one line at a time
    (setq use-dialog-box nil)) ;; Disable dialog boxes since they weren't working in Mac OSX

  (unless IS-TERMUX
    (set-frame-parameter (selected-frame) 'alpha '(90 . 90))
    (add-to-list 'default-frame-alist '(alpha . (90 . 90)))
    (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
    (add-to-list 'default-frame-alist '(fullscreen . maximized)))
#+end_src

*** Themes & Modeline

#+begin_src emacs-lisp
  (setup (:pkg spacegray-theme))
  (setup (:pkg doom-themes)
    (setq doom-themes-enable-bold t)
    (setq doom-themes-enable-italic t)
    (doom-themes-org-config))

  (unless IS-TERMUX
   ;; (load-theme 'doom-palenight t)
    (doom-themes-visual-bell-config))

  ;; Mode-line
  ;;Basic Customisation
  (setq display-time-format "%l:%M %p %b %y"
        display-time-default-load-average nil)

  ;; Doom Modeline

  (setup (:pkg minions)
    (:hook-into doom-modeline-mode))

  (setup (:pkg doom-modeline)
   ;; (setq doom-modeline-bar-width 4)
    (setq doom-modeline-buffer-encoding nil)
    (setq doom-modeline-buffer-file-name-style 'relative-from-project)
    (setq doom-modeline-height 30)
    (setq doom-modeline-major-mode-icon t)
    (setq doom-modeline-minor-modes t)
    (:with-hook window-setup-hook
      (:hook (fn (set-face-attribute
                  'mode-line nil :family "Iosevka Slab" :height 130))))
    (:hook-into window-setup)
    (:option doom-modeline-height 15
             doom-modeline-bar-width 6
             doom-modeline-lsp t
             doom-modeline-github nil
             doom-modeline-mu4e nil
             doom-modeline-irc t
             doom-modeline-minor-modes t
             doom-modeline-persp-name nil
             doom-modeline-buffer-file-name-style 'truncate-except-project
             doom-modeline-major-mode-icon nil)
    (custom-set-faces '(mode-line ((t (:height 0.85))))
                      '(mode-line-inactive ((t (:height 0.85))))))


#+end_src
*** Don't show default modeline

Wait until my *fancy* modeline is loaded -- from [[https://github.com/KaratasFurkan/.emacs.d#remove-redundant-ui][Furkan Karataş]].

#+begin_src emacs-lisp
  (setq-default mode-line-format nil)
#+end_src
*** highlights and diff
setup diff and highlights
#+begin_src emacs-lisp
  (setup (:pkg highlight-numbers)
    (:hook-into prog-mode)
    (:hide-mode))

  (setup (:pkg hl-fill-column)
    (:require hl-fill-column)
    (:hook-into prog-mode text-mode conf-mode))

  (setup (:pkg hl-line)
    (global-hl-line-mode 1))

  (setup (:pkg hl-todo)
    (global-hl-todo-mode 1))

(setup (:pkg diff-hl)
  (global-diff-hl-mode 1)
  (:with-mode dired-mode
    (:hook diff-hl-dired-mode))
  (:load-after magit
    (:with-hook magit-pre-refresh-hook
      (:hook diff-hl-magit-pre-refresh))
    (:with-hook magit-post-refresh-hook
      (:hook diff-hl-magit-post-refresh))))
#+end_src
*** Window Setup
:PROPERTIES:
:header-args: :noweb-ref pkg-window
:END:

1st some defaults

#+begin_src emacs-lisp
  (setup windows
      (setq split-height-threshold nil)
      (setq split-width-threshold 160)
      (setq window-divider-default-bottom-width 2)
      (setq window-divider-default-places t)
      (setq window-divider-default-right-width 2)
      (setq window-resize-pixelwise nil))

#+end_src
#+begin_src emacs-lisp :noweb-ref pkg-window
  (setup (:pkg ace-window)
    (setq aw-background t)
    (setq aw-scope 'frame)
    (ace-window-display-mode 1)
    (:hide-mode))

  (setup (:pkg shackle)
  (setq shackle-rules
        `((compilation-mode
           :select t :align right :size 0.33)
          (magit-status-mode
           :select t :align right :size 0.5)
          ((help-mode helpful-mode)
           :select t :align right :size 0.4)
          ((sly-xref-mode "\\*\\(sly-mrepl\\|ielm\\)")
           :regexp t :noselect t :align below :size 0.24)))
  (shackle-mode 1))

(setup (:pkg windmove)
  (windmove-default-keybindings))

(setup (:pkg winner)
  (winner-mode 1))
  (setq-default window-divider-default-places 'right-only ; only right
                window-divider-default-bottom-width 2
                window-divider-default-right-width 2)
#+end_src

#+begin_src emacs-lisp :noweb-ref pkg-ui
  (window-divider-mode +1)
#+end_src

**** Splitting windows sensibly

This is extremely fiddly and I'd love another option.
- [[https://www.emacswiki.org/emacs/ToggleWindowSplit][ToggleWindowSplit, EmacsWiki]]

#+begin_src emacs-lisp :noweb-ref pkg-window
  (setq-default split-width-threshold 100
                split-height-threshold 50)
#+end_src
*** Fringes
:PROPERTIES:
:header-args: :noweb-ref pkg-window
:END:

I have grown to love Emacs's little fringes on the side of the
windows.  In fact, I love them so much that I really went overboard
and have made a custom fringe bitmap.

**** Indicate empty lines after the end of the buffer

#+begin_src emacs-lisp
  (setq-default indicate-empty-lines t)
#+end_src

**** Indicate the boundaries of the buffer

#+begin_src emacs-lisp
  (setq-default indicate-buffer-boundaries 'right)
#+end_src

**** Indicate continuation lines, but only on the left fringe

#+begin_src emacs-lisp
  (setq-default visual-line-fringe-indicators '(left-curly-arrow nil))
#+end_src

**** Customise fringe bitmaps

***** Curly arrows (continuation lines)

#+begin_src emacs-lisp
  (define-fringe-bitmap 'left-curly-arrow
    [#b11000000
     #b01100000
     #b00110000
     #b00011000])

  (define-fringe-bitmap 'right-curly-arrow
    [#b00011000
     #b00110000
     #b01100000
     #b11000000])
#+end_src

***** Arrows (truncation lines)

#+begin_src emacs-lisp
  (define-fringe-bitmap 'left-arrow
    [#b00000000
     #b01010100
     #b01010100
     #b00000000])

  (define-fringe-bitmap 'right-arrow
    [#b00000000
     #b00101010
     #b00101010
     #b00000000])
#+end_src
*** Project Setup
setup of git and projectile
#+begin_src emacs-lisp :noweb-ref pkg-project

(setup (:pkg git-timemachine)
    (:bind
     "[" git-timemachine-show-previous-revision
     "]" git-timemachine-show-next-revision
     "b" git-timemachine-blame))

(setup (:pkg magit)
  (setq git-commit-summary-max-length 120)
  (setq magit-commit-show-diff nil)
  (setq magit-delete-by-moving-to-trash nil)
  (setq magit-display-buffer-function
        #'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-log-auto-more t)
  (setq magit-log-margin-show-committer-date t)
  (setq magit-revert-buffers 'silent)
  (setq magit-save-repository-buffers 'dontask)
  (setq magit-wip-after-apply-mode t)
  (setq magit-wip-after-save-mode t)
  (setq magit-wip-before-change-mode t)
  (setq transient-values
        '((magit-log:magit-log-mode "--graph" "--color" "--decorate"))))

(setup magit-wip
  (:load-after magit
    (magit-wip-mode 1)
    (:hide-mode)))

(setup (:pkg magit-todos)
  (:load-after magit
    (magit-todos-mode 1)))

(setup (:pkg persp-projectile)
  (:load-after (perspective projectile)))

(setup (:pkg perspective)
  (setq persp-modestring-short t)
  (setq persp-show-modestring t)
  (setq persp-sort 'name)
  (setq persp-state-default-file (/etc-file "perspectives"))
  (setq persp-switch-wrap nil)
  (persp-mode 1)
  (:global
   "M-1" (fn! (persp-switch-by-number 1))
   "M-2" (fn! (persp-switch-by-number 2))
   "M-3" (fn! (persp-switch-by-number 3))
   "M-4" (fn! (persp-switch-by-number 4))
   "M-5" (fn! (persp-switch-by-number 5))
   "M-6" (fn! (persp-switch-by-number 6))
   "M-7" (fn! (persp-switch-by-number 7))
   "M-8" (fn! (persp-switch-by-number 8))
   "M-9" (fn! (persp-switch-by-number 9))))

(setup (:pkg projectile)
  (setq projectile-cache-file (/etc-file "projectile.cache"))
  (setq projectile-kill-buffers-filter 'kill-only-files)
  (setq projectile-known-projects-file (/etc-file "projectile-bookmarks"))
  (projectile-mode 1)
  (setq projectile-find-dir-includes-top-level t)
  (setf projectile-globally-ignored-directories
        (delete-dups (append projectile-globally-ignored-directories
                             enfer/ignored-directories)))
  (setq projectile-globally-ignored-file-suffixes enfer/ignored-suffixes)
  (:with-idle-delay 15 (quiet! (projectile-cleanup-known-projects)))
  (:hide-mode))
#+end_src
*** Buffers
PROPERTIES:
:header-args: :noweb-ref sanity
:END:
Setup Scatch and minibuffer
#+begin_src emacs-lisp
          (setup scratch
            (setq initial-major-mode #'emacs-lisp-mode)
            (setq initial-scratch-message
                  ";; ABANDONNEZ TOUT ESPOIR VOUS QUI ENTREZ ICI\n\n" )
            (defun +scratch-immortal ()
              "Bury, don't kill \"*scratc*\" buffer.
            For `kill-buffer-query-functions'."
              (if (eq (current-buffer) (get-buffer "*scratch*"))
                  (progn (bury-buffer)
                         nil)
                t))
            (defun +scratch-buffer-setup ()
              "Add comment to `scratch' buffer and name it accordingly."
              (let* ((mode (format "%s" major-mode))
                     (string (concat "Scratch buffer for:" mode "\n\n")))
                (when scratch-buffer
                  (save-excursion
                    (insert string)
                    (goto-char (point-min))
                    (comment-region (point-at-bol) (point-at-eol)))
                  (next-line 2))
                (rename-buffer (concat "*scratch<" mode ">*") t)))
            (add-hook 'kill-buffer-query-functions #'+scratch-immortal))

          (setup minibuffer
            (file-name-shadow-mode 1)
            (minibuffer-depth-indicate-mode 1)
            (minibuffer-electric-default-mode 1)
            (fset #'yes-or-no-p #'y-or-n-p)
            (setq enable-recursive-minibuffers t)
            (setq file-name-shadow-properties '(invisible t intangible t))
            (setq minibuffer-eldef-shorten-default t)
            (setq minibuffer-prompt-properties
                  '(read-only t cursor-intangible t face minibuffer-prompt))
            (setq read-answer-short t)
            (setq read-extended-command-predicate #'command-completion-default-include-p)
            (setq use-short-answers t)
            ;; https://www.manueluberti.eu//emacs/2021/12/10/shell-command/
            (defun +minibuffer-complete-history ()
              "Complete minibuffer history."
              (interactive)
              (completion-in-region (minibuffer--completion-prompt-end) (point-max)
                                    (symbol-value minibuffer-history-variable)
                                    nil))
            (:with-hook minibuffer-setup-hook
              (:hook cursor-intangible-mode))
            (:with-map minibuffer-local-map
              (:bind "M-/" #'+minibuffer-complete-history))
            (:with-map minibuffer-inactive-mode-map
              (:bind "<mouse-1>" ignore)))

      (setup ibuffer
          (:also-load ibuf-ext)
          (:option ibuffer-expert t
                   ibuffer-show-empty-filter-groups nil
                   ibuffer-saved-filter-groups
                   '(("default"
                      ("Org" (mode . org-mode))
                      ("emacs" (or (name . "^\\*scratch\\*$")
                                   (name . "^\\*Messages\\*$")
                                   (name . "^\\*Warnings\\*$")
                                   (name . "^\\*straight-process\\*$")
                                   (name . "^\\*Calendar\\*$")))
                      ("customize" (mode . Custom-mode))
                      ("emacs-config" (or (filename . ".emacs.d")
                                          (mode . +init-mode)))
                      ("git" (or (name . "^\*magit")
                                 (name . "^\magit")))
                      ("help" (or (mode . help-mode)
                                  (mode . Info-mode)
                                  (mode . helpful-mode)))
                      ("irc" (or (mode . erc-mode)
                                 (mode . circe-server-mode)
                                 (mode . circe-channel-mode)))
                      ("shell" (or (mode . eshell-mode)
                                   (mode . shell-mode)
                                   (mode . vterm-mode)))
                      ("web" (or (mode . elpher-mode)
                                 (mode . eww-mode))))))
          (:hook (defun ibuffer@filter-to-default ()
                   (ibuffer-auto-mode +1)
                   (ibuffer-switch-to-saved-filter-groups "default"))))
  #+end_src

  The default way Emacs makes buffer names unique is really ugly and,
  dare I say it, stupid.  Instead, I want them to be uniquified by their
  filesystem paths.

#+begin_src emacs-lisp
  (setup (:require uniquify)
    (setq uniquify-after-kill-buffer-p t)
    (setq uniquify-buffer-name-style 'forward)
    (setq-default
     uniquify-separator "/"
     uniquify-ignore-buffers-re "^\\*"))

#+end_src

** Emacs as an Editor
:PROPERTIES:
:header-args: :noweb-ref pkg-editor
:END:
The visual-line-mode function enables line-wrapping. You can run the function separately for each buffer, but ideally, you hook it to all text modes.

When you select (mark) a section of text and start typing, Emacs will not replace the selected text. To enable Emacs deleting selected text, you set the delete-selection-mode variable, as below.

One last sensible default is to enure that Emacs lets you use the page-up and page-down buttons to
go to the first and last line in the buffer.
#+begin_src emacs-lisp
    ;; Sensible line breaking
  ;;(add-hook 'text-mode-hook 'visual-line-mode)

  ;; Overwrite selected text
  (setup (:require delsel)
    (delete-selection-mode t))

  ;; Scroll to the first and last line of the buffer
  (setq scroll-error-top-bottom t)
#+end_src
Undo is a key function of an editor - bind to Ctrl-Z - disabled
#+begin_src emacs-lisp :tangle no
  ;;undo
  (setup (:pkg undo-tree)
    (:hide-mode)
    (:global "C-z"   undo-tree-undo
           "C-S-z" undo-tree-redo)
    (setq undo-tree-auto-save-history nil)
    (global-undo-tree-mode 1))
    #+end_src
*** Spelling
The configuration below enables Flyspell for all text modes and sets Hunspell as the default checking program. The M-F7 key checks the spelling for all words in the buffer and F7 checks the word that you cursor is standing on.

A more productive method is to use the C-; function. This function provides the most likely correction of the first spelling error before the cursor is. Emacs will show the list of possible corrections in the mini buffer. Repeatedly pressing C-; will cycle through the options until you get back to the original. This function prevents you from having to jump to your spelling mistakes.
#+begin_src emacs-lisp
    (setup flyspell
    (:needs (or (executable-find "ispell")
                (executable-find "aspell")
                (executable-find "hunspell")))

      (:hook-into org-mode-hook git-commit-mode-hook markdown-mode-hook)
      (:bind "M-<f7>"  flyspell-buffer
             "<f7>"    flyspell-word
             "C-;"     flyspell-auto-correct-previous-word
             )
      (progn
        (cond
         ((executable-find "aspell")
          (setq ispell-program-name "aspell")
          (setq ispell-extra-args   '("--sug-mode=ultra"
                                      "--lang=en_AU")))
         ((executable-find "hunspell")
          (setq ispell-program-name "hunspell")
          (setq ispell-extra-args   '("-d en_AU"))))

        ;; Save a new word to personal dictionary without asking
        (setq ispell-silently-savep t)
        (setq ispell-default-dictionary "en_AU"))

      (defun avy-action-flyspell (pt)
        (save-excursion
          (goto-char pt)
          (when (require 'flyspell nil t)
            (flyspell-auto-correct-word)))
        (select-window
         (cdr (ring-ref avy-ring 0)))
        t)

      ;; Bind to semicolon (flyspell uses C-;)
      (setf (alist-get ?\; avy-dispatch-alist) 'avy-action-flyspell)

      (:when-loaded
        (:hide-mode)))
#+end_src

I use the dictionary package for Emacs, and I’m lazy about it:
#+begin_src emacs-lisp
(setup (:pkg dictionary)

(defun dictionary-search-dwim (&optional arg)
  "Search for definition of word at point. If region is active,
search for contents of region instead. If called with a prefix
argument, query for word to search."
  (interactive "P")
  (if arg
      (dictionary-search nil)
    (if (use-region-p)
        (dictionary-search (buffer-substring-no-properties
                            (region-beginning)
                            (region-end)))
      (if (thing-at-point 'word)
          (dictionary-lookup-definition)
        (dictionary-search-dwim '(4))))))

(defun avy-action-define (pt)
  (save-excursion
    (goto-char pt)
    (dictionary-search-dwim))
  (select-window
   (cdr (ring-ref avy-ring 0)))
  t)

(setf (alist-get ?= avy-dispatch-alist) 'dictionary-search-dwim))
#+end_src

*** Avy - Filter, Select, Act
Setup avy in filter, select, act mode
#+begin_src emacs-lisp
  (setup (:pkg avy)
    (:global  "M-j"  'avy-goto-char-timer
              "C-M-s" 'isearch-forward-other-window
              "C-M-r" 'isearch-backward-other-window)
    (setq avy-keys '(?q ?e ?r ?y ?u ?o ?p
                        ?a ?s ?d ?f ?g ?h ?j
                        ?k ?l ?' ?x ?c ?v ?b
                        ?n ?, ?/))
    (defun avy-show-dispatch-help ()
      (let* ((len (length "avy-action-"))
             (fw (frame-width))
             (raw-strings (mapcar
                           (lambda (x)
                             (format "%2s: %-19s"
                                     (propertize
                                      (char-to-string (car x))
                                      'face 'aw-key-face)
                                     (substring (symbol-name (cdr x)) len)))
                           avy-dispatch-alist))
             (max-len (1+ (apply #'max (mapcar #'length raw-strings))))
             (strings-len (length raw-strings))
             (per-row (floor fw max-len))
             display-strings)
        (cl-loop for string in raw-strings
                 for N from 1 to strings-len do
                 (push (concat string " ") display-strings)
                 (when (= (mod N per-row) 0) (push "\n" display-strings)))
        (message "%s" (apply #'concat (nreverse display-strings)))))

    ;; Kill text
    (defun avy-action-kill-whole-line (pt)
      (save-excursion
        (goto-char pt)
        (kill-whole-line))
      (select-window
       (cdr
        (ring-ref avy-ring 0)))
      t)

    (setf (alist-get ?k avy-dispatch-alist) 'avy-action-kill-stay
          (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line)

    ;; Copy text
    (defun avy-action-copy-whole-line (pt)
      (save-excursion
        (goto-char pt)
        (cl-destructuring-bind (start . end)
            (bounds-of-thing-at-point 'line)
          (copy-region-as-kill start end)))
      (select-window
       (cdr
        (ring-ref avy-ring 0)))
      t)

    (setf (alist-get ?w avy-dispatch-alist) 'avy-action-copy
          (alist-get ?W avy-dispatch-alist) 'avy-action-copy-whole-line)

    ;; Yank text
    (defun avy-action-yank-whole-line (pt)
      (avy-action-copy-whole-line pt)
      (save-excursion (yank))
      t)

    (setf (alist-get ?y avy-dispatch-alist) 'avy-action-yank
          (alist-get ?Y avy-dispatch-alist) 'avy-action-yank-whole-line)

    ;; Transpose/Move text
    (defun avy-action-teleport-whole-line (pt)
      (avy-action-kill-whole-line pt)
      (save-excursion (yank)) t)

    (setf (alist-get ?t avy-dispatch-alist) 'avy-action-teleport
          (alist-get ?T avy-dispatch-alist) 'avy-action-teleport-whole-line)

    ;; Mark text
    (defun avy-action-mark-to-char (pt)
      (activate-mark)
      (goto-char pt))

    (setf (alist-get ?  avy-dispatch-alist) 'avy-action-mark-to-char)

    ;; Avy + Isearch
    (define-key isearch-mode-map (kbd "M-j") 'avy-isearch)

    ;; Isearch in other windows
    (defun isearch-forward-other-window (prefix)
      "Function to isearch-forward in other-window."
      (interactive "P")
      (unless (one-window-p)
        (save-excursion
          (let ((next (if prefix -1 1)))
            (other-window next)
            (isearch-forward)
            (other-window (- next))))))

    (defun isearch-backward-other-window (prefix)
      "Function to isearch-backward in other-window."
      (interactive "P")
      (unless (one-window-p)
        (save-excursion
          (let ((next (if prefix 1 -1)))
            (other-window next)
            (isearch-backward)
            (other-window (- next))))))

    (setq avy-all-windows t)
    )

#+end_src

*** Encodings & Whitespace
Setup encodings
#+begin_src emacs-lisp :noweb-ref sanity

  (setup encoding
  (setq coding-system-for-read 'utf-8-unix)
  (setq coding-system-for-write 'utf-8-unix)
  (setq default-process-coding-system '(utf-8-unix utf-8-unix))
  (setq locale-coding-system 'utf-8-unix)
  (setq selection-coding-system 'utf-8)
  (setq x-select-request-type nil)
  (setq-default buffer-file-coding-system 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
  (set-clipboard-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8-unix)
  (set-keyboard-coding-system 'utf-8-unix)
  (set-language-environment "UTF-8")
  (set-selection-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8-unix))

#+end_src
Setup undo , whitespace, expand, indentation
#+begin_src emacs-lisp
   (setup (:pkg aggressive-indent)
     (:hook-into prog-mode)
     (:hide-mode))

   (setup (:pkg hungry-delete)
     (:load-after smartparens
       (setq hungry-delete-join-reluctantly t)
       (global-hungry-delete-mode 1)
       (:hook-into smartparens-enabled)
       (:hide-mode)))

   (setup (:pkg expand-region)
     (:require expand-region)
     )

   (setup (:pkg undo-fu undo-fu-session)
     (:with-map (prog-mode-map text-mode-map)
       (:bind
        "u" undo-fu-only-undo
        "C-r" undo-fu-only-redo))
     (setq undo-fu-session-incompatible-files
           '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'"))
     (global-undo-fu-session-mode 1))

  ;; (setup (:pkg whitespace-cleanup-mode)
  ;;   (global-whitespace-cleanup-mode 1)
  ;;   (:with-hook before-save-hook
  ;;     (:hook delete-trailing-whitespace))
  ;;   (:hide-mode))

#+end_src
whitespace defaults
#+begin_src emacs-lisp :noweb-ref sanity
  (setup whitespace
    (setq backward-delete-char-untabify-method 'hungry)
    (setq next-line-add-newlines nil)
    (setq sentence-end-double-space nil)
    (setq-default indent-tabs-mode nil)
    (setq-default indicate-empty-lines nil)
    (setq-default tab-always-indent nil)
    (setq-default tab-width 4)
    (:with-hook before-save-hook
      (:hook delete-trailing-whitespace)))

#+end_src
*** Emacs *Help* functions

 Help and which functions

#+begin_src emacs-lisp :noweb-ref pkg-ui

  (setup (:pkg helpful)
    (:when-loaded
      (:global-bind
       "C-h f" helpful-callable
       "C-h v" helpful-variable
       "C-h k" helpful-key)
      (defun avy-action-helpful (pt)
        (save-excursion
          (goto-char pt)
          (helpful-at-point))
        (select-window
         (cdr (ring-ref avy-ring 0)))
        t)
      ;; set H as avy dispatch to Help
      (setf (alist-get ?H avy-dispatch-alist) 'avy-action-helpful)

      (:load-after link-hint
        (:bind
         "o" link-hint-open-link-at-point)
        (setq helpful-switch-buffer-function
              (lambda (x)
                (if (eq major-mode 'helpful-mode)
                    (switch-to-buffer x)
                  (pop-to-buffer x)))))))

  (setup (:pkg which-key)
    (which-key-mode 1)
    (setq which-key-add-column-padding 2)
    (setq which-key-idle-delay 0.5)
    (setq which-key-idle-secondary-delay 0.1)
    (setq which-key-max-display-columns nil)
    (setq which-key-min-display-lines 6)
    (setq which-key-replacement-alist
          '((("left") . ("🡸"))
            (("right") . ("🡺"))
            (("up") . ("🡹"))
            (("down") . ("🡻"))
            (("delete") . ("DEL"))
            (("\\`DEL\\'") . ("BKSP"))
            (("RET") . ("⏎"))
            (("next") . ("PgDn"))
            (("prior") . ("PgUp"))))
    (setq which-key-sort-order 'which-key-key-order-alpha)
    (setq which-key-sort-uppercase-first nil)
    (which-key-setup-minibuffer)
    (:with-hook which-key-init-buffer-hook
      (:hook (fn (setq line-spacing 4))))
    (:hide-mode))

#+end_src

*** Navigation
setup Marginalia for navigation
#+begin_src emacs-lisp
    ;; Enable richer annotations using the Marginalia package
      (setup (:pkg marginalia)
        (:load-after vertico
          (marginalia-mode 1))
        (:with-map minibuffer-local-map
          (:bind "M-A" marginalia-cycle)))

#+end_src
keychords with hydra
#+begin_src emacs-lisp
  (setup (:pkg hydra)
    (require 'hydra))
#+end_src
*** Completion
Emacs completion parlava
#+begin_src emacs-lisp :noweb-ref pkg-completion
  (setup (:pkg corfu)
    (:with-map corfu-map
    (:bind
      "TAB"  corfu-next
      [tab]  corfu-next
      "S-TAB"  corfu-previous
      [backtab]  corfu-previous
      [remap completion-at-point]  corfu-complete
      "RET"  corfu-complete-and-quit))
    ;; Recommended: Enable Corfu globally.
    ;; This is recommended since dabbrev can be used globally (M-/).
    (corfu-global-mode)
    ;; Optionally enable cycling for `corfu-next' and `corfu-previous'.
    (setq corfu-cycle t)
    (defun corfu-move-to-minibuffer ()
      (interactive)
      (let (completion-cycle-threshold completion-cycling)
        (apply #'consult-completion-in-region completion-in-region--data)))
    (define-key corfu-map "\M-m" #'corfu-move-to-minibuffer)
    (setq corfu-preselect-first t)
    (setq corfu-scroll-margin 4)
    (setq corfu-quit-no-match t)
    (setq corfu-quit-at-boundary t)
    (setq corfu-max-width 100)
    (setq corfu-min-width 42)
    (setq corfu-count 9)
    ;; should be configured in the `indent' package, but `indent.el'
    ;; doesn't provide the `indent' feature.
    (setq tab-always-indent 'complete)
    (defun corfu-complete-and-quit ()
      (interactive)
      (corfu-complete)
      (corfu-quit)))

  ;; Dabbrev works with Corfu
  (setup (:pkg dabbrev)
    ;; Swap M-/ and C-M-/
    (:global "M-/"    dabbrev-completion
             "C-M-/"  dabbrev-expand))

  (setup (:pkg ripgrep)
    (:needs "rg")
    (setq ripgrep-arguments "--ignore-case"))

  (setup (:pkg consult)
      (:global "C-x b" consult-buffer
                 "M-y"   consult-yank-from-kill-ring
                 "C-c f" consult-ripgrep)
    (setq consult-async-min-input 2)
    (setq consult-preview-key (kbd "M-."))
    (setq xref-show-definitions-function #'consult-xref)
    (setq xref-show-xrefs-function #'consult-xref)
    ;; Updating the default to include "--ignore-case"
    (setq consult-ripgrep-command "rg --null --line-buffered --color=ansi --max-columns=1000 --ignore-case --no-heading --line-number . -e ARG OPTS")

    ;; From https://github.com/minad/consult/wiki#find-files-using-fd
    ;; Note: this requires lexical binding
    (defun jnf/consult-find-using-fd (&optional dir initial)
      "Find project files.
  A replacement for `projectile-find-file'."
      (interactive "P")
      (let ((consult-find-command "fd --color=never --hidden --exclude .git/ --full-path ARG OPTS"))
        (consult-find dir initial)))

    (defun jnf/consult-line (consult-line-function &rest rest)
      "Advising function around `CONSULT-LINE-FUNCTION'.
  When there's an active region, use that as the first parameter
  for `CONSULT-LINE-FUNCTION'.  Otherwise, use the current word as
  the first parameter.  This function handles the `REST' of the
  parameters."
      (interactive)
      (apply consult-line-function
             (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
             rest))

    (defun jnf/consult-ripgrep (consult-ripgrep-function &optional dir &rest rest)
      "Use region or thing at point to populate initial parameter for `CONSULT-RIPGREP-FUNCTION'.
  When there's an active region, use that as the initial parameter
  for the `CONSULT-RIPGREP-FUNCTION'.  Otherwise, use the thing at
  point.
  `DIR' use the universal argument (e.g. C-u prefix) to first set
  the directory.  `REST' is passed to the `CONSULT-RIPGREP-FUNCTION'."
      (interactive "P")
      (apply consult-ripgrep-function
             dir
             (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
             rest))

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)
    (advice-add #'consult-line :around #'jnf/consult-line '((name . "wrapper")))
    (advice-add #'consult-ripgrep :around #'jnf/consult-ripgrep '((name . "wrapper")))

    (:load-after projectile
      (setq consult-project-root-function #'projectile-project-root))
  ;;   (:load-after vertico
  ;;     (setq completion-in-region-function
  ;;           (lambda (&rest args)
  ;;             (apply (if vertico-mode
  ;;                        #'consult-completion-in-region
  ;;                      #'completion--in-region)
  ;;                    args))))
     )

   (setup (:pkg embark)
    (:load-after which-key
      (defun embark-which-key-indicator ()
        (lambda (&optional keymap targets prefix)
          (if (null keymap)
              (which-key--hide-popup-ignore-command)
            (which-key--show-keymap
             (if (eq (plist-get (car targets) :type) 'embark-become)
                 "Become"
               (format "Agir sur %s '%s'%s"
                       (plist-get (car targets) :type)
                       (embark--truncate-target (plist-get (car targets) :target))
                       (if (cdr targets) "…" "")))
             (if prefix
                 (pcase (lookup-key keymap prefix 'accept-default)
                   ((and (pred keymapp) km) km)
                   (_ (key-binding prefix 'accept-default)))
               keymap)
             nil nil t (lambda (binding)
                         (not (string-suffix-p "-argument" (cdr binding))))))))
      (setq prefix-help-command #'embark-prefix-help-command)
      (setq embark-indicators '(embark-which-key-indicator embark-highlight-indicator embark-isearch-highlight-indicator))
      (defun avy-action-embark (pt)
        (unwind-protect
            (save-excursion
              (goto-char pt)
              (embark-act))
          (select-window
           (cdr (ring-ref avy-ring 0))))
        t)

      (setf (alist-get ?. avy-dispatch-alist) 'avy-action-embark)

      (:advise embark-completing-read-prompter :around (fn &rest args)
        (when-let ((win (get-buffer-window which-key--buffer 'visible)))
          (quit-window 'kill-buffer win)
          (let ((embark-indicators (delq #'embark-which-key-indicator
                                         embark-indicators)))
            (apply fn args))))
      (:global "C-," embark-act)))

  (setup (:pkg embark-consult)
    (:load-after (embark consult)
      (:with-mode embark-collect-mode
        (:hook consult-preview-at-point-mode))))

  (setup (:pkg orderless)
    (setq completion-category-defaults nil)
    (setq completion-category-overrides '((file (styles partial-completion))))
    (setq completion-styles '(orderless)))

  (setup (:pkg (vertico :files (:defaults "extensions/*")))
    (:also-load vertico-repeat)
    (:global "M-r" #'vertico-repeat)
    ;; Different scroll margin
    ;; (setq vertico-scroll-margin 0)

    ;; Show more candidates
    ;; (setq vertico-count 20)

    ;; Grow and shrink the Vertico minibuffer
    ;; (setq vertico-resize t)

    ;; Use `consult-completion-in-region' if Vertico is enabled.
    ;; Otherwise use the default `completion--in-region' function.
    (setq completion-in-region-function
          (lambda (&rest args)
            (apply (if vertico-mode
                       #'consult-completion-in-region
                     #'completion--in-region)
                   args)))
    (advice-add #'completing-read-multiple
                :override #'consult-completing-read-multiple)
    (:with-hook minibuffer-setup-hook
      (:hook vertico-repeat-save))
    ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
    (setq vertico-cycle t))

  ;; A few more useful configurations...
  (setup emacs
    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 3)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete)

    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; recursive minibuffers
    (setq enable-recursive-minibuffers nil))

  (setup (:pkg cape)
    (defun enable-cape ()
      (add-hook 'completion-at-point-functions #'cape-dabbrev 90 t)
      (add-hook 'completion-at-point-functions #'cape-file 90 t))
    (:with-mode (prog-mode cider-mode) #'enable-cape))
#+end_src

** Note Taking
:PROPERTIES:
:header-args: :noweb-ref pkg-org
:END:
The ever changing Org setup part
#+BEGIN_SRC elisp :noweb-ref pkg-org
  (setq org-directory
        (if IS-TERMUX
            "~/storage/shared/org"
          "~/org"))
  (defun /org-path (path)
    (expand-file-name path org-directory))
  (setq org-default-notes-file (/org-path "todo.org"))

  ;; Turn on indentation and auto-fill mode for Org files
  (defun gas/org-mode-setup ()
    (org-indent-mode)       ;; turn on org indent
    (variable-pitch-mode 1) ;; turn on variable-pitch
    (auto-fill-mode 0)      ;; turn off auto-fill
    (visual-line-mode 1)    ;; turn on visual-line-mode
    (show-paren-mode 1)     ;; show parentheses
    )

  (setup (:pkg org)
    (:also-load org-tempo)
    ;; (:hook gas/org-mode-setup)
    (:global "C-c a"  org-agenda)
    (:bind   "C-c c"  org-capture
             "C-c l"  org-store-link)
    (setq ;;org-adapt-indentation nil ; don't indent things
     org-capture-bookmark nil
     org-catch-invisible-edits 'smart            ;; try not to accidently do weird stuff in invisible regions
     org-confirm-babel-evaluate nil
     org-cycle-separator-lines 2
     org-edit-src-content-indentation 2
     org-ellipsis " …"
     org-export-coding-system 'utf-8-unix
     org-export-headline-levels 8
     org-export-in-background t                  ;; run export processes in external emacs process
     org-export-with-section-numbers nil
     org-export-with-smart-quotes t
     org-export-with-sub-superscripts '{}        ;; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
     org-export-with-toc t
     org-fontify-quote-and-verse-blocks t
     org-fontify-whole-heading-line t
     org-hide-block-startup nil
     org-hide-emphasis-markers t                 ;; so dont see text markers aka bold italic
     org-html-coding-system 'utf-8-unix
     org-html-todo-kwd-class-prefix "keyword "
     org-id-link-to-org-use-id 'create-if-interactive
     org-id-locations-file (/org-path ".orgids")
     org-image-actual-width '(300)
     org-list-allow-alphabetical t               ;; have a. A. a\) A\) list bullets
     org-log-done 'time                          ;; having the time a item is done sounds convenient
     org-outline-path-complete-in-steps nil
     org-pretty-entities t                       ;; special symbols, latex
     org-return-follows-link t
     org-src-tab-acts-natively t
     org-src-fontify-natively t
     org-src-preserve-indentation nil
     org-startup-folded 'content
     org-startup-indented t                       ;; removed leading * for nicer view
     org-startup-with-inline-images t
     ;; Use the special C-a, C-e and C-k definitions for Org, which enable some special behaviour in headings.
     org-special-ctrl-a/e t
     org-special-ctrl-k t
     org-use-property-inheritance t              ; it's convenient to have properties inherited
     )

    (setq org-modules
          '(org-crypt
            org-habit
            org-bookmark
            ;;org-eshell
            ;;org-irc
            ))

    (setq org-refile-targets '((nil :maxlevel . 3)
                               (org-agenda-files :maxlevel . 3))
          org-refile-use-outline-path t)

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (clojure . t)
       (shell . t)
       (python . t)
       ;;(ledger . t)
       ))
    (setq org-ts-regexp-both-braket "\\([[<]\\)\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} ?[^]\n>]*?\\)\\([]>]\\)")
    (defface org-deadline-custom-braket '((t (:inherit 'default))) "org-deadline" :group 'org)
    (defface org-scheduled-custom-braket '((t (:inherit 'default))) "org-schedule" :group 'org)
    (defface org-priority-hide '((t ())) "org-priority-hide" :group 'org)
    (defface org-scheduled-custom '((t (:inherit 'default))) "org-schedule" :group 'org)
    (defface org-closed-custom '((t (:inherit 'default))) "org-close" :group 'org)
    (defface org-todo-keyword-done '((t ())) "org-done" :group 'org)
    (defface org-todo-keyword-next '((t ())) "org-next" :group 'org)
    (defface org-todo-keyword-proj '((t ())) "org-proj" :group 'org)
    (defface org-todo-keyword-wait '((t ())) "org-wait" :group 'org)
    (defface org-todo-keyword-todo '((t ())) "org-todo" :group 'org)
    (defface org-todo-keyword-kill '((t ())) "org-kill" :group 'org)
    ;; (with-no-warnings
    ;;   (custom-declare-face '+org-todo-active  '((t (:inherit (bold font-lock-constant-face org-todo)))) "")
    ;;   (custom-declare-face '+org-todo-project '((t (:inherit (bold font-lock-doc-face org-todo)))) "")
    ;;   (custom-declare-face '+org-todo-onhold  '((t (:inherit (bold warning org-todo)))) "")
    ;;   (custom-declare-face '+org-todo-cancel  '((t (:inherit (bold error org-todo)))) ""))
    ;; change CAPITAL Keywords to lowercase
    (defun org-syntax-convert-keyword-case-to-lower ()
      "Convert all #+KEYWORDS to #+keywords."
      (interactive)
      (save-excursion
        (goto-char (point-min))
        (let ((count 0)
              (case-fold-search nil))
          (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
            (unless (s-matches-p "RESULTS" (match-string 0))
              (replace-match (downcase (match-string 0)) t)
              (setq count (1+ count))))
          (message "Remplacement de %d occurrences" count))))

    (push '("conf-unix" . conf-unix) org-src-lang-modes)
    (:load-after hl-fill-column
      (:hook gas/org-mode-setup)))

  ;;   (add-hook 'org-mode-hook 'show-paren-mode)

#+END_SRC

*** Fonts, Bullets & Links
Use bullet characters instead of asterisks, plus set the header font sizes to something more palatable.  A fair amount of inspiration has been taken from [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][this blog post]].

#+begin_src emacs-lisp
  (setup (:require org-indent)
    (:load-after org
      (org-indent-mode 1)
      (:hide-mode)))

  (setup (:pkg org-appear)
    (:option org-appear-autoemphasis t
             org-appear-autoentities t
             org-appear-autokeywords t
             org-appear-autolinks nil
             org-appear-autosubmarkers t
             org-appear-delay 0)
    (:hook-into org-mode))

  (unless IS-TERMUX
    (setup (:pkg org-superstar)
      (:load-after org
        (:option org-superstar-remove-leading-stars t
                 org-superstar-special-todo-items t
                 org-superstar-headline-bullets-list '("◉" "○" "●" "○" "●" "○" "●"))
        (:hook-into org-mode)))

    ;; Replace list hyphen with dot
    ;; (font-lock-add-keywords 'org-mode
    ;;                         '(("^ *\\([-]\\) "
    ;;                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    (setup org-faces
      (:load-after org
        (dolist (face-cons '((org-document-title . 1.75)
                             (org-level-1 . 1.5)
                             (org-level-2 . 1.25)
                             (org-level-3 . 1.12)
                             (org-level-4 . 1.05)
                             (org-level-5 . 1.0)
                             (org-level-6 . 1.0)
                             (org-level-7 . 1.0)
                             (org-level-8 . 1.0)))
          (cl-destructuring-bind (face . height) face-cons
            (set-face-attribute face
                                nil
                                :weight 'bold
                                :font "Iosevka Aile"
                                :height height)))))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
    (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

    ;; Get rid of the background on column views
    (set-face-attribute 'org-column nil :background nil)
    (set-face-attribute 'org-column-title nil :background nil))


  ;; TODO: Others to consider
  ;; '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
  ;; '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
  ;; '(org-property-value ((t (:inherit fixed-pitch))) t)
  ;; '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
  ;; '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
  ;; '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
  ;; '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))
  (setup (:pkg toc-org)
    (:load-after org
      (:hook-into org-mode)))
#+end_src

*** Templates
These templates enable you to type things like =<el= and then hit =Tab= to expand
the template.  More documentation can be found at the Org Mode [[https://orgmode.org/manual/Easy-templates.html][Easy Templates]]
documentation page.

#+begin_src emacs-lisp

  ;; This is needed as of Org 9.2
  (setup org-tempo
    (:load-after org
      (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
      (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
      (add-to-list 'org-structure-template-alist '("li" . "src lisp"))
      (add-to-list 'org-structure-template-alist '("cli" . "src common-lisp"))
      (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
      (add-to-list 'org-structure-template-alist '("cl" . "src clojure"))
      (add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
      (add-to-list 'org-structure-template-alist '("py" . "src python"))
      (add-to-list 'org-structure-template-alist '("go" . "src go"))
      (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
      (add-to-list 'org-structure-template-alist '("json" . "src json"))))

#+end_src
Trying to fix weird org syntax problems. This just lets Org ignore < and > characters as if they
were regular words. This is necessary because in Clojure I want to make functions with -> in the
name and Org was always insisting on pairing <>. This caused any other paren matching to stop
working. It sucked.

**** YASSnippet
Setup Ysnippet
#+begin_src emacs-lisp
(setup (:pkg yasnippet)
       (:option yas-snippet-dirs (list
                                  (expand-file-name "snippets" user-emacs-directory)
                                  (sync/ "emacs/snippets" t)))
       (yas-global-mode +1))
#+end_src

*** Org Roam
#+begin_src emacs-lisp

  (with-eval-after-load 'org-roam
    (defun my/org-roam-project-finalise-hook ()
      "Adds the captured project file to `org-agenda-files' if the
  capture was not aborted."
      ;; Remove the hook since it was added temporarily
      (remove-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalise-hook)

      ;; Add project file to the agenda list if the capture was confirmed
      (unless org-note-abort
        (with-current-buffer (org-capture-get :buffer)
          (add-to-list 'org-agenda-files (buffer-file-name)))))


    (defun my/org-roam-find-project ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Select a project file to open, creating it if necessary
    (org-roam-node-find
     nil
     nil
     (my/org-roam-filter-by-tag "Projet")
     :templates
     '(("p" "projet" plain "* Objectifs\n\n%?\n\n* Tâches\n\n** TODO Ajouter des tâches initiales\n\n* Dates\n\n"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: Projet")
        :unnarrowed t))))

  (defun my/org-roam-capture-inbox ()
    (interactive)
    (org-roam-capture- :node (org-roam-node-create)
                       :templates '(("i" "inbox" plain "* %?"
                                     :if-new (file+head "todo.org" "#+title: Inbox\n")))))

  (defun my/org-roam-copy-todo-to-today ()
    (interactive)
    (let ((org-refile-keep t) ;; Set this to nil to delete the original!
          (org-roam-dailies-capture-templates
           '(("t" "tâches" entry "%?"
              :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n" ("TÂches")))))
          (org-after-refile-insert-hook #'save-buffer)
          today-file
          pos)
      (save-window-excursion
        (org-roam-dailies--capture (current-time) t)
        (setq today-file (buffer-file-name))
        (setq pos (point)))

      ;; Only refile if the target file is different than the current file
      (unless (equal (file-truename today-file)
                     (file-truename (buffer-file-name)))
        (org-refile nil nil (list "Tâches" today-file nil pos)))))

    (defvar dw/org-roam-project-template
      '("p" "projet" plain "** TODO %?"
        :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                               "#+title: ${title}\n#+category: ${title}\n#+filetags: Projet\n"
                               ("Tâches"))))

  ;; (add-to-list 'org-after-todo-state-change-hook
  ;;              (lambda ()
  ;;                (when (equal org-state "DONE")
  ;;                  (my/org-roam-copy-todo-to-today))))
  )

    (defun my/org-roam-filter-by-tag (tag-name)
      (lambda (node)
        (member tag-name (org-roam-node-tags node))))

    (defun my/org-roam-list-notes-by-tag (tag-name)
      (mapcar #'org-roam-node-file
              (seq-filter
               (my/org-roam-filter-by-tag tag-name)
               (org-roam-node-list))))

    (defun org-roam-node-insert-immediate (arg &rest args)
      (interactive "P")
      (let ((args (push arg args))
            (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                      '(:immediate-finish t)))))
        (apply #'org-roam-node-insert args)))

    (defun dw/org-roam-goto-month ()
      (interactive)
      (org-roam-capture- :goto (when (org-roam-node-from-title-or-alias (format-time-string "%Y-%B")) '(4))
                         :node (org-roam-node-create)
                         :templates '(("m" "month" plain "\n* Objectifs\n\n%?* Résumé\n\n"
                                       :if-new (file+head "%<%Y-%B>.org"
                                                          "#+title: %<%Y-%B>\n#+filetags: Projet\n")
                                       :unnarrowed t))))

    (defun dw/org-roam-goto-year ()
      (interactive)
      (org-roam-capture- :goto (when (org-roam-node-from-title-or-alias (format-time-string "%Y")) '(4))
                         :node (org-roam-node-create)
                         :templates '(("y" "year" plain "\n* Objectifs\n\n%?* Résumé\n\n"
                                       :if-new (file+head "%<%Y>.org"
                                                          "#+title: %<%Y>\n#+filetags: Projet\n")
                                       :unnarrowed t))))

    (defun dw/org-roam-capture-task ()
      (interactive)
      ;; Add the project file to the agenda after capture is finished
      (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

      ;; Capture the new task, creating the project file if necessary
      (org-roam-capture- :node (org-roam-node-read
                                nil
                                (my/org-roam-filter-by-tag "Projet"))
                         :templates (list dw/org-roam-project-template)))

    (defun my/org-roam-refresh-agenda-list ()
      (interactive)
      (setq org-agenda-files (my/org-roam-list-notes-by-tag "Projet")))

    (defhydra dw/org-roam-jump-menu (:hint nil)
      "
    ^Dailies^        ^Capture^       ^Jump^
    ^^^^^^^^-------------------------------------------------
    _t_: today       _T_: today       _m_: current month
    _r_: tomorrow    _R_: tomorrow    _e_: current year
    _y_: yesterday   _Y_: yesterday   ^ ^
    _d_: date        ^ ^              ^ ^
    "
      ("t" org-roam-dailies-goto-today)
      ("r" org-roam-dailies-goto-tomorrow)
      ("y" org-roam-dailies-goto-yesterday)
      ("d" org-roam-dailies-goto-date)
      ("T" org-roam-dailies-capture-today)
      ("R" org-roam-dailies-capture-tomorrow)
      ("Y" org-roam-dailies-capture-yesterday)
      ("m" dw/org-roam-goto-month)
      ("e" dw/org-roam-goto-year)
      ("c" nil "cancel"))

    (setup (:pkg org-roam)
      (setq org-roam-v2-ack t)
      (setq dw/daily-note-filename "%<%Y-%m-%d>.org"
            dw/daily-note-header "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")

      (:when-loaded
        (org-roam-db-autosync-mode)
        (my/org-roam-refresh-agenda-list))

      (:option
       org-roam-directory "~/org/roam/"
       org-roam-dailies-directory "journal/"
       org-roam-completion-everywhere t
       org-roam-capture-templates
       '(("d" "default" plain "%?"
          :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                             "#+title: ${title}\n")
          :unnarrowed t))
       org-roam-dailies-capture-templates
       `(("d" "default" entry
          "* %?"
          :if-new (file+head ,dw/daily-note-filename
                             ,dw/daily-note-header))
         ("t" "tâche" entry
          "* TODO %?\n  %U\n  %a\n  %i"
          :if-new (file+head+olp ,dw/daily-note-filename
                                 ,dw/daily-note-header
                                 ("Tasks"))
          :empty-lines 1)
         ("l" "log entry" entry
          "* %<%I:%M %p> - %?"
          :if-new (file+head+olp ,dw/daily-note-filename
                                 ,dw/daily-note-header
                                 ("Log")))
         ("j" "journal" entry
          "* %<%I:%M %p> - Journal  :journal:\n\n%?\n\n"
          :if-new (file+head+olp ,dw/daily-note-filename
                                 ,dw/daily-note-header
                                 ("Log")))
         ("m" "meeting" entry
          "* %<%I:%M %p> - %^{Meeting Title}  :meetings:\n\n%?\n\n"
          :if-new (file+head+olp ,dw/daily-note-filename
                                 ,dw/daily-note-header
                                 ("Log")))))
      (:global "C-c n l" org-roam-buffer-toggle
               "C-c n f" org-roam-node-find
               "C-c n d" dw/org-roam-jump-menu/body
               "C-c n c" org-roam-dailies-capture-today
               "C-c n t" dw/org-roam-capture-task
               "C-c n g" org-roam-graph)
      (:bind "C-c n i" org-roam-node-insert
             "C-c n I" org-roam-insert-immediate))


    ;;(setq  org-capture-templates
    ;;       '(("x" "Note" entry
    ;;          (file+olp+datetree "journal.org")
    ;;          "**** [ ] %U %?" :prepend t :kill-buffer t)
    ;;         ("t" "Tâches" entry
    ;;          (file+headline "todo.org" "Boîte de réception")
    ;;          "* [ ] %?\n%i" :prepend t :kill-buffer t)))
    ;;  (setq org-capture-templates
    ;;        `(("i" "inbox" entry (file ,(concat gas/org-agenda-directory "inbox.org"))
    ;;          "* TODO %?")
    ;;         ("e" "email" entry (file+headline ,(concat gas/org-agenda-directory "emails.org") "Emails")
    ;;              "* TODO [#A] Reply: %a :@maison:@bureau:"
    ;;               :immediate-finish t)
    ;;          ("c" "org-protocol-capture" entry (file ,(concat gas/org-agenda-directory "inbox.org"))
    ;;               "* TODO [[%:link][%:description]]\n\n %i"
    ;;               :immediate-finish t)
    ;;          ("w" "Weekly Review" entry (file+olp+datetree ,(concat gas/org-agenda-directory "reviews.org"))
    ;;           (file ,(concat gas/org-agenda-directory "templates/weekly_review.org")))
    ;;           ))
#+end_src
*** Org Agenda
org-capture provides a generic and extensible interface to capturing things into org-mode in
different formats
#+begin_src emacs-lisp
      (setup org-agenda
       (:load-after org
        (setq org-agenda-files
              '( "~/org/todo.org"  "~/org/roam/"
                 ))
            (setq org-todo-keywords
              '((sequence
                 "TODO(t)"  ; A task that needs doing & is ready to do
                 "PROJ(p)"  ; A project, which usually contains other tasks
                 "SUIV(s)"  ; A task that is in progress
                 "ATTE(w)"  ; Something external is holding up this task
                 "SUSP(h)"  ; This task is paused/on hold because of me
                 "|"
                 "FINI(d)"  ; Task successfully completed
                 "KILL(k)") ; Task was cancelled, aborted or is no longer applicable
                (sequence
                 "[ ](T)"   ; A task that needs doing
                 "[-](S)"   ; Task is in progress
                 "[?](W)"   ; Task is being held up or paused
                 "|"
                 "[X](D)")  ; Task was completed
                (sequence
                 "|"
                 "OKAY(o)"
                 "YES(y)"
                 "NO(n)"))
              org-todo-keyword-faces
              '(("[ ]"   . org-todo-keyword-todo)
                ("SUIV" .  org-todo-keyword-next)
                ("[-]"  .  org-todo-keyword-next)
                ("[?]"  .  org-todo-keyword-wait)
                ("ATTE" .  org-todo-keyword-wait)
                ("SUSP" .  org-todo-keyword-wait)
                ("PROJ" .  org-todo-keyword-proj)
                ("KILL" .  org-todo-keyword-kill)
                ("FINI" .  org-todo-keyword-done)
                ("[X]"  .  org-todo-keyword-done)
                ))
        (setq org-fancy-priorities-list '("⚡" "⬆" "⬇" "☕"))
        (setq-default
         org-tag-alist
         (quote (("@errand"     . ?e)
                 ("@bureau"    . ?o)
                 ("@maison"    . ?h)
                 ("important"  . ?i)
                 ("urgent"     . ?u)

                 (:newline)
                 ("ATTENDRE"  . ?w)
                 ("SUSPENDUÉ" . ?h)
                 ("ANNULÉ"    . ?c)
                 ("RÉUNION"   . ?m)
                 ("TÉLÉPHONE" . ?p)
                 ("french"    . ?f)
                 ("spanish"   . ?s))))

        (setq org-priority-faces
         `((?A . ,(face-foreground 'error))
           (?B . ,(face-foreground 'warning))
           (?C . ,(face-foreground 'success))))
        (setq org-agenda-custom-commands
              (quote
               (("N" "Notes" tags "NOTE"
                 ((org-agenda-overriding-header "Notes")
                  (org-tags-match-list-sublevels t)))
                ("h" "Habitudes" tags-todo "STYLE=\"habit\""
                 ((org-agenda-overriding-header "Habitudes")
                  (org-agenda-sorting-strategy
                   '(todo-state-down priority-down category-keep))))
                ("e" "Eisenhower Matrix"
                 ((agenda
                   ""
                   ((org-agenda-overriding-header "Calendrier Eisenhower:")
                    (org-agenda-show-log t)
                    (org-agenda-log-mode-items '(clock state))
                    (org-agenda-category-filter-preset '("-Habitudes"))
                    (org-agenda-span 5)
                    (org-agenda-start-on-weekday t)
                    ;;            (org-agenda-ndays 5)
                    ;;            (org-agenda-start-day "-2d")
                    (org-deadline-warning-days 30)))
                  (tags-todo  "+important+urgent\!FINI"
                              ((org-agenda-overriding-header "Tâches importantes et urgentes")
                               (org-tags-match-list-sublevels nil)))
                  (tags-todo  "+important-urgent"
                              ((org-agenda-overriding-header "Tâches importantes mais non urgentes")
                               (org-tags-match-list-sublevels nil)))
                  (tags-todo "-important+urgent"
                             ((org-agenda-overriding-header "Tâches urgentes mais sans importance")
                              (org-tags-match-list-sublevels nil)))
                  (tags-todo "-important-urgent/!TODO"
                             ((org-agenda-overriding-header "Tâches non importantes ni urgentes")
                              (org-agenda-category-filter-preset '("-Habitudes"))
                              (org-tags-match-list-sublevels nil)))
                  (tags-todo "VALUE"
                             ((org-agenda-overriding-header "Valeurs")
                              (org-tags-match-list-sublevels nil)))
                  ))
                (" " "Agenda"
                 ((agenda ""
                          ((org-agenda-overriding-header "Calendrier d'aujourd'hui:")
                           (org-agenda-show-log t)
                           (org-agenda-log-mode-items '(clock state))
                           ;;   (org-agenda-span 'day)
                           ;;   (org-agenda-ndays 3)
                           (org-agenda-start-on-weekday nil)
                           (org-agenda-start-day "-d")
                           (org-agenda-todo-ignore-deadlines nil)))
                  (tags-todo "+important"
                             ((org-agenda-overriding-header "Tâches Importantes à Venir")
                              (org-tags-match-list-sublevels nil)))
                  (tags-todo "-important"
                             ((org-agenda-overriding-header "Tâches de Travail")
                              (org-agenda-category-filter-preset '("-Habitudes"))
                              (org-agenda-sorting-strategy
                               '(todo-state-down priority-down))))
                  (tags "REFILE"
                        ((org-agenda-overriding-header "Tâches à la Représenter")
                         (org-tags-match-list-sublevels nil)))))
                )))))
#+end_src
*** Distraction Free
setup olivetti to have a distraction free editing mode
#+begin_src emacs-lisp
  ;; Distraction-free screen
    (setup (:pkg olivetti)
      (setq olivetti-body-width .67)
      (defun distraction-free ()
        "Distraction-free writing environment"
        (interactive)
        (if (equal olivetti-mode nil)
            (progn
              (window-configuration-to-register 1)
              (delete-other-windows)
              (text-scale-increase 2)
              (olivetti-mode t))
          (progn
            (jump-to-register 1)
            (olivetti-mode 0)
            (text-scale-decrease 2))))
      (:bind "<f9>"  #'distraction-free))
#+end_src
*** angle-bracket-hack
#+begin_src elisp
(defun my-angle-bracket-fix ()
  (modify-syntax-entry ?< "w")
  (modify-syntax-entry ?> "w"))

(add-hook 'org-mode-hook 'my-angle-bracket-fix)
#+end_src

** Coding Settings
I mostly use Clojure and Clojurescript, so they're setup inheriting from LISP setup
*** LISP Paren Setup
Setup smartparens and rainbow delimiters
#+begin_src emacs-lisp :noweb-ref code-paren
  ;; matching braces
  (setup (:require paren)
    (set-face-attribute 'show-paren-match-expression nil :background "#363e4a")
    (show-paren-mode 1))

  (setup (:pkg paren-face)
  (:hook-into emacs-lisp-mode
              ielm-mode sly-repl-mode
              lisp-mode
              lisp-interaction-mode
              clojure-mode))

  (setup hideshow
    (defun +hs-cycle (&optional level)
      (interactive "p")
      (let (message-log-max
            (inhibit-message t))
        (if (= level 1)
            (pcase last-command
              ('+hs-cycle
               (hs-hide-level 1)
               (setq this-command 'hs-cycle-children))
              ('hs-cycle-children
               ;; TODO: Fix this case. `hs-show-block' needs to be
               ;; called twice to open all folds of the parent
               ;; block.
               (save-excursion (hs-show-block))
               (hs-show-block)
               (setq this-command 'hs-cycle-subtree))
              ('hs-cycle-subtree
               (hs-hide-block))
              (_
               (if (not (hs-already-hidden-p))
                   (hs-hide-block)
                 (hs-hide-level 1)
                 (setq this-command 'hs-cycle-children))))
          (hs-hide-level level)
          (setq this-command 'hs-hide-level))))

    (defun +hs-global-cycle ()
      (interactive)
      (pcase last-command
        ('+hs-global-cycle
         (save-excursion (hs-show-all))
         (setq this-command 'hs-global-show))
        (_ (hs-hide-all))))
    (:with-mode hs-minor-mode
      (:hook-into prog-mode)
      (:bind "C-<tab>"   #'+hs-cycle
             "C-S-<tab>" #'+hs-global-cycle)))
  ;; Setup a "Common" ALL Lisp modes MAP

  (setup all-lisp-modes
    (define-minor-mode all-lisp-modes-mode
      "Mode for enabling all modes that are common for ALL lisps.

  \\<all-lisp-modes-mode-map>"
      :lighter " Almm"
      :keymap (make-sparse-keymap))
    (defun all-lisp-modes-indent-or-fill-sexp ()
      "Indent s-expression or fill string/comment."
      (interactive)
      (let ((ppss (syntax-ppss)))
        (if (or (nth 3 ppss)
                (nth 4 ppss))
            (fill-paragraph)
          (save-excursion
            (mark-sexp)
            (indent-region (point) (mark))))))
    (provide 'all-lisp-modes)
    (:with-map all-lisp-modes-mode-map
      (:bind "M-q" all-lisp-modes-indent-or-fill-sexp)))

  (setup (:pkg rainbow-delimiters)
    ;;(setq rainbow-delimiters-max-face-count 2)
    (:hook-into emacs-lisp-mode-hook
                eval-expression-minibuffer-setup-hook
                ielm-mode-hook
                lisp-interaction-mode-hook
                lisp-mode-hook
                sly-mrepl-mode-hook
                clojure-mode
                prog-mode)
    (:hide-mode))

  (setup (:pkg smartparens)
    (:require smartparens-config)
    (:with-map smartparens-mode-map
      (:bind "C-M-q" sp-indent-defun))
    ;;(:with-map all-lisp-modes-mode-map
    ;;  (:bind ";" sp-comment))
    ;; use paredit bindings
    (sp-use-paredit-bindings)
    ;; needs to be set manually, because :bind section runs before :config
    (define-key smartparens-mode-map (kbd "M-r") 'sp-rewrap-sexp)
    (setq sp-cancel-autoskip-on-backward-movement nil)
    (setq sp-echo-match-when-visible nil)
    ;; Overlays are too distracting and not terribly helpful. show-parens does
    ;; this for us already (and is faster), so...
    (setq sp-highlight-pair-overlay nil)
    (setq sp-highlight-wrap-overlay nil)
    (setq sp-highlight-wrap-tag-overlay nil)
    ;; No pair has any business being longer than 4 characters; if they must, set
    ;; it buffer-locally. It's less work for smartparens.
    (setq sp-max-pair-length 2)
    ;; The default is 100, because smartparen's scans are relatively expensive
    ;; (especially with large pair lists for some modes), we reduce it, as a
    ;; better compromise between performance and accuracy.
    (setq sp-max-prefix-length 32)
    (setq sp-message-width nil)
    (setq sp-navigate-consider-sgml-tags nil)
    (setq sp-navigate-skip-match nil)
    (setq sp-show-pair-from-inside t)
    (setq sp-show-pair-delay 0)
    (sp-pair "'" nil :actions :rem)
    (sp-pair "`" nil :actions :rem)
    (sp-pair "(" nil :unless '(:rem sp-point-before-word-p))
    (defun minibuffer-enable-sp ()
      "Enable `smartparens-strict-mode' in the minibuffer, during `eval-expression'."
      (setq-local comment-start ";")
      (sp-local-pair 'minibuffer-pairs "'" nil :actions nil)
      (sp-local-pair 'minibuffer-pairs "`" nil :actions nil)
      (sp-update-local-pairs 'minibuffer-pairs)
      (smartparens-strict-mode 1))


    ;; Define a hydra
    ;; (defhydra hydra-smartparens (:idle 1 :hint nil)
    ;;   "
    ;;     Sexps (quit with _q_)

    ;;     ^Nav^            ^Barf/Slurp^          ^Depth^
    ;;     ^---^------------^----------^----------^-----^-----------------------
    ;;     _f_: forward     _s_:  slurp forward   _R_:      splice
    ;;     _b_: backward    _S_:  barf forward    _r_:      raise
    ;;     _a_: begin       _d_:  slurp backward  _<up>_:   raise backward
    ;;     _e_: end         _D_:  barf backward   _<down>_: raise forward
    ;;     _m_: mark

    ;;     ^Kill^           ^Misc^                       ^Wrap^
    ;;     ^----^-----------^----^-----------------------^----^------------------
    ;;     _w_: copy        _j_: join                    _(_: wrap with ( )
    ;;     _k_: kill        _s_: split                   _{_: wrap with { }
    ;;     ^^               _t_: transpose               _'_: wrap with ' '
    ;;     ^^               _c_: convolute               _\"_: wrap with \" \"
    ;;     ^^               _i_: indent defun"
    ;;   ("q" nil)
    ;;   ;; Wrapping
    ;;   ("(" (lambda (a) (interactive "P") (sp-wrap-with-pair "(")))
    ;;   ("{" (lambda (a) (interactive "P") (sp-wrap-with-pair "{")))
    ;;   ("'" (lambda (a) (interactive "P") (sp-wrap-with-pair "'")))
    ;;   ("\"" (lambda (a) (interactive "P") (sp-wrap-with-pair "\"")))
    ;;   ;; Navigation
    ;;   ("f" sp-beginning-of-next-sexp)
    ;;   ("b" sp-beginning-of-previous-sexp)
    ;;   ("a" sp-beginning-of-sexp)
    ;;   ("e" sp-end-of-sexp)
    ;;   ("m" sp-mark-sexp)
    ;;   ;; Kill/copy
    ;;   ("w" sp-copy-sexp :exit t)
    ;;   ("k" sp-kill-sexp :exit t)
    ;;   ;; Misc
    ;;   ("t" sp-transpose-sexp)
    ;;   ("j" sp-join-sexp)
    ;;   ("c" sp-convolute-sexp)
    ;;   ("i" sp-indent-defun)
    ;;   ;; Depth changing
    ;;   ("R" sp-splice-sexp)
    ;;   ("r" sp-splice-sexp-killing-around)
    ;;   ("<up>" sp-splice-sexp-killing-backward)
    ;;   ("<down>" sp-splice-sexp-killing-forward)
    ;;   ;; Barfing/slurping
    ;;   ("s" sp-forward-slurp-sexp)
    ;;   ("S" sp-forward-barf-sexp)
    ;;   ("D" sp-backward-barf-sexp)
    ;;   ("d" sp-backward-slurp-sexp))
    (:with-hook (emacs-lisp-mode-hook
                 expression-minibuffer-setup-hook
                 ielm-mode-hook
                 lisp-interaction-mode-hook
                 lisp-mode-hook
                 all-lisp-modes-mode-map
                 sly-mrepl-mode-hook
                 clojure-mode-hook
                 clojurescript-mode-hook
                 cider-repl-mode-hook)
      (:hook smartparens-strict-mode))
    ;; (:hide-mode)
    )
#+end_src
*** Emacs Lisp
ielm setup
#+begin_src emacs-lisp :noweb-ref code-elisp
  (setup (:require pulse)
    (defgroup +pulse nil
      "Extra customisations for `pulse'."
      :group 'pulse
      :prefix "+pulse-")

    (defcustom +pulse-location-commands '(scroll-up-command
                                          scroll-down-command
                                          recenter-top-bottom
                                          other-window
                                          switch-to-buffer
                                          redraw-frame)
      "Commands to pulse the current line after.
  Good for finding location."
      :type '(repeat function))

    (defcustom +pulse-location-function '+pulse-line-current-window
      "What function to call after `+pulse-location-commands'."
      :type 'function)

    ;; XXX: this doesn't work yet.  I only want to pulse the line in the
    ;; active window, so when I have the same buffer viewed in multiple
    ;; windows I can still see where my cursor is.  To see the issue, C-x
    ;; 2 then C-x o a few times.
    (defun +pulse-line-current-window (&rest _)
      "Pulse the current line, but only if this window is active."
      (pulse-momentary-highlight-one-line
       (window-point (selected-window))))

    (defun +pulse--advice-remove (symbol where function &optional props)
      "Remove advice SYMBOL from FUNCTION.
  This uses the same args as `advice-add' for easy toggling.
  WHERE and PROPS are discarded."
      (ignore where props)
      (advice-remove symbol function))

    (define-minor-mode +pulse-location-mode
      "After moving locations, pulse where we are."
      :global t
      :keymap nil
      (dolist (command +pulse-location-commands)
        (funcall
         (if +pulse-location-mode 'advice-add '+pulse--advice-remove)
         command :after +pulse-location-function)))
    (:option pulse-flag nil
             pulse-delay 0.5
             pulse-iterations 1)
    (dolist (command '(+ace-window-or-switch-buffer
                       pop-mark pop-globl-mark))
      (add-to-list '+pulse-location-commands command))
    (+ensure-after-init #'+pulse-location-mode))

  (setup elisp-mode
    (defun +elisp-eval-region-or-buffer ()
      (interactive)
      (if (region-active-p)
          (eval-region (region-beginning) (region-end))
        (+eval-region@pulse (lambda (_ _) (eval-buffer)) (point-min) (point-max))))

    (defun +eval-region@pulse (advised beg end &rest args)
      "ADVICE to pulse an eval'd region."
      (apply advised beg end args)
      (pulse-momentary-highlight-region beg end))

    (:option eval-expression-print-length nil
             eval-expression-print-level nil)
    (:with-map (emacs-lisp-mode-map lisp-interaction-mode-map)
      (:bind "C-c C-c" #'eval-defun
             "C-c C-k" #'+elisp-eval-region-or-buffer
             "C-c C-z" #'ielm )
    (advice-add #'eval-region :around #'+eval-region@pulse)))

  (setup (:pkg elisp-slime-nav)
    (:load-after ielm
      (:hook-into emacs-lisp-mode ielm-mode)
      (:hide-mode)))

  (setup (:pkg ielm)
    (:load-after comint
      (:with-map ielm-map
        (:bind
         [up] comint-previous-input
         [down] comint-next-input))))

  (setup (:pkg macrostep)
    (:with-map macrostep-keymap
      (:bind
       [tab] macrostep-next-macro
       [backtab] macrostep-prev-macro
       "c" macrostep-collapse
       "e" macrostep-expand
       "q" macrostep-collapse-all))
    (:hide-mode))
#+end_src
*** Common LISP
SLY setup
#+begin_src emacs-lisp :noweb-ref code-common-lisp
  (defun mf/sly-ask ()
    (interactive)
    (let ((current-prefix-arg '-))
      (sly nil nil t)))

  (setup (:pkg sly)
    (:when-loaded
      (sly-setup '(sly-fancy)))
    (setq sly-command-switch-to-existing-lisp 'always)
    (setq sly-complete-symbol-function 'sly-flex-completions)
    (setq sly-enable-evaluate-in-emacs t)
    (setq sly-kill-without-query-p t)
    (setq sly-mrepl-history-file-name (/etc-file "sly-repl-history"))
    (setq sly-mrepl-pop-sylvester nil)
    (setq sly-mrepl-prevent-duplicate-history 'move)
    (setq sly-net-coding-system 'utf-8-unix)
    (:hide-mode))

#+end_src
*** Clojure
Editing Clojure / Clojurescript code is best done using a REPL, which is provided with the cider package.
Cider has a lot of options to customise, and here are the ones I think are most critical.
Source comes from: [[https://stackoverflow.com/a/31080940]]
#+BEGIN_SRC elisp :noweb-ref code-clojure
  (setup (:pkg clojure-mode)
    (:local-hook clojurec-mode
                 clojurescript-mode)
    (:hook clojure-mode-setup)
    (defvar org-babel-default-header-args:clojure '((:results . "silent")))'
    (defun org-babel-execute:clojure (body params)
      "Evaluate a block of Clojure code with Babel."
      (lisp-eval-string body))
    (defun clojure-set-compile-command ()
      (let ((project-dir (clojure-project-dir)))
        (cond ((and (file-exists-p (expand-file-name "project.clj" project-dir))
                    (executable-find "lein"))
               (setq-local compile-command "lein "))
              ((and (file-exists-p (expand-file-name "deps.edn" project-dir))
                    (executable-find "clojure"))
               (setq-local compile-command "clojure ")))))
    (defun clojure-mode-setup ()
      "Setup Clojure buffer."
      (all-lisp-modes-mode)
      (clojure-set-compile-command)
      (flycheck-mode)))

  (setup (:pkg cider)
    (:load-after clojure-mode
      (:options nrepl-log-messages nil
                nrepl-use-ssh-fallback-for-remote-hosts t
                nrepl-hide-special-buffers t
                cider-allow-jack-in-without-project t
                cider-enrich-classpath t
                cider-font-lock-dynamically '(macro var deprecated)
                cider-repl-clear-help-banner t
                cider-repl-display-help-banner nil
                cider-repl-tab-command #'indent-for-tab-command
                ;;cider-repl-use-pretty-printing t
                ;;cider-repl-pop-to-buffer-on-connect t
                cider-save-file-on-load nil
                cider-test-show-report-on-success t
                cider-use-fringe-indicators nil)
      (:bind "C-c C-S-o" cider-repl-clear-buffer )
      ;; (:face (cider-result-overlay-face ((t (:box (:line-width -1 :color "grey50")))))
      ;;        (cider-error-highlight-face ((t (:inherit flymake-error))))
      ;;        (cider-warning-highlight-face ((t (:inherit flymake-warning)))))
      (
       :with-mode cider-repl-mode clojure-mode)
      (:hook eldoc-mode)))

  ;; Allow cider-repl to be cleared with shortcut
  ;;(add-hook 'cider-repl-mode-hook
                  ;;;          '(lambda () (define-key cider-repl-mode-map (kbd "C-c M-b")
                                          ;                        'cider-repl-clear-buffer)))

  ;; (add-hook 'cider-mode-hook (lambda () (show-paren-mode 1)))
  ;; (add-hook 'cider-mode-hook #'eldoc-mode)

  ;;(add-hook 'cider-repl-mode-hook #'enable-paredit-mode)
  ;;(add-hook 'cider-mode-hook #'imenu-add-menubar-index)


  (setup (:pkg async))
  (setup (:pkg ob-async))
  (setup (:pkg ob-clojurescript))
  ;;(setup (:pkg ob-babel-eval-in-repl))

  (setup (:pkg flycheck-clj-kondo)
    :only-if (executable-find "clj-kondo"))

  ;;(setup (:pkg eval-in-repl))

#+END_SRC


**** clj templates
Insertion templates can be used to speed up project setups. This is code of my own creation, so use at your own risk. The template files are in ~.emacs.d/templates/lib.org~.

***** slurp
#+BEGIN_SRC elisp
(defun slurp (file)
  (with-temp-buffer
    (insert-file-contents file)
    (buffer-substring-no-properties
     (point-min)
     (point-max))))

#+END_SRC

***** template-reader
#+begin_src elisp
(defun template-reader (file replace)
  (let ((lines (split-string (slurp file) "\n")))
    (->> lines
         (mapcar (lambda (x) (replace-regexp-in-string "_str_" replace x)))
         (mapcar (lambda (x) (concat x "\n")))
         (-concat)
         (apply 'concat))))

#+end_src

***** clj-org-templates
I use org mode and literate programming ideas to build my clj/cljs projects. So, it is helpful to have skeletons that take .org template files that tangle into a nice clojure project setup. Currently I only have one template, but the idea is to be able to have a few which you just bind to different keys as needed. The idea is demonstrated with 'Project' and 'Library'.

#+BEGIN_SRC elisp :tangle no
(define-skeleton cljc-lib-skeleton
  "Inserts a .org template with user's project name input.
   Use in empty file and save to desired project directory.
   Tangle will create project structure on save."
  ""
  (template-reader "~/.config/emacs/templates/lib.org" (skeleton-read "Library name: ")))

(define-skeleton cljc-project-skeleton
  "Inserts a .org template with user's project name input.
   Use in empty file and save to desired project directory.
   Tangle will create project structure on save."
  ""
  (template-reader "~/.emacs.d/templates/lib.org" (skeleton-read "Project name: ")))

;;(global-set-key (kbd "C-S-L") 'cljc-lib-skeleton)
;;(global-set-key (kbd "C-S-P") 'cljc-project-skeleton)

#+END_SRC
*** Fennel
:properties:
:header-args: :noweb-ref code-fennel
:end:
Setup of Fennel and Lua

#+begin_src emacs-lisp
(setup (:pkg fennel-mode)
(:bind "C-c C-k"  eval-each-sexp)
(put 'global 'fennel-indent-function 1)
  (put 'local 'fennel-indent-function 1)
  (put 'var 'fennel-indent-function 1)
  (defvar org-babel-default-header-args:fennel '((:results . "silent")))
  (defun org-babel-execute:fennel (body _params)
    "Evaluate a block of Fennel code with Babel."
    (save-window-excursion
      (unless (bufferp fennel-repl--buffer)
        (fennel-repl nil))
      (let ((inferior-lisp-buffer fennel-repl--buffer))
        (lisp-eval-string body))))
  (defun eval-each-sexp ()
    "Evaluate each s-expression in the buffer consequentially.

If prefix ARG specified, call `fennel-reload' function.  If
double prefix ARG specified call `fennel-reload' function and ask
for the module name."
    (interactive)
    (save-excursion
      (save-restriction
        (goto-char (point-min))
        (while (save-excursion
                 (search-forward-regexp "[^[:space:]]." nil t))
          (forward-sexp)
          (when (and (not (nth 4 (syntax-ppss)))
                     (looking-back "." 1))
            (lisp-eval-last-sexp)))))
    (when fennel-mode-switch-to-repl-after-reload
      (switch-to-lisp t)))
)
#+end_src


* Keybindings
:PROPERTIES:
:header-args: :noweb-ref keybindings
:END:
Change the Mac modifiers to my liking. I also disable passing Control characters to the system, to avoid that C-M-space launches the Character viewer instead of running mark-sexp.
#+begin_src emacs-lisp
(cond (IS-MAC
       (setq mac-command-modifier      'meta
              mac-option-modifier         'alt
              mac-right-option-modifier   'alt
              mac-pass-control-to-system nil)))
#+end_src
When at the beginning of the line, make Ctrl-K remove the whole line, instead of just emptying it.
#+begin_src emacs-lisp
(setq kill-whole-line t)
#+end_src
**** Emulating Vi's % key
One of the few things I missed in Emacs from vi was the % key, which jumps to the parenthesis, bracket or brace which matches the one below the cursor. This function implements this functionality, bound to the same key. Inspired by NavigatingParentheses, but modified to use smartparens instead of the default commands, and to work on brackets and braces.
#+begin_src emacs-lisp
        (setup
          (:pkg smartparens)
          (defun zz/goto-match-paren (arg)
            "Go to the matching paren/bracket, otherwise (or if ARG is not
            nil) insert %.  vi style of % jumping to matching brace."
            (interactive "p")
            (if (not (memq last-command '(set-mark
                                          cua-set-mark
                                          zz/goto-match-paren
                                          down-list
                                          up-list
                                          end-of-defun
                                          beginning-of-defun
                                          backward-sexp
                                          forward-sexp
                                          backward-up-list
                                          forward-paragraph
                                          backward-paragraph
                                          end-of-buffer
                                          beginning-of-buffer
                                          backward-word
                                          forward-word
                                          mwheel-scroll
                                          backward-word
                                          forward-word
                                          mouse-start-secondary
                                          mouse-yank-secondary
                                          mouse-secondary-save-then-kill
                                          move-end-of-line
                                          move-beginning-of-line
                                          backward-char
                                          forward-char
                                          scroll-up
                                          scroll-down
                                          scroll-left
                                          scroll-right
                                          mouse-set-point
                                          next-buffer
                                          previous-buffer
                                          previous-line
                                          next-line
                                          back-to-indentation
                                          )))
                (self-insert-command (or arg 1))
              (cond ((looking-at "\\s\(") (sp-forward-sexp) (backward-char 1))
                    ((looking-at "\\s\)") (forward-char 1) (sp-backward-sexp))
                    (t (self-insert-command (or arg 1)))))
          )
          (:global "%" 'zz/goto-match-paren))
#+end_src

* Maybe to applied - not tangled at present
#+begin_src elisp :tangle no

    ;; enable line-numbers
     (column-number-mode)

     ;; Enable line numbers for some modes
     (dolist (mode '(text-mode-hook
                     prog-mode-hook
                     conf-mode-hook))
       (add-hook mode (lambda () (display-line-numbers-mode 1))))

     ;; Override some modes which derive from the above
     (dolist (mode '(org-mode-hook))
       (add-hook mode (lambda () (display-line-numbers-mode 0))))



#+end_src


* Tangling config noweb
** Header & disclaimer
:PROPERTIES:
:header-args: :noweb-ref disclaimer
:END:

#+begin_src emacs-lisp
  ;; Copyright (C) 2021 Gas

  ;; Author: Gas <gas@tuatara.red>
  ;; Created: Sometime during the Covid-19 lockdown
  ;; Keywords: configuration, emacs
  ;; URL: https://github.com/frap/emacs.d

  ;; This file is not part of GNU Emacs.

  ;;; Commentary:
  ;; This file is automatically tangled from config.org.
  ;; Hand edits will be overwritten!
  ;; Je t'ai prévenu putain!

#+end_src
** My Utility fns constants and macros
:PROPERTIES:
:header-args: :tangle lisp/enfer-utility-fn-macros.el :noweb yes
:END:

File for my constants, macros and functions

*** Contents enfer-util

#+begin_src emacs-lisp
;;; enfer-utility-fn-macros.el -*- lexical-binding: t -*-

<<disclaimer>>

;;; Code:

;;; ============================================================================
;;; Variables
;;; ============================================================================

<<variables>>

;;; ============================================================================
;;; Macros
;;; ============================================================================

<<macros>>

;;; ============================================================================
;;; Functions
;;; ============================================================================

<<functions>>

(provide 'enfer-utility-fn-macros)
;;; enfer-utility-fn-macros.el ends here
#+end_src

** Emacs setup package manager and configurator setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkgmgr.el :noweb yes
:END:

"Setup" of setup.el the emacs package manager and package setup to replace use-package

*** Contents enfer-setup

#+begin_src emacs-lisp
  ;;; enfer-pkgmgr.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  ;; Install setup.el. We use this to concisely perform repetitive tasks, such as
  ;; installing and loading packages.
  <<setup-pkgmgr>>

  ;;; ============================================================================
  ;;; Custom setup.el local macros
  ;;; ============================================================================

   <<setup-macros>>

  (provide 'enfer-pkgmgr)
   ;;; enfer-pkgmgr.el ends here
#+end_src
** Emacs Sanity setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-emacs-sanity.el :noweb yes
:END:

"Setup" of Emacs to some sort of sanity

*** Contents enfer-emacs-sanity

#+begin_src emacs-lisp
  ;;; enfer-emacs-sanity.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  (setup files
    (setq auto-mode-case-fold nil)
    (setq auto-save-default nil)
    (setq auto-save-list-file-prefix nil)
    (setq backup-inhibited t)
    (setq create-lockfiles nil)
    (setq delete-by-moving-to-trash nil)
    (setq find-file-suppress-same-file-warnings t)
    (setq find-file-visit-truename t)
    (setq load-prefer-newer t)
    (setq make-backup-files nil)
    (setq require-final-newline t)
    (setq vc-follow-symlinks t))

  (setup mouse
    (setq focus-follows-mouse t)
    (setq make-pointer-invisible t)
    (setq mouse-1-click-follows-link t)
    (setq mouse-autoselect-window t)
    (setq mouse-wheel-follow-mouse t)
    (setq mouse-wheel-progressive-speed nil)
    (setq mouse-wheel-scroll-amount '(3 ((shift) . hscroll)))
    (setq mouse-wheel-scroll-amount-horizontal 2)
    (setq mouse-yank-at-point t))

  (setup scrolling
    (setq auto-hscroll-mode 'current-line)
    (setq auto-window-vscroll nil)
    (setq fast-but-imprecise-scrolling t)
    (setq hscroll-margin 16)
    (setq hscroll-step 1)
    (setq scroll-conservatively 101)
    (setq scroll-margin 8)
    (setq scroll-preserve-screen-position t)
    (setq scroll-step 1))

  (setup selection
    (setq kill-do-not-save-duplicates t)
    (setq select-enable-clipboard t)
    (setq select-enable-primary t)
    (setq x-select-enable-clipboard-manager nil))

  <<user-config>>

  (setup misc
    (setq ad-redefinition-action 'accept)
    (setq bidi-inhibit-bpa t)
    (setq command-line-ns-option-alist nil)
    (setq confirm-kill-processes nil)
    (setq custom-file (/etc-file "custom.el"))
    (setq default-input-method "TeX")
    (setq ffap-machine-p-known 'reject)
    (setq inhibit-compacting-font-caches t)
    (setq inhibit-default-init t)
    (setq jit-lock-defer-time nil)
    (setq jka-compr-verbose nil)
    (setq native-comp-async-report-warnings-errors nil)
    (setq read-file-name-completion-ignore-case t)
    (setq read-process-output-max (* 64 1024))
    (setq redisplay-skip-fontification-on-input t)
    (setq ring-bell-function 'ignore)
    (setq-default fill-column 100)
    (setq-default lexical-binding t))

  <<sanity>>

  (provide 'enfer-emacs-sanity)
;;; enfer-emacs-sanity.el ends here
#+end_src

** Emacs Startup enhancements and GC
:PROPERTIES:
:header-args: :tangle lisp/enfer-emacs-startup.el :noweb yes
:END:

Setup auto-compile, no littering and GMCH

*** Contents enfer-emacs-startup

#+begin_src emacs-lisp
  ;;; enfer-emacs-startup.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<emacs-setup>>

  (provide 'enfer-emacs-startup)
   ;;; enfer-emacs-startup.el ends here
#+end_src
** Emacs Builtins
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-builtin.el :noweb yes
:END:

Setup Emacs builtins

*** Contents enfer-pkg-builtin

#+begin_src emacs-lisp
;;; enfer-pkg-builtin.el -*- lexical-binding: t -*-
    <<disclaimer>>
;;; Code:
(setup abbrev
  (:option abbrev-file-name (sync/ "abbrev.el")
           save-abbrevs 'silent)
  (:hook-into text-mode
              circe-chat-mode))

    (setup auto-fill
      (:with-feature simple
        (:with-mode (text-mode org-mode)
          (:hook turn-on-auto-fill))
        (:with-mode prog-mode
          (:hook (fn (setq-local comment-auto-fill-only-comments t)
                     (auto-fill-mode 1))))
        (:hide-mode auto-fill-function)))

    (setup (:require autorevert)
      (setq auto-revert-check-vc-info t)
      (setq auto-revert-remote-files t)
      (setq global-auto-revert-non-file-buffers t)
      (setq auto-revert-verbose nil)
      (global-auto-revert-mode 1)
      (:hide-mode auto-revert))

    (setup comint
      (setq ansi-color-for-comint-mode t)
      (setq comint-buffer-maximum-size 4096)
      (setq comint-prompt-read-only t))

    (setup compile
      (add-hook 'compilation-filter #'ansi-color-compilation-filter)
      (:option compilation-always-kill t
               compilation-ask-about-save nil
               compilation-scroll-output 'first-error)
      (defmacro compile-add-error-syntax (name regexp file line &optional col level)
        "Register new compilation error syntax.

    Add NAME symbol to `compilation-error-regexp-alist', and then add
    REGEXP FILE LINE and optional COL LEVEL info to
    `compilation-error-regexp-alist-alist'."
        (declare (indent 1))
        `(progn (add-to-list 'compilation-error-regexp-alist ',name)
                (add-to-list 'compilation-error-regexp-alist-alist
                             '(,name ,regexp ,file ,line ,col ,level))))
      (compile-add-error-syntax kaocha-tap
                                "^not ok.*(\\([^:]*\\):\\([0-9]*\\))$"
                                (1 "src/%s" "test/%s") 2)
      (compile-add-error-syntax kaocha-fail
                                ".*FAIL in.*(\\([^:]*\\):\\([0-9]*\\))$"
                                (1 "src/%s" "test/%s") 2)
      (compile-add-error-syntax clojure-reflection-warning
                                "^Reflection warning,[[:space:]]*\\([^:]+\\):\\([0-9]+\\):\\([0-9]+\\).*$"
                                (1 "src/%s" "test/%s") 2 3)
      (compile-add-error-syntax clojure-syntax-error
                                "^Syntax error macroexpanding at (\\([^:]+\\):\\([0-9]+\\):\\([0-9]+\\)).$"
                                (1 "src/%s" "test/%s") 2 3)
      (compile-add-error-syntax lua-stacktrace
                                "\\(?:^[[:space:]]+\\([^
    :]+\\):\\([[:digit:]]+\\):[[:space:]]+in.+$\\)"
                                1 2)
      (compile-add-error-syntax fennel-compile-error
                                "\\(?:^Compile error in[[:space:]]+\\([^:]+\\):\\([[:digit:]]+\\)$\\)"
                                1 2)
      )

    (setup dired
      (:also-load dired-x)
      (:pkg dired-collapse
            dired-git-info
            ;;  dired-single
            dired-subtree
            ;;   diredfl
            dired+)
      (:option dired-recursive-copies 'always
               dired-recursive-deletes 'always
               dired-create-destination-dirs 'always
               dired-do-revert-buffer t
               dired-hide-details-hide-symlink-targets nil
               dired-isearch-filenames 'dwim
               delete-by-moving-to-trash t
               dired-auto-revert-buffer t
               dired-listing-switches "-Al"
               ls-lisp-dirs-first t
               dired-ls-F-marks-symlinks t
               dired-clean-confirm-killing-deleted-buffers nil
               dired-no-confirm '(byte-compile
                                  load chgrp chmod chown
                                  copy move hardlink symlink
                                  shell touch)
               dired-dwim-target t)
      (:local-set truncate-lines t)
      (:bind
       "<backspace>" #'dired-up-directory
       "TAB" #'dired-subtree-cycle
       "i" #'dired-subtree-toggle
       ")" #'dired-git-info-mode
       "q" #'quit-window)
      (:hook #'dired-collapse-mode
             #'dired-hide-details-mode
             #'hl-line-mode)
      ;;(:+key "C-x C-j" #'dired-jump)
      ;;  (setq dired-recursive-copies 'top)
      ;;  (setq dired-recursive-deletes 'top)
      ;;    (diredfl-global-mode 1)
      )

    (setup (:require eldoc)
      (setq eldoc-echo-area-use-multiline-p nil)
      (setq eldoc-idle-delay 0.1)
      (:with-mode prog-mode
        (:hook turn-on-eldoc-mode))
      (:hook-into clojure-mode
                  cider-repl-mode
                  elisp-mode
                  lisp-interactive-mode)
      (:hide-mode))

    (setup (:require elec-pair)
      (electric-pair-mode 1))

    (setup executable
      (setq executable-prefix-env t)
      (:with-hook after-save-hook
        (:hook executable-make-buffer-file-executable-if-script-p)))

    (setup (:require goto-addr)
      (:with-mode prog-mode
        (:hook goto-address-prog-mode))
      (:with-mode text-mode
        (:hook goto-address-mode)))

    (setup (:require help-mode)
      (setq help-window-select t))

    (setup (:require recentf)
      (setq recentf-auto-cleanup 'mode)
      (setq recentf-exclude `(,#'enfer/cache-dir-p
                              "^/tmp/"
                              "COMMIT_EDITMSG$"
                              ".gz$"))
      (setq recentf-filename-handlers '(abbreviate-file-name))
      (setq recentf-max-menu-items 100)
      (setq recentf-max-saved-items nil)
      (recentf-mode 1)
      (run-at-time nil 120 (fn (quiet! (recentf-save-list))))
      (:with-hook kill-emacs-hook
        (:hook recentf-cleanup recentf-save-list)))

    (setup (:require savehist)
      (setq history-delete-duplicates t)
      (setq history-length t)
      (setq savehist-additional-variables
            '(extended-command-history
              global-mark-ring
              kill-ring
              mark-ring
              regexp-search-ring
              search-ring))
      (setq savehist-autosave-interval 60)
      (setq savehist-file (/etc-file "history"))
      (setq savehist-save-minibuffer-history t)
      (savehist-mode 1))

    (setup (:require saveplace)
      (setq save-place-file (/etc-file "places"))
      (setq save-place-forget-unreadable-files nil)
      (save-place-mode 1))

    (setup (:require server)
      (unless (server-running-p)
        (server-start)))

    (setup (:require subword)
      (global-subword-mode 1)
      (:hide-mode))

    (setup (:require url)
      (setq url-cookie-file (/etc-file "url-cookies")))

    (setup (:require visual-line-mode)
      (:hide-mode))

    (provide 'enfer-pkg-builtin)
      ;;; enfer-pkg-builtin.el ends here
#+end_src
** Utility package
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-util.el :noweb yes
:END:

Setup utility packages

*** Contents enfer-pkg-util

#+begin_src emacs-lisp
  ;;; enfer-pkg-util.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-utils>>

  (provide 'enfer-pkg-util)
   ;;; enfer-pkg-util.el ends here
#+end_src
** Emacs UI Appearance
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-ui.el :noweb yes
:END:

Setup

*** Contents enfer-pkg-ui

#+begin_src emacs-lisp
  ;;; enfer-pkg-ui.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-ui>>

  (provide 'enfer-pkg-ui)
   ;;; enfer-pkg-ui.el ends here
#+end_src
** Emacs Editor Setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-editor.el :noweb yes
:END:

Setup Editor functions

*** Contents enfer-pkg-editor

#+begin_src emacs-lisp
  ;;; enfer-pkg-editor.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-editor>>

  (provide 'enfer-pkg-editor)
   ;;; enfer-pkg-editor.el ends here
#+end_src
** Emacs Completion Frameworks
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-completion.el :noweb yes
:END:

Setup embark, vertico and consult

*** Contents enfer-pkg-completion

#+begin_src emacs-lisp
  ;;; enfer-pkg-completion.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-completion>>

  (provide 'enfer-pkg-completion)
   ;;; enfer-pkg-completion.el ends here
#+end_src
** Emacs Windows
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-window.el :noweb yes
:END:

windose

*** Contents enfer-pkg-window

#+begin_src emacs-lisp
  ;;; enfer-pkg-window.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-window>>

  (provide 'enfer-pkg-window)
   ;;; enfer-pkg-window.el ends here
#+end_src
** Projects
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-project.el :noweb yes
:END:

Setup projects

*** Contents enfer-pkg-project

#+begin_src emacs-lisp
  ;;; enfer-pkg-project.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-project>>

  (provide 'enfer-pkg-project)
   ;;; enfer-pkg-project.el ends here
#+end_src
** Org mode workflow
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-org.el :noweb yes
:END:

Setup org-mode

*** Contents enfer-pkg-org

#+begin_src emacs-lisp
  ;;; enfer-pkg-org.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-org>>

  (provide 'enfer-pkg-org)
   ;;; enfer-pkg-org.el ends here
#+end_src
** Coding
Setup Coding languages

*** LISP setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-lisp.el :noweb yes
:END:
Smartparens setup here
#+begin_src emacs-lisp
  ;;; enfer-code-lisp.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-paren>>

  (provide 'enfer-code-lisp)
   ;;; enfer-code-lisp.el ends here
#+end_src
*** Emacs-lisp setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-elisp.el :noweb yes
:END:
#+begin_src emacs-lisp
  ;;; enfer-code-elisp.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-elisp>>

  (provide 'enfer-code-elisp)
   ;;; enfer-code-elisp.el ends here
#+end_src
*** Common LISP setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-common-lisp.el :noweb yes
:END:
#+begin_src emacs-lisp
  ;;; enfer-code-common-lisp.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-common-lisp>>

  (provide 'enfer-code-common-lisp)
   ;;; enfer-code-common-lisp.el ends here
#+end_src
*** Clojure setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-clojure.el :noweb yes
:END:
#+begin_src emacs-lisp
  ;;; enfer-code-clojure.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-clojure>>

  (provide 'enfer-code-clojure)
  ;;; enfer-code-clojure.el ends here
#+end_src
*** Fennel/LUA setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-fennel.el :noweb yes
:END:
#+begin_src emacs-lisp
  ;;; enfer-code-fennel.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-fennel>>

  (provide 'enfer-code-fennel)
  ;;; enfer-code-fennel.el ends here
#+end_src
** Keybindings
:PROPERTIES:
:header-args: :tangle lisp/enfer-key-bindings.el :noweb yes
:END:
#+begin_src emacs-lisp
  ;;; enfer-key-bindings.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<keybindings>>

  (provide 'enfer-key-bindings)
   ;;; enfer-key-bindings.el ends here
#+end_src
** config.el
:PROPERTIES:
:header-args: :tangle config.el :noweb yes
:END:

While =config.el= is written above, I use Noweb references to tangle
them all together in the following block, which enables me to organise
my config here /logically/, while keeping the generated file organised
/programmatically/.

*** Enable lexical binding

#+begin_src emacs-lisp
  ;;; config.el --- personal configuration -*- lexical-binding: t -*-
#+end_src


*** The rest

#+begin_src emacs-lisp
  <<disclaimer>>
  ;;; Code:

  ;;; REQUIRES
  <<requires>>

  ;;; CONSTANTS
  <<constants>>

  ;;; VARIABLES
  <<variables>>

  ;;; FUNCTIONS
  <<functions>>

  ;;; PACKAGE SETUP
  <<pkg-setup>>

  ;;; EMACS SANITY SETTINGS
  <<sanity>>

  ;;; UI
  <<UI>>

  ;;; EDITOR WORKFLOW
  <<editor>>

  ;;; CODING
  <<coding>>

  ;;; SYSTEM-DEPENDENT SETTINGS
  ;; at home
  (eval-and-compile
    (when (memq system-type '(gnu gnu/linux darwin))
      <<linux-specific>>
      ))

  ;; at work
  (eval-and-compile
    (when (memq system-type '(ms-dos windows-nt))
      <<windows-specific>>
      ))

  ;;; MODES
  <<modes>>

  ;;; HOOKS
  <<hooks>>

  ;;; BINDINGS
  <<bindings>>
  ;;; config.el ends here
#+end_src
*** Ease of editing
:PROPERTIES:
:header-args: :tangle no
:END:

#+begin_src emacs-lisp :noweb-ref functions
  (defun enfer/find-config ()
    "Find `config.org'."
    (interactive)
    (find-file (locate-user-emacs-file "config.org")))
#+end_src

Bind it to =C-z i= because =C-z C-c= is taken for capture.

#+begin_src emacs-lisp :noweb-ref bindings
(define-key acdw/leader (kbd "i") #'acdw/find-config)
#+end_src

*** Ease of reloading
:PROPERTIES:
:header-args: :tangle no
:END:

#+begin_src emacs-lisp :noweb-ref functions
  (defun acdw/reload ()
    "Tangle and reload Emacs configuration."
    (interactive)
    (let ((config (locate-user-emacs-file "config.org")))
      ;; tangle
      (with-current-buffer (find-file-noselect config)
        (message "Tangling config.org...")
        (let ((prog-mode-hook nil)
              (inhibit-redisplay t)
              (inhibit-message t))
          (add-to-list 'load-path (locate-user-emacs-file
                                   "straight/build/org/"))
          (require 'org)
          (org-babel-tangle)))
      (message "Tangling config.org... Done.")
      ;; load init files
      (load (locate-user-emacs-file "early-init.el"))
      (load (locate-user-emacs-file "init.el"))
      (load (locate-user-emacs-file "config.el"))))
#+end_src

#+begin_src emacs-lisp :noweb-ref bindings
  (define-key acdw/leader (kbd "C-M-r") #'acdw/reload)
#+end_src

** init.el
:PROPERTIES:
:header-args: :tangle init.el :noweb yes
:END:

The classic Emacs initiation file.

*** Header

#+begin_src emacs-lisp
  ;;; init.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:
#+end_src

*** Load enfer custom files
#+begin_src emacs-lisp
;;; Set up extra load paths and functionality
(push (locate-user-emacs-file "lisp") load-path)

;;; Load them all up
(require 'enfer-utility-fn-macros)
(require 'enfer-pkgmgr)
(require 'enfer-emacs-sanity)
(require 'enfer-emacs-startup)
(require 'enfer-pkg-builtin)
(require 'enfer-pkg-util)
(require 'enfer-pkg-ui)
(require 'enfer-pkg-editor)
(require 'enfer-pkg-completion)
(require 'enfer-pkg-window)
(require 'enfer-pkg-project)
(require 'enfer-pkg-org)
(require 'enfer-code-lisp)
(require 'enfer-code-elisp)
(require 'enfer-code-lisp)
(require 'enfer-code-clojure)
(require 'enfer-key-bindings)
#+end_src
*** Load the config -disabled

I keep most of my config in =config.el=, which is tangled directly from
this file.  This init just loads that file, either from lisp
or directly from Org if it's newer.  /Note/ the longish comment before
the =unless= form -- it was pretty tough for me to wrap my head around
the needed boolean expression to tangle config.org.  Booleans, yall!

#+begin_src emacs-lisp :tangle no
  (let* (;; Speed up init
        ;; (gc-cons-threshold most-positive-fixnum)
         ;; (gc-cons-percentage 0.6)
         ;;(file-name-handler-alist nil)
         ;; Config file names
         (config (expand-file-name "config"
                                   user-emacs-directory))
         (config.el (concat config ".el"))
         (config.org (concat config ".org"))
         (straight-org-dir (locate-user-emacs-file "straight/build/org")))
    ;; Okay, let's figure this out.
    ;; `and' evaluates each form, and returns nil on the first that
    ;; returns nil.  `unless' only executes its body if the test
    ;; returns nil.  So.
    ;; 1. Test if config.org is newer than config.el.  If it is (t), we
    ;;    *want* to evaluate the body, so we need to negate that test.
    ;; 2. Try to load the config.  If it errors (nil), it'll bubble that
    ;;    to the `and' and the body will be evaluated.
    (unless (and (not (file-newer-than-file-p config.org config.el))
                 (load config :noerror))
      ;; A plain require here just loads the older `org'
      ;; in Emacs' install dir.  We need to add the newer
      ;; one to the `load-path', hopefully that's all.
      (when (file-exists-p straight-org-dir)
        (add-to-list 'load-path straight-org-dir))
      ;; Load config.org
      (require 'org)
      (org-babel-load-file config.org)))

  ;;; init.el ends here
#+end_src

** early-init.el
:PROPERTIES:
:header-args: :tangle early-init.el :noweb yes
:END:

Beginning with 27.1, Emacs also loads an =early-init.el= file, before
the package manager or the UI code.

#+begin_src emacs-lisp
;;; early-init.el -*- lexical-binding: t; no-byte-compile: t; -*-
<<disclaimer>>
;;; Code:

;;; ============================================================================
;;; Some constants for condtional compliation
;;; ============================================================================
<<constants>>

;;; ============================================================================
;;; Emacs startup optimisations
;;; ============================================================================
<<garbage-filehandler>>

;;; ============================================================================
;;; Frame parameters for faster startup
;;; ============================================================================
<<early-init-frame>>

;;; ============================================================================
;;; Specify some directory paths
;;; ============================================================================
<<early-directories>>

;;; ============================================================================
;;; Set up the package manager
;;; ============================================================================
<<early-straight>>

;;; early-init.el ends here
#+end_src

** License
:PROPERTIES:
:header-args: :tangle LICENSE
:END:

Copyright © 2021 Gas <gas@tuatara.red>

This work is free.  You can redistribute it and/or modify it under the
terms of the Do What the Fuck You Want To Public License, Version 2,
as published by Sam Hocevar.  See the =LICENSE= file, tangled from the
following source block, for details.

#+begin_src text
  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE

  Version 2, December 2004

  Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>

  Everyone is permitted to copy and distribute verbatim or modified copies of
  this license document, and changing it is allowed as long as the name is changed.

  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE

  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. You just DO WHAT THE FUCK YOU WANT TO.
#+end_src
