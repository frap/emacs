:PROPERTIES:
:ID:                     8c17836b-8be8-4254-b03b-0f3b5aa2303c
:END:
#+title: Literate Roam Clojure Emacs Config
#+author: gas
#+startup: overview
#+property: header-args :cache yes :results output :mkdirp yes :padline :async
#+auto_tangle: yes

* About me
:PROPERTIES:
:ID:                     969aec14-acc9-46c8-9534-8c0857305593
:END:

Some scripts to setup whether I am on work computer or not
#+begin_src emacs-lisp :noweb-ref user-config
  (if (getenv "USER")
      (defconst IS-WORK (string-match "810989" (getenv "USER")))
      (defconst IS-WORK nil))

  (if IS-WORK
      (setq
       user-full-name "Gas 810989"
       user-mail-address "gas_gasson@bnz.co.nz")
    (setq
     user-full-name "Andr√©s Gasson"
     user-mail-address "gas@tuatara.red"
     github-account-name "frap"))

#+end_src

** Where am I?
:PROPERTIES:
:ID:                     0e4cd289-1e57-40ab-bdb8-518669112965
:END:

#+begin_src emacs-lisp :noweb-ref user-config
  (setq calendar-location-name "Wellington, NZ"
        calendar-latitude -41.28
        calendar-longitude 174.78)

#+end_src

** Auth-sources
:PROPERTIES:
:ID:                     edbde090-6fd1-4cd3-9c03-4ad6a0af2919
:END:

Here feels like as good a place as any to setup =auth-sources=.

#+begin_src emacs-lisp :noweb-ref user-config
  (setq-default auth-sources '("~/.local/state/authinfo.gpg")
                auth-source-cache-expiry nil) ; default is 7200 (2h)

#+end_src
* Startup Performance
:PROPERTIES:
:ID:                     bb63575d-8ceb-4c7d-8753-3c3b0ae33630
:END:

** Garbage Collection & File handlers
:PROPERTIES:
:header-args: :noweb-ref garbage-filehandler
:ID:                     56c4a633-3570-4c8d-a72d-b7dab745aac1
:END:
Make startup faster by reducing the frequency of garbage collection and then use a hook to measure Emacs startup time.


#+begin_src emacs-lisp
      ;; Garbage collection slows down startup time, so we maximise the threshold for
      ;; it to run, and we will later reset it.
      (let ((normal-gc-cons-threshold (* 20 1024 1024))
          (init-gc-cons-threshold (* 128 1024 1024)))
      (setq gc-cons-threshold init-gc-cons-threshold)
      (add-hook 'emacs-startup-hook
                (lambda () (setq gc-cons-threshold
                                 normal-gc-cons-threshold))))
      ;;(setq gc-cons-threshold most-positive-fixnum)

      ;; file-name-handler-alist is consulted on various I/O functions such as
      ;; REQUIRE, slowing down startup time, so we set it to NIL, and establish a hook
      ;; to restore when Emacs is finished starting.
      (unless (or (daemonp) noninteractive)
        (let ((file-name-handler-alist/old file-name-handler-alist))
          (setq file-name-handler-alist nil)
          (add-hook 'emacs-startup-hook
                    (lambda ()
                      (let ((value (delete-dups
                                    (append file-name-handler-alist
                                            file-name-handler-alist/old))))
                        (setq file-name-handler-alist value))))))

      (unless (daemonp)
        (advice-add #'tty-run-terminal-initialization :override #'ignore)
        (add-hook 'window-setup-hook
                  (lambda ()
                    (advice-remove #'tty-run-terminal-initialization #'ignore)
                    (tty-run-terminal-initialization (selected-frame) nil t))))

#+end_src
** Initial frame setup
:PROPERTIES:
:header-args: :noweb-ref early-init-frame
:ID:                     0ae373ff-ee6b-484d-9d03-99ce56f59dc8
:END:

I tangle this section to =early-init.el=, since that's evaluated
before GUI set-up.  Which, in turn, means Emacs will skip the "flash
of unstyled content" thing. Turned off for Termux.

*** Tool bar
:PROPERTIES:
:ID:                     07c28d7c-c8e5-4999-8282-9b25f3ca859f
:END:

#+begin_src emacs-lisp
  (unless ENV-IS-TERMUX?
    (add-to-list 'default-frame-alist
                '(tool-bar-lines . 0))

   (tool-bar-mode -1)

#+end_src

*** Menu bar
:PROPERTIES:
:ID:                     76c92e6b-c4ff-457d-8853-37d8a095f9e4
:END:

#+begin_src emacs-lisp
   (add-to-list 'default-frame-alist
                '(menu-bar-lines . 0))

  ;; (menu-bar-mode -1)

#+end_src

*** Scroll bars
:PROPERTIES:
:ID:                     4c17d471-2aac-4fe0-a242-46d389ed05c1
:END:

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist
               '(vertical-scroll-bars . nil)
                 '(horizontal-scroll-bars . nil))

    (scroll-bar-mode -1)
    (horizontal-scroll-bar-mode -1)

#+end_src

*** Resizing
:PROPERTIES:
:ID:                     d054c73f-121a-4155-964e-c4c3d7f1d2ce
:END:

I don't want the frame to resize when I change fonts and stuff, and I
want it to resize by pixels -- we /are/ using a GUI, after all.

#+begin_src emacs-lisp
  (setq-default frame-inhibit-implied-resize t
                frame-resize-pixelwise t)
  (setq truncate-partial-width-windows nil)

#+end_src

*** Miscellaneous
:PROPERTIES:
:ID:                     70398db1-dd55-46da-8ac6-9389debcb75e
:END:
setting some default settings on early-init
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Iosevka Slab 12"))
  (blink-cursor-mode 0)
  (column-number-mode 1)
  (display-time-mode 0)
  (fringe-mode '(4 . 0))
  (tooltip-mode 0)
  (window-divider-mode 1)
  ) ;; end of unless IS-TERMUX

#+end_src
** Path & Directories
:PROPERTIES:
:header-args: :noweb-ref path-config
:ID:                     81265071-dc7f-4b25-bfb4-8442780963e4
:END:
Need to setup some constants and try to keep state in a "clean" directory structure
#+begin_src emacs-lisp
  (defconst path-home/ (file-name-as-directory (getenv "HOME"))
    "Path to user home directory.

In a nutshell, it's just a value of $HOME.")

  (defconst xdg-config/
    (file-name-as-directory
     (or (getenv "XDG_CONFIG_HOME")
         (concat path-home/ ".config")))
    "Home root directory for personal configurations.")

  (defconst emacs-cache/
    (concat
     (file-name-as-directory
      (or (getenv "XDG_CACHE_HOME")
          (concat path-home/ ".cache")))
     "emacs/")
    "The root directory for local Emacs files.
    Use this as permanent storage for files that are safe to share
    across systems.")

  (defconst emacs-config/
    (file-name-as-directory
     (expand-file-name "emacs/" xdg-config/))
    "The path to this Emacs directory.")

  (defconst emacs-private/
    (concat path-home/ "Sync/emacs/")
    "The root directory for private configurations.")

  (defconst path-autoloads-file
    (expand-file-name "lisp/init-autoloads.el" emacs-config/ )
    "The path to personal autoloads file.")

  (defconst emacs-etc/ (concat emacs-cache/ "etc/")
    "Directory for non-volatile storage.
  Use this for files that don't change much, like servers binaries,
  external dependencies or long-term shared data.")

  (defconst emacs-cache2/ (concat emacs-cache/ "cache/")
    "Directory for volatile storage.
  Use this for files that change often, like cache files.")

  (defconst emacs-packages/
    (expand-file-name (format "packages/%s.%s/"
                              emacs-major-version
                              emacs-minor-version)
                      emacs-cache/ )
    "Where packages are stored.")

  ;; For the rest of the Emacs configuration, set this directory to something
  ;; inside the standard cache directory, so we do not pollute our emacs.d
  ;; directory with files that we would then have to ignore with Git.
  (setq user-emacs-directory emacs-cache/)

  ;; For the list of native compilation ELN cache directories, delete all but the
  ;; last element, which is always assumed to be the system path, and then cons a
  ;; new path in our cache directory to the front. This effectively removes the
  ;; entry for the original ~/.emacs.d/eln-cache/ and any others that are
  ;; unwanted.
  (if (fboundp 'native-comp-available-p)
      (setq native-comp-eln-load-path
            (cons (expand-file-name "eln-cache/" emacs-cache2/ )
                  (last native-comp-eln-load-path))))

#+end_src

** Emacs Package Management
:PROPERTIES:
:header-args: :noweb-ref straight-setup
:ID:                     f265e03f-9f75-41ca-924b-dee7d391cb4c
:END:
Use Straight for package Management. Also use setup.el for easy config of packages.
#+begin_src emacs-lisp
  ;; Pre-configure the package manager settings before it is loaded.
  (setq package-enable-at-startup nil
      package-quickstart nil
      straight-host-usernames '((github . "frap")
				(gitlab .  "agasson"))
      straight-check-for-modifications '(check-on-save
					 find-when-checking))

  (defvar elpa-bootstrap-p nil)

  

  (setq package-user/
	(expand-file-name
	 "elpa/"
	 emacs-packages/))

  
  ;; bootstrap straight.el

  (setq-default
   straight-repository-branch "develop"
   straight-check-for-modifications nil
   straight-use-package-by-default t
   straight-base-dir emacs-packages/
   straight-profiles (list
		      (cons nil
			    (expand-file-name
			     "versions/default.el"
			     emacs-config/ ))))

  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el"
			   straight-base-dir))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   (concat "https://raw.githubusercontent.com/"
		   "raxod502/straight.el/"
		   "develop/install.el")
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (defvar elpa-straight-retry-count 3
    "Amount of retries for `straight' operations.")

  (defun elpa-straight-with-retry (orig-fn &rest args)
    "Wrapper around ORIG-FN supporting retries.
		    ORIG-FN is called with ARGS and retried
		    `elpa-straight-retry-count' times."
    (let ((n elpa-straight-retry-count)
	  (res nil))
      (while (> n 0)
	(condition-case err
	    (progn
	      (setq res (apply orig-fn args)
		    n 0)
	      res)
	  (error
	   (setq n (- n 1))
	   (unless (> n 0)
	     (signal (car err) (cdr err))))))))

  (advice-add #'straight-fetch-package
	      :around
	      #'elpa-straight-with-retry)
  (advice-add #'straight--clone-repository
	      :around
	      #'elpa-straight-with-retry)

  ;; Additional post-setup of straight.el.
  (require 'straight-x)
  ;;; Appendix
  ;; Get rid of a dumb alias.  straight-‡≤†_‡≤†-mode really slows down all
  ;; minibuffer completion functions.  Since it's a (rarely-used, even)
  ;; alias anyway, I just define it back to nil.  By the way, the alias
  ;; is `straight-package-neutering-mode'.
  (defalias 'straight-‡≤†_‡≤†-mode nil)

  #+end_src
** Emacs Package Manager Setup
:PROPERTIES:
:header-args: :noweb-ref setup-pkgmgr
:ID:                     5ff57b26-2da9-4f1a-91db-de7ea0f0c001
:END:
Using [[https://www.emacswiki.org/emacs/SetupEl][setup.el]] by pkal to manage packages as alternative to use-package
#+begin_src emacs-lisp

  (require 'subr-x)

  ;; Setup `setup'

  (straight-use-package '(setup :type git :host nil :repo "https://git.sr.ht/~pkal/setup"))
  (require 'setup)

  (add-to-list 'setup-modifier-list 'setup-wrap-to-demote-errors)
  ;; Uncomment this for debugging purposes
   (defun dw/log-require (&rest args)
     (with-current-buffer (get-buffer-create "*require-log*")
       (insert (format "%s\n"
                       (file-name-nondirectory (car args))))))
   (add-to-list 'after-load-functions #'dw/log-require)
  ;; added from  https://github.com/daviwil/dotfiles/blob/master/Emacs.org#org-mode

  (defmacro define-setup-macro (name signature &rest body)
    "Shorthand for 'setup-define'. NAME is the name of the local macro. SIGNATURE
	is used as the argument list for FN. If BODY starts with a string, use this as
	the value for :documentation. Any following keywords are passed as OPTS to
	'setup-define'."
    (declare (debug defun))
    (let (opts)
      (when (stringp (car body))
	(setq opts (nconc (list :documentation (pop body)) opts)))
      (while (keywordp (car body))
	(let ((prop (pop body))
	      (val `',(pop body)))
	  (setq opts (nconc (list prop val) opts))))
      `(setup-define ,name
	 (cl-function (lambda ,signature ,@body))
	 ,@opts)))

  #+end_src
*** Setup local macros
  :PROPERTIES:
:header-args: :noweb-ref setup-macros
  :ID:                     41dbce54-3e02-42f3-aaba-21dc7801c19e
:END:
 local-macros for setup.el
 #+begin_src emacs-lisp
   (define-setup-macro :straight (recipe)
     "Install RECIPE with 'straight-use-package'. This macro can be used as HEAD,
                          and will replace itself with the first RECIPE's package."
     :repeatable t
     :shorthand (lambda (sexp)
                  (let ((recipe (cadr sexp)))
                    (if (consp recipe)
                        (car recipe)
                      recipe)))
     `(straight-use-package ',recipe))

   (defun +setup-warn (message &rest args)
     "Warn the user that something bad happened in `setup'."
     (display-warning 'setup (format message args)))

   (setup-define :face
     (lambda (face spec)
       `(custom-set-faces '(,face ,spec 'now "Customised by `setup'.")))
     :documentation "Customise FACE with SPEC using `custom-set-faces'."
     :repeatable t)

   (setup-define :straight-when
     (lambda (recipe condition)
       `(if ,condition
            (straight-use-package ',recipe)
          ,(setup-quit)))
     :documentation
     "Install RECIPE with `straight-use-package' when CONDITION is met.
         If CONDITION is false, stop evaluating the body.  This macro can
         be used as HEAD, and will replace itself with the RECIPE's
         package.  This macro is not repeatable."
     :repeatable nil
     :indent 1
     :shorthand (lambda (sexp)
                  (let ((recipe (cadr sexp)))
                    (if (consp recipe) (car recipe) recipe))))

   (define-setup-macro :hide-mode (&optional mode)
     "Hide the mode-line lighter of the current mode. Alternatively, MODE can be
                      specified manually, and override the current mode."
     :after-loaded t
     (let ((mode (or mode (setup-get 'mode))))
       `(progn
          (setq minor-mode-alist
                (remq (assq ',(intern (format "%s-mode" mode)) minor-mode-alist)
                      minor-mode-alist))
          (setq minor-mode-alist
                (remq (assq ',mode minor-mode-alist)
                      minor-mode-alist)))))

   (define-setup-macro :load-after (features &rest body)
     "Load the current feature after FEATURES."
     :indent 1
     (let ((body `(progn
                    (require ',(setup-get 'feature))
                    ,@body)))
       (dolist (feature (nreverse (doom-enlist features)))
         (setq body `(with-eval-after-load ',feature ,body)))
       body))

   (define-setup-macro :disable ()
     "Unconditionally abort the evaluation of the current body."
     (setup-quit))

   (define-setup-macro :delay (seconds)
     "Require the current FEATURE after SECONDS of idle time."
     :indent 1
     `(run-with-idle-timer ,seconds nil #'require ',(setup-get 'feature) nil t))

   (define-setup-macro :with-idle-delay (seconds &rest body)
     "Evaluate BODY after SECONDS of idle time."
     :indent 1
     `(run-with-idle-timer ,seconds nil (lambda () ,@body)))

   (define-setup-macro :advise (symbol where arglist &rest body)
     "Add a piece of advice on a function. See 'advice-add' for more details."
     :after-loaded t
     :debug '(sexp sexp function-form)
     :indent 3
     (let ((name (gensym "setup-advice-")))
       `(progn
          (defun ,name ,arglist ,@body)
          (advice-add ',symbol ,where #',name))))

   (setup-define :needs
     (lambda (executable)
       `(unless (executable-find ,executable)
          ,(setup-quit)))
     :documentation "If EXECUTABLE is not in the path, stop here."
     :repeatable 1)


#+end_src
Sometimes it's good to clean up unused repositories if I've removed packages from my configuration.
Use =straight-remove-unused-repos= for this purpose.

Setup some popular packages
#+begin_src emacs-lisp
  ;; popular packages
  (setup (:straight el-patch))
  (setup (:straight s))
  (setup (:straight dash))
  (setup (:straight async))
  (setup (:straight request))

  

  ;; profiler
  (setup (:straight esup)) ;; :defer t)

  ;;use-package - for copied configs
  (straight-use-package 'use-package) ;; use use-package for complicated copied config
#+end_src
** Environment
:PROPERTIES:
:header-args: :noweb-ref environment
:ID:                     08d9a2dc-6b27-4316-9fde-f62d5d52a92a
:END:
Setup the Emacs environment from the local env
#+begin_src emacs-lisp
  (defun doom-load-envvars-file (file &optional noerror)
  "Read and set envvars from FILE.
      If NOERROR is non-nil, don't throw an error if the file doesn't exist or is
      unreadable. Returns the names of envvars that were changed."
  (if (null (file-exists-p file))
      (unless noerror
	(signal 'file-error (list "No envvar file exists" file)))
    (with-temp-buffer
      (insert-file-contents file)
      (when-let (env (read (current-buffer)))
	(let ((tz (getenv-internal "TZ")))
	  (setq-default
	   process-environment
	   (append env (default-value 'process-environment))
	   exec-path
	   (append (split-string (getenv "PATH") path-separator t)
		   (list exec-directory))
	   shell-file-name
	   (or (getenv "SHELL")
	       (default-value 'shell-file-name)))
	  (when-let (newtz (getenv-internal "TZ"))
	    (unless (equal tz newtz)
	      (set-time-zone-rule newtz))))
	env))))

      (doom-load-envvars-file "~/.cache/emacs/env")

#+end_src
** Emacs Startup Setup
:PROPERTIES:
:header-args: :noweb-ref emacs-startup
:ID:                     41de579e-bfb1-43e0-8799-2216e33e497e
:END:
Show startup time
#+begin_src emacs-lisp

  (setup show-startup-time
    (:with-hook emacs-startup-hook
      (:hook enfer/show-startup-time)))

#+end_src
*** Garbage collection automatic
:PROPERTIES:
:ID:                     f282c662-4830-44e2-927b-48bf198e8381
:END:
Configure grabage collection
#+begin_src emacs-lisp
  (setup (:straight gcmh)
    (setq gcmh-auto-idle-delay-factor 10)
    (setq gcmh-high-cons-threshold (* 128 1024 1024))
    (setq gcmh-idle-delay 'auto)
    (gcmh-mode 1)
    (:hide-mode))

#+end_src

*** Auto compile and Benchmarking
:PROPERTIES:
:ID:                     f1aecd27-d27e-4b5e-9291-4ef3a014edf7
:END:
#+begin_src emacs-lisp

  (setup (:straight benchmark-init)
    (:disable) ; Disabled when not benchmarking.
    (define-advice define-obsolete-function-alias (:filter-args (ll))
      (let ((obsolete-name (pop ll))
            (current-name (pop ll))
            (when (if ll (pop ll) "1"))
            (docstring (if ll (pop ll) nil)))
        (list obsolete-name current-name when docstring)))
    (:require benchmark-init-modes)
    (:global-bind
     "<M-f2>" #'benchmark-init/show-durations-tabulated
     "<M-f3>" #'benchmark-init/show-durations-tree)
    (:with-hook after-init-hook
      (:hook benchmark-init/deactivate)))

  (setup (:straight auto-compile)
    (auto-compile-on-load-mode 1)
    (auto-compile-on-save-mode 1)
    (:hide-mode)
    (:hide-mode auto-compile-on-load))

#+end_src
*** Keep Emacs Directory clean
:PROPERTIES:
:ID:                     6a5d7242-ad99-4056-81cd-344f0a3d3b97
:END:
Use no-littering to automatically set common paths to the new user-emacs-directory
#+begin_src emacs-lisp
(setup (:straight no-littering)
  (require 'no-littering))

#+end_src

* Emacs Sane defaults
:PROPERTIES:
:ID:                     0b7a23eb-354b-4f88-bdb6-fbf54081e1f3
:END:
** Constants
:PROPERTIES:
:ID:                     8e5d71f2-1d6b-4a25-843d-980894a67fac
:END:
Set Up Good Defaults. Taken from [[https://github.com/mfiano/dotfiles/blob/master/.emacs.d/lisp/mf-settings.el][mifano's emacs setup]]

Some constants that I use.
#+begin_src emacs-lisp :noweb-ref constants

  (require 'subr-x)
    ;;; Initialise Constants
  (defconst ENV-IS-NATIVECOMP? (if (fboundp 'native-comp-available-p) (native-comp-available-p)))
  (defconst ENV-IS-GRAPHIC? (display-graphic-p))
  (defconst ENV-IS-MAC?     (eq system-type 'darwin))
  (defconst ENV-IS-LINUX?   (eq system-type 'gnu/linux))
  (defconst ENV-IS-TERMUX?
    (string-suffix-p "Android" (string-trim (shell-command-to-string "uname -a"))))
  (defconst env-sys-name (system-name))

  (defmacro fn (&rest body)
    `(lambda () ,@body))

  (defun doom-enlist (exp)
    "Return EXP wrapped in a list, or as-is if already a list."
    (declare (pure t) (side-effect-free t))
    (if (proper-list-p exp) exp (list exp)))
#+end_src

** Keyboard
:PROPERTIES:
:ID:                     a218fd94-1b2d-405d-a572-53bf5a382654
:END:
#+begin_src emacs-lisp :noweb-ref keyboard
  (use-package general
    :commands (general-define-key))

  (general-create-definer leader-def
    :states nil
    :keymaps 'override
    :prefix "M-m"
    :prefix-command 'prefix-command
    :prefix-map 'prefix-map)

  (leader-def
    "/" '(nil :which-key "search...")
    "[" '(nil :which-key "previous...")
    "a" '(nil :which-key "align...")
    "g" '(nil :which-key "git...")
    "i" '(nil :which-key "insert...")
    "j" '(nil :which-key "jump...")
    "o" '(nil :which-key "open..."))

  (use-package bind-key)

     (defvar kbd-escape-hook nil
       "A hook run after \\[keyboard-quit] is pressed.
     Triggers `kbd-escape'.
     If any hook returns non-nil, all hooks after it are ignored.")

     (defun kbd-escape ()
       "Run the `kbd-escape-hook'."
       (interactive)
       (cond ((minibuffer-window-active-p (minibuffer-window))
       ;; quit the minibuffer if open.
       (abort-recursive-edit))
      ;; Run all escape hooks. If any returns non-nil, then stop
      ;; there.
      ((cl-find-if #'funcall kbd-escape-hook))
      ;; don't abort macros
      ((or defining-kbd-macro executing-kbd-macro) nil)
      ;; Back to the default
      ((keyboard-quit))))

     (global-set-key [remap keyboard-quit] #'kbd-escape)

       (setup (:straight which-key)
    ;;    (which-key-mode 1)
    ;;   (setq which-key-add-column-padding 2)
    ;;   (setq which-key-idle-delay 0.5)
    ;;   (setq which-key-idle-secondary-delay 0.1)
    ;;   (setq which-key-max-display-columns nil)
    ;;   (setq which-key-min-display-lines 6)
    ;;   (setq which-key-replacement-alist
    ;;     '((("left") . ("ü°∏"))
    ;;       (("right") . ("ü°∫"))
    ;;       (("up") . ("ü°π"))
    ;;       (("down") . ("ü°ª"))
    ;;       (("delete") . ("DEL"))
    ;;       (("\\`DEL\\'") . ("BKSP"))
    ;;       (("RET") . ("‚èé"))
    ;;       (("next") . ("PgDn"))
    ;;       (("prior") . ("PgUp"))))
    ;;   (setq which-key-sort-order 'which-key-key-order-alpha)
    ;;   (setq which-key-sort-uppercase-first nil)
    ;;   (which-key-setup-minibuffer)
    ;; ;;  (:with-hook which-key-init-buffer-hook
    ;;  ;;   (:hook (lambda (setq line-spacing 4))))
       (:hide-mode))

  (use-package which-key
    :hook (after-init . which-key-mode))

#+end_src
keychords with hydra
#+begin_src emacs-lisp :noweb-ref keyboard

(setup (:straight hydra)
  (require 'hydra))

#+end_src
* Emacs Packages
:PROPERTIES:
:ID:                     7946938d-411b-45f0-9f86-ac04b3cccbdc
:END:
** Utility Functions & macros
:PROPERTIES:
:ID:                     7ac6b421-f461-44d6-9b26-8b26fc00bbb1
:END:

These have been sucked from [[https://github.com/mfiano/dotfiles/blob/master/.emacs.d/lisp/mf-util.el][mifano]] and doom

*** Macros
:PROPERTIES:
:header-args: :noweb-ref macros
:ID:                     c9538dff-30bc-4c0e-b196-4020bf042dcd
:END:
#+begin_src emacs-lisp
  (require 'cl-lib)

  (defmacro +define-dir (name directory &optional docstring inhibit-mkdir)
    "Define a variable and function NAME expanding to DIRECTORY.
      DOCSTRING is applied to the variable.  Ensure DIRECTORY exists in
      the filesystem, unless INHIBIT-MKDIR is non-nil."
    (declare (indent 2))
    (unless inhibit-mkdir
      (make-directory (eval directory) :parents))
    `(progn
       (defvar ,name ,directory
         ,(concat docstring (when docstring "\n")
                  "Defined by `/define-dir'."))
       (defun ,name (file &optional mkdir)
         ,(concat "Expand FILE relative to variable `" (symbol-name name) "'.\n"
                  "If MKDIR is non-nil, the directory is created.\n"
                  "Defined by `/define-dir'.")
         (let ((file-name (expand-file-name (convert-standard-filename file)
                                            ,name)))
           (when mkdir
             (make-directory (file-name-directory file-name) :parents))
           file-name))))

  (defun +suppress-messages (oldfn &rest args) ; from pkal
    "Advice wrapper for suppressing `message'.
      OLDFN is the wrapped function, that is passed the arguments
      ARGS."
    (let ((msg (current-message)))
      (prog1
          (let ((inhibit-message t))
            (apply oldfn args))
        (when msg
          (message "%s" msg)))))

  (defmacro letenv! (envvars &rest body)
    "Lexically bind ENVVARS in BODY, like `let' but for `process-environment'."
    (declare (indent 1))
    `(let ((process-environment (copy-sequence process-environment)))
       (dolist (var (list ,@(cl-loop for (var val) in envvars
                                     collect `(cons ,var ,val))))
         (setenv (car var) (cdr var)))
       ,@body))

  (defmacro letf! (bindings &rest body)
    "Temporarily rebind function, macros, and advice in BODY.

          Intended as syntax sugar for `cl-letf', `cl-labels', `cl-macrolet', and
          temporary advice.

          BINDINGS is either:

            A list of, or a single, `defun', `defun*', `defmacro', or `defadvice' forms.
            A list of (PLACE VALUE) bindings as `cl-letf*' would accept.

          TYPE is one of:

            `defun' (uses `cl-letf')
            `defun*' (uses `cl-labels'; allows recursive references),
            `defmacro' (uses `cl-macrolet')
            `defadvice' (uses `defadvice!' before BODY, then `undefadvice!' after)

          NAME, ARGLIST, and BODY are the same as `defun', `defun*', `defmacro', and
          `defadvice!', respectively.

          \(fn ((TYPE NAME ARGLIST &rest BODY) ...) BODY...)"
    (declare (indent defun))
    (setq body (macroexp-progn body))
    (when (memq (car bindings) '(defun defun* defmacro defadvice))
      (setq bindings (list bindings)))
    (dolist (binding (reverse bindings) body)
      (let ((type (car binding))
            (rest (cdr binding)))
        (setq
         body (pcase type
                (`defmacro `(cl-macrolet ((,@rest)) ,body))
                (`defadvice `(progn (defadvice! ,@rest)
                                    (unwind-protect ,body (undefadvice! ,@rest))))
                ((or `defun `defun*)
                 `(cl-letf ((,(car rest) (symbol-function #',(car rest))))
                    (ignore ,(car rest))
                    ,(if (eq type 'defun*)
                         `(cl-labels ((,@rest)) ,body)
                       `(cl-letf (((symbol-function #',(car rest))
                                   (fn! ,(cadr rest) ,@(cddr rest))))
                          ,body))))
                (_
                 (when (eq (car-safe type) 'function)
                   (setq type (list 'symbol-function type)))
                 (list 'cl-letf (list (cons type rest)) body)))))))


  (defmacro fn! (&rest body)
    `(lambda () (interactive) ,@body))

                ;;; Closure factories
  (defmacro fn!! (arglist &rest body)
    "Returns (cl-function (lambda ARGLIST BODY...))
              The closure is wrapped in `cl-function', meaning ARGLIST will accept anything
              `cl-defun' will. Implicitly adds `&allow-other-keys' if `&key' is present in
              ARGLIST."
    (declare (indent defun) (doc-string 1) (pure t) (side-effect-free t))
    `(cl-function
      (lambda
        ,(letf! (defun* allow-other-keys (args)
                  (mapcar
                   (lambda (arg)
                     (cond ((nlistp (cdr-safe arg)) arg)
                           ((listp arg) (allow-other-keys arg))
                           (arg)))
                   (if (and (memq '&key args)
                            (not (memq '&allow-other-keys args)))
                       (if (memq '&aux args)
                           (let (newargs arg)
                             (while args
                               (setq arg (pop args))
                               (when (eq arg '&aux)
                                 (push '&allow-other-keys newargs))
                               (push arg newargs))
                             (nreverse newargs))
                         (append args (list '&allow-other-keys)))
                     args)))
           (allow-other-keys arglist))
        ,@body)))

  (defmacro cmd! (&rest body)
    "Returns (lambda () (interactive) ,@body)
              A factory for quickly producing interaction commands, particularly for keybinds
              or aliases."
    (declare (doc-string 1) (pure t) (side-effect-free t))
    `(lambda (&rest _) (interactive) ,@body))

  (defmacro quiet! (&rest forms)
    `(cond
      (noninteractive
       (let ((old-fn (symbol-function 'write-region)))
         (cl-letf ((standard-output (lambda (&rest _)))
                   ((symbol-function 'load-file)
                    (lambda (file) (load file nil t)))
                   ((symbol-function 'message) (lambda (&rest _)))
                   ((symbol-function 'write-region)
                    (lambda (start end filename &optional append visit lockname
                                   mustbenew)
                      (unless visit (setq visit 'no-message))
                      (funcall old-fn start end filename append visit lockname
                               mustbenew))))
           ,@forms)))
      ((or debug-on-error debug-on-quit)
       ,@forms)
      ((let ((inhibit-message t)
             (save-silently t))
         (prog1 ,@forms (message ""))))))

            ;;; Mutation
  (defmacro appendq! (sym &rest lists)
    "Append LISTS to SYM in place."
    `(setq ,sym (append ,sym ,@lists)))

  (defmacro setq! (&rest settings)
    "A stripped-down `customize-set-variable' with the syntax of `setq'.

            This can be used as a drop-in replacement for `setq'. Particularly when you know
            a variable has a custom setter (a :set property in its `defcustom' declaration).
            This triggers setters. `setq' does not."
    (macroexp-progn
     (cl-loop for (var val) on settings by 'cddr
              collect `(funcall (or (get ',var 'custom-set) #'set)
                                ',var ,val))))

  (defmacro delq! (elt list &optional fetcher)
    "`delq' ELT from LIST in-place.

            If FETCHER is a function, ELT is used as the key in LIST (an alist)."
    `(setq ,list
           (delq ,(if fetcher
                      `(funcall ,fetcher ,elt ,list)
                    elt)
                 ,list)))

  (defmacro pushnew! (place &rest values)
    "Push VALUES sequentially into PLACE, if they aren't already present.
            This is a variadic `cl-pushnew'."
    (let ((var (make-symbol "result")))
      `(dolist (,var (list ,@values) (with-no-warnings ,place))
         (cl-pushnew ,var ,place :test #'equal))))

  (defmacro prependq! (sym &rest lists)
    "Prepend LISTS to SYM in place."
    `(setq ,sym (append ,@lists ,sym)))

  ;;; Loading
  (defmacro add-load-path! (&rest dirs)
    "Add DIRS to `load-path', relative to the current file.
            The current file is the file from which `add-to-load-path!' is used."
    `(let ((default-directory ,(dir!))
           file-name-handler-alist)
       (dolist (dir (list ,@dirs))
         (cl-pushnew (expand-file-name dir) load-path :test #'string=))))

 #+end_src
*** Variables
:PROPERTIES:
:header-args: :noweb-ref variables
:ID:                     96932d92-d4cc-4d1f-ace0-60da51f8e009
:END:
#+begin_src emacs-lisp
(defvar enfer/ignored-directories
  `(,user-emacs-directory
    "eln-cache"))

(defvar enfer/ignored-suffixes
  '(".7z" ".bz2" ".db" ".dll" ".dmg" ".elc" ".exe" ".fasl" ".gz" ".iso" ".jar"
    ".o" ".pyc" ".rar" ".so" ".sql" ".sqlite" ".tar" ".tgz" ".xz" ".zip"))
#+end_src
*** Functions
:PROPERTIES:
:header-args: :noweb-ref functions
:ID:                     f00d3971-f116-4a18-9aad-a005ea5eb4ea
:END:
#+begin_src emacs-lisp
  (defun enfer/show-startup-time ()
    (message "Heure de d√©marrage d'Emacs: %.2fs (%d GCs (ramasse-miettes))"
             (float-time (time-subtract after-init-time before-init-time))
             gcs-done))

  (defun /etc-file (file-name)
    (expand-file-name (format "etc/%s" file-name) user-emacs-directory))

  (defun /cache-dir-p (path)
    (string-prefix-p (getenv "XDG_CACHE_HOME") (expand-file-name path)))

  (+define-dir /etc (locate-user-emacs-file "etc")
    "Directory for all of Emacs's various files.
    See `no-littering' for examples.")

  (+define-dir sync/ (expand-file-name "~/Sync")
    "My Syncthing directory.")


  (defun mf/smarter-move-beginning-of-line (arg)
    (interactive "^p")
    (setq arg (or arg 1))
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))
    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  (defun mf/yank-primary-selection ()
    (interactive)
    (let ((primary (or (gui-get-primary-selection) (gui-get-selection))))
      (when primary
        (push-mark (point))
        (insert-for-yank primary))))

  (defun mf/delete-file (filename)
    (interactive "f")
    (when (and filename (file-exists-p filename))
      (let ((buffer (find-buffer-visiting filename)))
        (when buffer
          (kill-buffer buffer)))
      (delete-file filename)))

  (defun mf/rename-file ()
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' n'a ‚Äã‚Äãpas de fichier associ√©!" name)
        (let* ((dir (file-name-directory filename))
               (new-name (read-file-name "Nouveau nom de fichier: " dir)))
          (cond ((get-buffer new-name)
                 (error "Un Buffer nomm√© '%s' existe d√©j√†!" new-name))
                (t
                 (let ((dir (file-name-directory new-name)))
                   (when (and (not (file-exists-p dir))
                              (yes-or-no-p (format "Cr√©er le r√©pertoire '%s'?"
                                                   dir)))
                     (make-directory dir t)))
                 (rename-file filename new-name 1)
                 (rename-buffer new-name)
                 (set-visited-file-name new-name)
                 (set-buffer-modified-p nil)
                 (when (fboundp 'recentf-add-file)
                   (recentf-add-file new-name)
                   (recentf-remove-if-non-kept filename))
                 (message "Fichier '%s' renomm√© avec succ√®s en '%s'" name
                          (file-name-nondirectory new-name))))))))

  (defun doom-unquote (exp)
    "Return EXP unquoted."
    (declare (pure t) (side-effect-free t))
    (while (memq (car-safe exp) '(quote function))
      (setq exp (cadr exp)))
    exp)


  (defun doom-keyword-intern (str)
    "Converts STR (a string) into a keyword (`keywordp')."
    (declare (pure t) (side-effect-free t))
    (cl-check-type str string)
    (intern (concat ":" str)))

  (defun doom-keyword-name (keyword)
    "Returns the string name of KEYWORD (`keywordp') minus the leading colon."
    (declare (pure t) (side-effect-free t))
    (cl-check-type keyword keyword)
    (substring (symbol-name keyword) 1))


  (defun +ensure-after-init (function)
    "Ensure FUNCTION runs after init, or now if already initialised.
  If Emacs is already started, run FUNCTION.  Otherwise, add it to
  `after-init-hook'.  FUNCTION is called with no arguments."
    (if after-init-time
        (funcall function)
      (add-hook 'after-init-hook function)))

  ;;
      ;;; Sugars

  (defun dir! ()
    "Returns the directory of the emacs lisp file this macro is called from."
    (when-let (path (file!))
      (directory-file-name (file-name-directory path))))

  (defun file! ()
    "Return the emacs lisp file this macro is called from."
    (cond ((bound-and-true-p byte-compile-current-file))
          (load-file-name)
          ((stringp (car-safe current-load-list))
           (car current-load-list))
          (buffer-file-name)
          ((error "Cannot get this file-path"))))

#+end_src
** Setup if exists Executable
:PROPERTIES:
:ID:                     8646057b-7936-46f3-a18e-b4b69372eb25
:END:
ripgrep and gist
#+begin_src emacs-lisp :noweb-ref pkg-utils
  (+with-message "pkg-util"
    (setup (:straight rg)
      (:when-loaded
	(setq rg-group-result t)
	(setq rg-ignore-case 'smart)))

    (setup (:straight gist)
      (setq gist-view-gist t)
      (:hide-mode))

    (setup (:straight link-hint)
      (:require link-hint))

    ) ;; end of pkg-utils +with-message
#+end_src
*** MAC PATH specific
:PROPERTIES:
:ID:                     59f904d5-a915-4e9b-9102-197d3c1bcf73
:END:
#+begin_src emacs-lisp :noweb-ref pkg-editor
  ;;(cua-mode 1)
  ;; load doom-path

  ;;    (setup (:straight-when exec-path-from-shell ENV-IS-MAC?)
  ;;      (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE" "GOPATH" "HOMEBREW_PREFIX"))
  ;;        (add-to-list 'exec-path-from-shell-variables var))
  ;;      (exec-path-from-shell-initialize)
  ;;      (add-to-list 'exec-path (expand-file-name "/bin" (getenv  "HOMEBREW_PREFIX")))
  ;;      )


#+end_src
** Emacs UI Appearance
:PROPERTIES:
:header-args: :noweb-ref pkg-ui
:ID:                     3b410e52-29cb-42e3-aade-decf4bc46fd1
:END:
*** Default Appearance setting
:PROPERTIES:
:ID:                     328a3836-2d52-443e-a443-1a39ba555d3e
:END:
Some Defaults for my preferred appearance
#+begin_src emacs-lisp
  ;; be quiet at startup; don't load or display anything unnecessary
  (setq-default
   inhibit-startup-message t
   inhibit-startup-screen t
   inhibit-startup-echo-area-message user-login-name
   inhibit-default-init t
   initial-major-mode 'fundamental-mode
   initial-scratch-message nil
   use-file-dialog nil
   use-dialog-box nil)

  ;; disable cursort blinking
  (blink-cursor-mode -1)

  ;; play around with frame title (which I rarely see)
  (setq frame-title-format
        '("%b@"
          (:eval (or (file-remote-p default-directory 'host)
                     system-name))
          " ‚Äî Emacs"))

  ;; for some reason only this removes the clutter with xmonad
  (setup  scroll-bar
    (scroll-bar-mode -1))

  ;; y/n instead of yes/no
  (fset #'yes-or-no-p #'y-or-n-p)

  ;; mode line
  (column-number-mode)
  (size-indication-mode)

  (setq-default
   ;; no beeping and no blinking please
   ring-bell-function #'ignore
   visible-bell nil

   ;; make sure that trash is not drawed
   indicate-buffer-boundaries nil
   indicate-empty-lines nil

   ;; don't resize emacs in steps, it looks weird and plays bad with
   ;; window manager.
   window-resize-pixelwise t
   frame-resize-pixelwise t

   ;; disable bidirectional text for tiny performance boost
   bidi-display-reordering nil

   ;; hide cursors in other windoes
   cursor-in-non-selected-windows nil)

  ;; (setup appearance
  ;;   ;;(setq blink-matching-paren nil)
  ;;   (setq display-time-default-load-average nil)
  ;;   (setq echo-keystrokes 0.1)
  ;;   (setq highlight-nonselected-windows nil)
  ;;   (setq idle-update-delay 1.0)
  ;;   (setq inhibit-startup-echo-area-message t)
  ;;   (setq inhibit-startup-screen t)
  ;;   (setq use-dialog-box nil)
  ;;   (setq use-file-dialog nil)
  ;;   (setq visible-bell nil)
  ;;   (setq x-gtk-use-system-tooltips nil)
  ;;   (setq x-stretch-cursor nil)
  ;;   (setq-default bidi-display-reordering 'left-to-right)
  ;;   (setq-default bidi-paragraph-direction 'left-to-right)
  ;;   (setq-default cursor-in-non-selected-windows nil)
  ;;   (setq-default cursor-type 'hbar)
  ;;   (setq-default display-line-numbers-widen t)
  ;;   (setq-default display-line-numbers-width 3)
  ;;   (setq-default indicate-buffer-boundaries nil)
  ;;   (setq-default truncate-lines t)
  ;;   (:with-hook (prog-mode-hook text-mode-hook conf-mode-hook)
  ;;     (:hook display-line-numbers-mode))
  ;;   (:with-hook text-mode-hook
  ;;     (:hook visual-line-mode)))
#+end_src
*** Menu and Tool bars
:PROPERTIES:
:ID:                     29668972-915f-4b30-b610-8eb235bee74c
:END:
#+begin_src elisp
(menu-bar-mode -1)            ; Disable the menu bar
(unless ENV-IS-TERMUX?
  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room
  (menu-bar-mode 1))          ; I like menu whilst learning

#+end_src
*** Fonts & Emojis
:PROPERTIES:
:ID:                     e70dbb98-1d6f-4837-8b45-ffc730e45e99
:END:

On Linux, I have a custom build of Iosevka that I like.

#+begin_src emacs-lisp :noweb-ref pkg-ui
  (setup (:straight all-the-icons)
    (:load-after marginalia
      (:straight all-the-icons-completion)
      (all-the-icons-completion-mode 1)
      (:with-mode marginalia-mode
        (:hook all-the-icons-completion-marginalia-setup)))
    (:load-after dired
      (:straight all-the-icons-dired)
      (:with-mode dired-mode
        (:hook all-the-icons-dired-mode))))

  (setup (:straight emojify)
    (setq emojify-emoji-styles '(unicode))
    (global-emojify-mode 1))

  (setup (:straight unicode-fonts)
    (unicode-fonts-setup))

  (setup (:straight mixed-pitch)
      (:hook-into text-mode)

  ;; Set the font face based on platform
  (pcase system-type
    ((or 'gnu/linux 'windows-nt 'cygwin)
     (set-face-attribute 'default nil
                         :font "JetBrains Mono"
                         :weight 'light
                         :height 120
                         ))
    ('darwin (set-face-attribute 'default nil :font "Fira Mono" :height 130)))

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil
                      :font "JetBrains Mono"
                      :weight 'light
                      )

  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil
                      ;; :font "Cantarell"
                      :font "Iosevka Aile"
                      :weight 'light))

  ;; Required for proportional font in posframe
  (setup (:straight company-posframe)
    (company-posframe-mode 1))

  (setup (:straight default-text-scale)
    (:bind
     "M--" default-text-scale-decrease
     "M-+" default-text-scale-increase
     "M-=" default-text-scale-reset)
    (default-text-scale-mode 1))

  (setup (:straight dimmer)
    (setq dimmer-fraction 0.3)
    (dimmer-mode 1))

  ;; Install it from sources, because ELPA version has invalid
;; signature.
(setup (:straight (spinner
             :type git
             :host github
             :repo "Malabarba/spinner.el")))
#+end_src

*** Frame titles, sizes and mouse setup
:PROPERTIES:
:ID:                     8d16458c-e38a-4060-91e8-40a3a034e639
:END:

#+begin_src emacs-lisp
  ;; (setq-default frame-title-format
  ;;               (concat invocation-name "@" (system-name)
  ;;                       ": %b %+%+ %f"))
  (unless ENV-IS-TERMUX?
    (setup mouse
      (setq focus-follows-mouse t)
      (setq make-pointer-invisible t)
      (setq mouse-1-click-follows-link t)
      (setq mouse-autoselect-window t)
      (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
      (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
      ;;(setq mouse-wheel-scroll-amount '(3 ((shift) . hscroll)))
      (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
      (setq mouse-wheel-scroll-amount-horizontal 2)
      (setq mouse-yank-at-point t)
      (setq scroll-step 1) ;; keyboard scroll one line at a time
      (setq use-dialog-box nil))) ;; Disable dialog boxes since they weren't working in Mac OSX


  (unless ENV-IS-TERMUX?
    (setup scrolling
      (setq auto-hscroll-mode 'current-line)
      (setq auto-window-vscroll nil)
      (setq fast-but-imprecise-scrolling t)
      (setq hscroll-margin 16)
      (setq hscroll-step 1)
      (setq scroll-conservatively 101)
      (setq scroll-margin 8)
      (setq scroll-preserve-screen-position t)
      (setq scroll-step 1)))

  (unless ENV-IS-TERMUX?
    (set-frame-parameter (selected-frame) 'alpha '(90 . 90))
    (add-to-list 'default-frame-alist '(alpha . (90 . 90)))
    (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
    (add-to-list 'default-frame-alist '(fullscreen . maximized)))
#+end_src

*** Themes & Modeline
:PROPERTIES:
:ID:                     86d008a2-d188-496b-a6c8-564b6a68a88a
:END:

#+begin_src emacs-lisp
    (setup (:straight spacegray-theme))

   (use-package modus-themes
     :if ENV-IS-GRAPHIC?
     :init
     (setq-default
      modus-themes-diffs 'desaturated
      ;;modus-themes-headings '((t . section))
      modus-themes-bold-constructs t
      modus-themes-syntax 'faint
      modus-themes-prompts 'subtle
      modus-themes-completions 'opionated))

    (setup (:straight doom-themes)
      (setq doom-themes-enable-bold t)
      (setq doom-themes-enable-italic t)
      (doom-themes-org-config))

    (unless ENV-IS-TERMUX?
         (load-theme 'modus-operandi t)
     ;; (load-theme 'doom-palenight t)
      (doom-themes-visual-bell-config))

    ;; Mode-line
    ;;Basic Customisation
    (setq display-time-format "%l:%M %p %b %y"
          display-time-default-load-average nil)

    ;; Doom Modeline

    (setup (:straight minions)
      (:hook-into doom-modeline-mode))

    (setup (:straight doom-modeline)
     ;; (setq doom-modeline-bar-width 4)
      (setq doom-modeline-buffer-encoding nil)
      (setq doom-modeline-buffer-file-name-style 'relative-from-project)
      (setq doom-modeline-height 30)
      (setq doom-modeline-major-mode-icon t)
      (setq doom-modeline-minor-modes t)
      (:with-hook window-setup-hook
        (:hook (fn (set-face-attribute
                    'mode-line nil :family "Iosevka Slab" :height 130))))
      (:hook-into window-setup)
      (:option doom-modeline-height 15
               doom-modeline-bar-width 6
               doom-modeline-lsp t
               doom-modeline-github nil
               doom-modeline-mu4e nil
               doom-modeline-irc t
               doom-modeline-minor-modes t
               doom-modeline-persp-name nil
               doom-modeline-buffer-file-name-style 'truncate-except-project
               doom-modeline-major-mode-icon nil)
      (custom-set-faces '(mode-line ((t (:height 0.85))))
                        '(mode-line-inactive ((t (:height 0.85))))))

(use-package bui
  :defer t)

;; what does this TODO?
(use-package lister
  :straight (lister
             :type git
             :host github
             :repo "publicimageltd/lister"
             :branch "archive-version-0.7.2")
  :defer t)


#+end_src
*** Don't show default modeline
:PROPERTIES:
:ID:                     f761fe6b-6855-4252-848d-de3be17b045a
:END:

Wait until my *fancy* modeline is loaded -- from [[https://github.com/KaratasFurkan/.emacs.d#remove-redundant-ui][Furkan Karata≈ü]].

#+begin_src emacs-lisp
    (setq-default mode-line-format nil)

#+end_src
*** highlights and diff
:PROPERTIES:
:ID:                     6d744ef7-add5-408d-8f5f-e7112027ce62
:END:
setup diff and highlights
#+begin_src emacs-lisp
    (setup (:straight highlight-numbers)
      (:hook-into prog-mode)
      (:hide-mode))

    (setup (:straight hl-fill-column)
      (:require hl-fill-column)
      (:hook-into prog-mode text-mode conf-mode))

    (setup (:straight hl-line)
      (global-hl-line-mode 1))

    (setup (:straight hl-todo)
      (global-hl-todo-mode 1))

  (setup (:straight diff-hl)
    (global-diff-hl-mode 1)
    (:with-mode dired-mode
      (:hook diff-hl-dired-mode))
    (:load-after magit
      (:with-hook magit-pre-refresh-hook
        (:hook diff-hl-magit-pre-refresh))
      (:with-hook magit-post-refresh-hook
        (:hook diff-hl-magit-post-refresh))))

#+end_src
** Window Setup
:PROPERTIES:
:header-args: :noweb-ref windose
:ID:                     1c36aad2-dfb6-4189-9aea-45732dba3d5d
:END:

1st some defaults

#+begin_src emacs-lisp
  (setup windows
      (setq split-height-threshold nil)
      (setq split-width-threshold 160)
      (setq window-divider-default-bottom-width 2)
      (setq window-divider-default-places t)
      (setq window-divider-default-right-width 2)
      (setq window-resize-pixelwise nil))

#+end_src
#+begin_src emacs-lisp
  (setup (:straight ace-window)
    (setq aw-background t)
    (setq aw-scope 'frame)
    (ace-window-display-mode 1)
    (:hide-mode))

(setup (:straight windmove)
  (windmove-default-keybindings))

(setup (:straight winner)
  (winner-mode 1))
  (setq-default window-divider-default-places 'right-only ; only right
                window-divider-default-bottom-width 2
                window-divider-default-right-width 2)
#+end_src

#+begin_src emacs-lisp :noweb-ref pkg-ui
  (window-divider-mode +1)
#+end_src

*** Splitting windows sensibly
:PROPERTIES:
:ID:                     43136dd2-3231-485b-89d9-88c8fe9fd6aa
:END:

This is extremely fiddly and I'd love another option.
- [[https://www.emacswiki.org/emacs/ToggleWindowSplit][ToggleWindowSplit, EmacsWiki]]

#+begin_src emacs-lisp :noweb-ref pkg-window
     (defun window-split-vertically ()
      "Split window vertically."
      (interactive)
      (split-window-right))

    (defun window-split-vertically-and-focus ()
      "Split window vertically and focus it."
      (interactive)
      (split-window-right)
      (windmove-right))

    (defun window-split-horizontally ()
      "Split window horizontally."
      (interactive)
      (split-window-below))

    (defun window-split-horizontally-and-focus ()
      "Split window horizontally and focus it."
      (interactive)
      (split-window-below)
      (windmove-down))

    (defun window-zoom ()
      "Close other windows to focus on this one.
    Activate again to undo this. If the window changes before then,
    the undo expires."
      (interactive)
      (if (and (one-window-p)
               (assq ?_ register-alist))
          (jump-to-register ?_)
        (window-configuration-to-register ?_)
        (delete-other-windows)))

  ;;(setq-default split-width-threshold 100
  ;;                  split-height-threshold 50)
#+end_src
*** Fringes
:PROPERTIES:
:ID:                     2d868201-f74e-4308-9326-55ffecb072a3
:END:

I have grown to love Emacs's little fringes on the side of the
windows.  In fact, I love them so much that I really went overboard
and have made a custom fringe bitmap.

**** Indicate empty lines after the end of the buffer
:PROPERTIES:
:ID:                     ed5dbc40-17dc-4dc1-afe9-438667404b90
:END:

#+begin_src emacs-lisp
  (setq-default indicate-empty-lines t)
#+end_src

**** Indicate the boundaries of the buffer
:PROPERTIES:
:ID:                     18a0a877-886e-4258-9cec-b4c7ade6acb8
:END:

#+begin_src emacs-lisp
  (setq-default indicate-buffer-boundaries 'right)
#+end_src

**** Indicate continuation lines, but only on the left fringe
:PROPERTIES:
:ID:                     a9d9c920-70a0-44f8-9a35-e8dbab82ee02
:END:

#+begin_src emacs-lisp
  (setq-default visual-line-fringe-indicators '(left-curly-arrow nil))
#+end_src

**** Customise fringe bitmaps
:PROPERTIES:
:ID:                     809ba958-cf27-4d36-91a1-cee523bb164c
:END:

***** Curly arrows (continuation lines)
:PROPERTIES:
:ID:                     a6b18024-eff2-4daa-bff3-37a9b190c6a8
:END:

#+begin_src emacs-lisp
  (define-fringe-bitmap 'left-curly-arrow
    [#b11000000
     #b01100000
     #b00110000
     #b00011000])

  (define-fringe-bitmap 'right-curly-arrow
    [#b00011000
     #b00110000
     #b01100000
     #b11000000])
#+end_src

***** Arrows (truncation lines)
:PROPERTIES:
:ID:                     34b749d5-dc05-4f04-ad4a-6477dd225bc6
:END:

#+begin_src emacs-lisp
  (define-fringe-bitmap 'left-arrow
    [#b00000000
     #b01010100
     #b01010100
     #b00000000])

  (define-fringe-bitmap 'right-arrow
    [#b00000000
     #b00101010
     #b00101010
     #b00000000])
#+end_src
** Emacs as an Editor
:PROPERTIES:
:header-args: :noweb-ref pkg-editor
:ID:                     2251b28a-96ec-4776-8039-c7455e886527
:END:
*** Reading mode
:PROPERTIES:
:ID:                     414d00c3-1cd2-4fa0-8f78-79596396d7be
:END:
What does it do?
#+begin_src emacs-lisp
(setup (:require reading)
  ;;(:hook-into view-mode)                ; XXX doesn't go back
  )
#+end_src
*** Indentation
:PROPERTIES:
:ID:                     499df3a6-0e15-4f23-b915-ead73842e866
:END:
use electric-indent but have a way of turning it off
#+begin_src emacs-lisp
;; easier to search
(setq-default
search-default-mode #'char-fold-to-regexp
replace-char-fold t)



;; electric everything (but there must be a way to disable it)
(when (fboundp 'electric-pair-mode)
(add-hook 'after-init-hook 'electric-pair-mode))
(add-hook 'after-init-hook 'electric-indent-mode)

(defun editor-disable-electric-indent ()
"Disable the command `electric-indent-mode' locally."
(electric-indent-local-mode -1))

(defun editor-disable-electric-pair ()
"Disable the command `electric-pair-mode' locally."
  (electric-pair-local-mode -1))

#+end_src

*** Whitespaces
:PROPERTIES:
:ID:                     172e5cef-83e4-499b-a753-34beef9ad275
:END:
#+begin_src emacs-lisp
;; Whitespaces

(setq-default
 indent-tabs-mode nil
 tab-width 2
 require-final-newline t
 tab-always-indent t)

(defun editor-show-trailing-whitespace ()
  "Enable display of trailing whitespace in this buffer."
  (setq-local show-trailing-whitespace t))

(dolist (hook '(prog-mode-hook text-mode-hook conf-mode-hook))
  (add-hook hook 'editor-show-trailing-whitespace))

#+end_src

*** Formatting
:PROPERTIES:
:ID:                     4b0da00e-0866-48e4-8cd7-0b34847c9d14
:END:
use ws-butler
#+begin_src emacs-lisp
    ;; Formatting
    (setq-default
     ;; `ws-butler' is used for better whitespace handling
     delete-trailing-lines nil
     sentence-end-double-space nil
     word-wrap t)

    (setup (:straight (ws-butler
                 :type git
                 :host github
                 :repo "hlissner/ws-butler"))
     (:hide-mode)
     ;; :commands (ws-butler-global-mode)
      (ws-butler-global-mode)
      (setq ws-butler-global-exempt-modes
            (append ws-butler-global-exempt-modes
                    '(special-mode comint-mode term-mode eshell-mode))))


    
    ;; Disable backup files. While I find them useful in general, they
    ;; keep interfering with `org-roam'.

    (setq make-backup-files nil)

  #+end_src

  ACDW setup whitespace defaults
  #+begin_src emacs-lisp :tangle no
    (setup whitespace
      (setq backward-delete-char-untabify-method 'hungry)
      (setq next-line-add-newlines nil)
      (setq sentence-end-double-space nil)
      (setq-default indent-tabs-mode nil)
      (setq-default indicate-empty-lines nil)
      (setq-default tab-always-indent nil)
      (setq-default tab-width 4)
      (:with-hook before-save-hook
        (:hook delete-trailing-whitespace)))

#+end_src
*** Long lines
:PROPERTIES:
:ID:                     07be8af1-fc88-4a04-b390-f40c054f1bd1
:END:
The visual-line-mode function enables line-wrapping. You can run the function separately for each buffer, but ideally, you hook it to all text modes.

When you select (mark) a section of text and start typing, Emacs will not replace the selected text. To enable Emacs deleting selected text, you set the delete-selection-mode variable, as below.

One last sensible default is to enure that Emacs lets you use the page-up and page-down buttons to
go to the first and last line in the buffer.
#+begin_src emacs-lisp
  ;; Long lines

  (setup (:straight visual-fill-column)
    (:option visual-fill-column-center-text t)
;;             (append reading-modes) '(visual-fill-column-mode . +1))
    (:hook #'visual-line-mode)
    (:hook-into org-mode)
    (advice-add #'text-scale-adjust :after #'visual-fill-column-adjust))

  (setup (:straight adaptive-wrap)
    (:with-mode adaptive-wrap-prefix-mode
      (:hook-into visual-column-mode)))


  (setup (:straight unfill)
    ;;:commands (unfill-toggle)
    (:global "M-q"  #'unfill-toggle))

  ;; Overwrite selected text
  ;; (setup (:require delsel)
  ;;  (delete-selection-mode t))

  ;; Scroll to the first and last line of the buffer
  ;;(setq scroll-error-top-bottom t)
#+end_src
Undo is a key function of an editor - bind to Ctrl-Z - disabled
#+begin_src emacs-lisp :tangle no
  ;;undo
  (setup (:straight undo-tree)
    (:hide-mode)
    (:global "C-z"   undo-tree-undo
           "C-S-z" undo-tree-redo)
    (setq undo-tree-auto-save-history nil)
    (global-undo-tree-mode 1))
    #+end_src
*** Move Text
:PROPERTIES:
:ID:                     e876dc83-2902-46e7-8c1c-69e371a03b56
:END:
#+begin_src emacs-lisp
  (setup (:straight move-text)
   ;; :commands (move-text-up
   ;;            move-text-down)
    (:global [M-S-down]  #'move-text-down
             [M-S-up]    #'move-text-up))
#+end_src
*** Move where I Mean
:PROPERTIES:
:ID:                     0afacc7c-7b32-4047-842c-ade5637483c4
:END:
#+begin_src emacs-lisp
(setup  (:straight mwim)
  (:delay 1)
  (:global "C-a"  mwim-beginning))
#+end_src

*** Avy - Filter, Select, Act
:PROPERTIES:
:ID:                     e2c2803d-7159-4431-9bff-1ada59aaece5
:END:
Setup avy in filter, select, act mode
#+begin_src emacs-lisp
    (setup (:straight avy)
     (:disable)
      (:global  "M-j"  'avy-goto-char-timer
                "C-M-s" 'isearch-forward-other-window
                "C-M-r" 'isearch-backward-other-window)
      (setq avy-keys '(?q ?e ?r ?y ?u ?o ?p
                          ?a ?s ?d ?f ?g ?h ?j
                          ?k ?l ?' ?x ?c ?v ?b
                          ?n ?, ?/))

      (defun avy-show-dispatch-help ()
        (let* ((len (length "avy-action-"))
               (fw (frame-width))
               (raw-strings (mapcar
                             (lambda (x)
                               (format "%2s: %-19s"
                                       (propertize
                                        (char-to-string (car x))
                                        'face 'aw-key-face)
                                       (substring (symbol-name (cdr x)) len)))
                             avy-dispatch-alist))
               (max-len (1+ (apply #'max (mapcar #'length raw-strings))))
               (strings-len (length raw-strings))
               (per-row (floor fw max-len))
               display-strings)
          (cl-loop for string in raw-strings
                   for N from 1 to strings-len do
                   (push (concat string " ") display-strings)
                   (when (= (mod N per-row) 0) (push "\n" display-strings)))
          (message "%s" (apply #'concat (nreverse display-strings)))))

      ;; Kill text
      (defun avy-action-kill-whole-line (pt)
        (save-excursion
          (goto-char pt)
          (kill-whole-line))
        (select-window
         (cdr
          (ring-ref avy-ring 0)))
        t)

   ;; (:option avy-dispatch-alist (append (?k avy-action-kill-stay)))
  ;;    (add-to-list 'avy-dispatch-alist '(?k . avy-action-kill-stay))
      (setf (alist-get ?k avy-dispatch-alist) 'avy-action-kill-stay
            (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line)

      ;; Copy text
      (defun avy-action-copy-whole-line (pt)
        (save-excursion
          (goto-char pt)
          (cl-destructuring-bind (start . end)
              (bounds-of-thing-at-point 'line)
            (copy-region-as-kill start end)))
        (select-window
         (cdr
          (ring-ref avy-ring 0)))
        t)

      (setf (alist-get ?w avy-dispatch-alist) 'avy-action-copy
            (alist-get ?W avy-dispatch-alist) 'avy-action-copy-whole-line)

      ;; Yank text
      (defun avy-action-yank-whole-line (pt)
        (avy-action-copy-whole-line pt)
        (save-excursion (yank))
        t)

      (setf (alist-get ?y avy-dispatch-alist) 'avy-action-yank
            (alist-get ?Y avy-dispatch-alist) 'avy-action-yank-whole-line)

      ;; Transpose/Move text
      (defun avy-action-teleport-whole-line (pt)
        (avy-action-kill-whole-line pt)
        (save-excursion (yank)) t)

      (setf (alist-get ?t avy-dispatch-alist) 'avy-action-teleport
            (alist-get ?T avy-dispatch-alist) 'avy-action-teleport-whole-line)

      ;; Mark text
      (defun avy-action-mark-to-char (pt)
        (activate-mark)
        (goto-char pt))

      (setf (alist-get ?  avy-dispatch-alist) 'avy-action-mark-to-char)

      ;; Avy + Isearch
      (define-key isearch-mode-map (kbd "M-j") 'avy-isearch)

      ;; Isearch in other windows
      (defun isearch-forward-other-window (prefix)
        "Function to isearch-forward in other-window."
        (interactive "P")
        (unless (one-window-p)
          (save-excursion
            (let ((next (if prefix -1 1)))
              (other-window next)
              (isearch-forward)
              (other-window (- next))))))

      (defun isearch-backward-other-window (prefix)
        "Function to isearch-backward in other-window."
        (interactive "P")
        (unless (one-window-p)
          (save-excursion
            (let ((next (if prefix 1 -1)))
              (other-window next)
              (isearch-backward)
              (other-window (- next))))))

      (setq avy-all-windows t))

    ;; (setup (:straight avy-zap)
    ;;   ;; : my-laptop-p
    ;;   (setq avy-zap-forward-only t)
    ;;   ;; (setq avy-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s))
    ;;   :global
    ;;   (("M-z" . avy-zap-up-to-char-dwim)
    ;;    ("M-Z" . avy-zap-to-char-dwim)))

#+end_src
*** Spelling
:PROPERTIES:
:ID:                     646035cd-ccc8-4a21-b116-f5d2269dbad9
:END:
The configuration below enables Flyspell for all text modes and sets Hunspell as the default checking program. The M-F7 key checks the spelling for all words in the buffer and F7 checks the word that you cursor is standing on.

A more productive method is to use the C-; function. This function provides the most likely correction of the first spelling error before the cursor is. Emacs will show the list of possible corrections in the mini buffer. Repeatedly pressing C-; will cycle through the options until you get back to the original. This function prevents you from having to jump to your spelling mistakes.
#+begin_src emacs-lisp
    (setup flyspell
      (:needs (or "hunspell"
                  "aspell"))
      (:load-after avy
        (:hook-into org-mode-hook git-commit-mode-hook markdown-mode-hook)
        (:bind "M-<f7>"  flyspell-buffer
               "<f7>"    flyspell-word
               "C-;"     flyspell-auto-correct-previous-word
               )
        (progn
          (cond
           ((executable-find "aspell")
            (setq ispell-program-name "aspell")
            (setq ispell-extra-args   '("--sug-mode=ultra"
                                        "--lang=en_AU")))
           ((executable-find "hunspell")
            (setq ispell-program-name "hunspell")
            (setq ispell-extra-args   '("-d en_AU"))))

          ;; Save a new word to personal dictionary without asking
          (setq ispell-silently-savep t)
          (setq ispell-default-dictionary "en_AU"))

        (defun avy-action-flyspell (pt)
          (save-excursion
            (goto-char pt)
            (when (require 'flyspell nil t)
              (flyspell-auto-correct-word)))
          (select-window
           (cdr (ring-ref avy-ring 0)))
          t)

        ;; Bind to semicolon (flyspell uses C-;)
        (setf (alist-get ?\; avy-dispatch-alist) 'avy-action-flyspell)

        (:when-loaded
          (:hide-mode))))
#+end_src

I use the dictionary package for Emacs, and I‚Äôm lazy about it:
#+begin_src emacs-lisp
  (setup (:straight dictionary)
    (:load-after avy
      (defun dictionary-search-dwim (&optional arg)
        "Search for definition of word at point. If region is active,
    search for contents of region instead. If called with a prefix
    argument, query for word to search."
        (interactive "P")
        (if arg
            (dictionary-search nil)
          (if (use-region-p)
              (dictionary-search (buffer-substring-no-properties
                                  (region-beginning)
                                  (region-end)))
            (if (thing-at-point 'word)
                (dictionary-lookup-definition)
              (dictionary-search-dwim '(4))))))

      ;; dictionary
      (defun avy-action-define (pt)
        (save-excursion
          (goto-char pt)
          (dictionary-search-dwim))
        (select-window
         (cdr (ring-ref avy-ring 0)))
        t)

      (setf (alist-get ?= avy-dispatch-alist) 'dictionary-search-dwim))
    (:option dictionary-use-single-buffer t)
    (autoload 'dictionary-search "dictionary"
      "Ask for a word and search it in all dictionaries" t)
    (:hook #'reading-mode))

#+end_src

*** Encodings & expand region
:PROPERTIES:
:ID:                     7c67910a-5992-4b18-a845-c454b93186c3
:END:
Setup encodings
#+begin_src emacs-lisp :noweb-ref sanity

  (setup encoding
  (setq coding-system-for-read 'utf-8-unix)
  (setq coding-system-for-write 'utf-8-unix)
  (setq default-process-coding-system '(utf-8-unix utf-8-unix))
  (setq locale-coding-system 'utf-8-unix)
  (setq selection-coding-system 'utf-8)
  (setq x-select-request-type nil)
  (setq-default buffer-file-coding-system 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
  (set-clipboard-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8-unix)
  (set-keyboard-coding-system 'utf-8-unix)
  (set-language-environment "UTF-8")
  (set-selection-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8-unix))

#+end_src
Setup undo , whitespace, expand, indentation
#+begin_src emacs-lisp
  ;; (setup (:straight aggressive-indent)
  ;;   (:hook-into prog-mode)
  ;;   (:hide-mode))

  ;; (setup (:straight hungry-delete)
  ;;   (:load-after smartparens
  ;;     (setq hungry-delete-join-reluctantly t)
  ;;     (global-hungry-delete-mode 1)
  ;;     (:hook-into smartparens-enabled)
  ;;     (:hide-mode)))

   (setup (:straight expand-region)
    (:require expand-region))

  ;; (setup (:straight undo-fu undo-fu-session)
  ;;   (:with-map (prog-mode-map text-mode-map)
  ;;     (:bind
  ;;      "u" undo-fu-only-undo
  ;;      "C-r" undo-fu-only-redo))
  ;;   (setq undo-fu-session-incompatible-files
  ;;         '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'"))
  ;;   (global-undo-fu-session-mode 1))



#+end_src

** Buffers in Emacs
:PROPERTIES:
:header-args: :noweb-ref buffers
:ID:                     e82ac276-b2db-434f-83aa-da6df0f3b90e
:END:
Setup the buffers to my liking
#+begin_src emacs-lisp
  (defvar buffer-fallback-name "*scratch*"
    "The name of the buffer to fall back to.
    Used when no other buffers exist.")

  (defun buffer-fallback ()
    "Return the fallback buffer, creating it if necessary.
    By default this is the scratch buffer. See
    `buffer-fallback-name' to change this."
    (get-buffer-create buffer-fallback-name))

  

  (defun buffer-display-and-switch (buffer-or-name)
    "Display BUFFER-OR-NAME in some window and switch to it."
    (select-window (display-buffer buffer-or-name)))

  

  (defvar buffer-messages-display-fn #'buffer-display-and-switch
    "The function to use to display messages buffer.
    Must accept one argument: the buffer to display.")

  (defvar buffer-messages-name "*Messages*"
    "The name of the messages buffer.")

  (defun buffer-pop-messages ()
    "Open `buffer-messages-name' buffer."
    (interactive)
    (funcall buffer-messages-display-fn
             (get-buffer-create buffer-messages-name)))

  (defun buffer-switch-to-messages ()
    "Open `buffer-messages-name' buffer."
    (interactive)
    (let ((buffer-messages-display-fn #'switch-to-buffer))
      (buffer-pop-messages)))

  

  (defvar buffer-scratch-files-dir (concat emacs-etc/ "scratch/")
    "Where to store project scratch files.
    Files are created by `buffer-open-project-scratch'.")

  (defvar buffer-scratch-display-fn #'buffer-display-and-switch
    "The function to use to display the scratch buffer.
    Must accept one argument: the buffer to display.")

  (defvar buffer-scratch-major-mode nil
    "What major mode to use in scratch buffers.
    This can be one of the following:
      t          Inherits the major mode of the last buffer you had
                 selected.
      nil        Uses `fundamental-mode'
      MAJOR-MODE  Any major mode symbol")

  (defvar buffer-scratch-hook ()
    "The hooks to run after a scratch buffer is made.")

  (defun buffer-scratch (&optional file mode text)
    "Return a scratch buffer in major MODE with TEXT in it.
    If FILE is a valid path, open it as if it were a persistent
    scratch."
    (if file (setq file (file-truename file)))
    (let ((buffer
           (if file
               (with-current-buffer (find-file-noselect file)
                 (rename-buffer (format "*scratch (%s)*"
                                        (file-name-nondirectory file)))
                 (current-buffer))
             (get-buffer-create "*scratch*"))))
      (with-current-buffer buffer
        (when (and (functionp mode)
                   (not (eq major-mode mode)))
          (funcall mode))
        (when text
          (insert text))
        (run-hooks 'buffer-scratch-hook)
        (current-buffer))))

  (defun buffer-pop-scratch (&optional arg)
    "Opens a scratch pad window in the same `major-mode'.
    If ARG (universal argument), then open a persistent scratch
    buffer. You'll be prompted for its name, or to open a previously
    created. These are stored in `buffer-scratch-files-dir'.
    If a region is active, copy its contents to the scratch."
    (interactive "P")
    (funcall
     buffer-scratch-display-fn
     (buffer-scratch
      (when arg
        (if-let* ((file (read-file-name
                         "Ouvrir le fichier de scratch > "
                         buffer-scratch-files-dir
                         "scratch")))
            file
          (user-error "Abandon..")))
      (cond ((eq buffer-scratch-major-mode t)
             (unless (or buffer-read-only
                         (derived-mode-p 'special-mode)
                         (string-match-p "^ ?\\*" (buffer-name)))
               major-mode))
            ((null buffer-scratch-major-mode) nil)
            ((symbolp buffer-scratch-major-mode)
             buffer-scratch-major-mode))
      (and (region-active-p)
           (buffer-substring-no-properties
            (region-beginning) (region-end))))))

  (defun buffer-switch-to-scratch (&optional arg)
    "Switch to a scratch buffer in the current window.
    Otherwise, does exactly what `buffer-pop-scratch' does.
    ARG is passed to `buffer-pop-scratch'."
    (interactive "P")
    (let ((buffer-scratch-display-fn #'switch-to-buffer))
      (buffer-pop-scratch arg)))

  (defun buffer-delete-scratch-files ()
    "Deletes all scratch buffers in `buffer-scratch-files-dir'."
    (interactive)
    (dolist (file (directory-files buffer-scratch-files-dir
                                   t "[^.]" t))
      (delete-file file)
      (message "Supprim√© '%s'" (file-name-nondirectory file))))

  

  (defun buffer-sudo-edit (&optional arg)
    "Edit currently visited file as root.
    With a prefix ARG prompt for a file to visit. Will also prompt
    for a file to visit if current buffer is not visiting a file."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (read-file-name "Rechercher le fichier (en tant que root): ")))
      (find-alternate-file
       (concat "/sudo:root@localhost:"
               buffer-file-name))))

  

  (defhydra hydra-buffer-menu (:color pink
                                      :hint nil)
    "
  ^Mark^             ^Unmark^           ^Actions^          ^Search
  ^^^^^^^^-----------------------------------------------------------------
  _m_: mark          _u_: unmark        _x_: execute       _R_: re-isearch
  _s_: save          _U_: unmark up     _b_: bury          _I_: isearch
  _d_: delete        ^ ^                _g_: refresh       _O_: multi-occur
  _D_: delete up     ^ ^                _T_: files only: % -28`Buffer-menu-files-only
  _~_: modified
  "
    ("m" Buffer-menu-mark)
    ("u" Buffer-menu-unmark)
    ("U" Buffer-menu-backup-unmark)
    ("d" Buffer-menu-delete)
    ("D" Buffer-menu-delete-backwards)
    ("s" Buffer-menu-save)
    ("~" Buffer-menu-not-modified)
    ("x" Buffer-menu-execute)
    ("b" Buffer-menu-bury)
    ("g" revert-buffer)
    ("T" Buffer-menu-toggle-files-only)
    ("O" Buffer-menu-multi-occur :color blue)
    ("I" Buffer-menu-isearch-buffers :color blue)
    ("R" Buffer-menu-isearch-buffers-regexp :color blue)
    ("c" nil "cancel")
    ("v" Buffer-menu-select "select" :color blue)
    ("o" Buffer-menu-other-window "other-window" :color blue)
    ("q" quit-window "quit" :color blue))

  (define-key Buffer-menu-mode-map "." 'hydra-buffer-menu/body)

#+end_src

#+begin_src emacs-lisp
  (setup scratch
   ;; (setq initial-major-mode #'emacs-lisp-mode)
    (setq initial-scratch-message
          ";; ABANDONNEZ TOUT ESPOIR VOUS QUI ENTREZ ICI\n\n" )
  ;;   (defun +scratch-immortal ()
  ;;     "Bury, don't kill \"*scratc*\" buffer.
  ;;       For `kill-buffer-query-functions'."
  ;;     (if (eq (current-buffer) (get-buffer "*scratch*"))
  ;;         (progn (bury-buffer)
  ;;                nil)
  ;;       t))
  ;;   (defun +scratch-buffer-setup ()
  ;;     "Add comment to `scratch' buffer and name it accordingly."
  ;;     (let* ((mode (format "%s" major-mode))
  ;;            (string (concat "Scratch buffer for:" mode "\n\n")))
  ;;       (when scratch-buffer
  ;;         (save-excursion
  ;;           (insert string)
  ;;           (goto-char (point-min))
  ;;           (comment-region (point-at-bol) (point-at-eol)))
  ;;         (next-line 2))
  ;;       (rename-buffer (concat "*scratch<" mode ">*") t)))
  ;;   (add-hook 'kill-buffer-query-functions #'+scratch-immortal)
     )

   (setup minibuffer
     (file-name-shadow-mode 1)
     (minibuffer-depth-indicate-mode 1)
    (minibuffer-electric-default-mode 1)
    (fset #'yes-or-no-p #'y-or-n-p)
    (setq enable-recursive-minibuffers t)
    (setq file-name-shadow-properties '(invisible t intangible t))
    (setq minibuffer-eldef-shorten-default t)
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (setq read-answer-short t)
    (setq read-extended-command-predicate #'command-completion-default-include-p)
    (setq use-short-answers t)
    ;; https://www.manueluberti.eu//emacs/2021/12/10/shell-command/
    (defun +minibuffer-complete-history ()
      "Complete minibuffer history."
      (interactive)
      (completion-in-region (minibuffer--completion-prompt-end) (point-max)
                            (symbol-value minibuffer-history-variable)
                            nil))
    (:with-hook minibuffer-setup-hook
      (:hook cursor-intangible-mode))
    (:with-map minibuffer-local-map
      (:bind "M-/" #'+minibuffer-complete-history))
    (:with-map minibuffer-inactive-mode-map
      (:bind "<mouse-1>" ignore)))

  (setup ibuffer
    (:also-load ibuf-ext)
    (:option ibuffer-expert t
             ibuffer-show-empty-filter-groups nil
             ibuffer-saved-filter-groups
             '(("default"
                ("Org" (mode . org-mode))
                ("emacs" (or (name . "^\\*scratch\\*$")
                             (name . "^\\*Messages\\*$")
                             (name . "^\\*Warnings\\*$")
                             (name . "^\\*straight-process\\*$")
                             (name . "^\\*Calendar\\*$")))
                ("customize" (mode . Custom-mode))
                ("emacs-config" (or (filename . ".emacs.d")
                                    (mode . +init-mode)))
                ("git" (or (name . "^\*magit")
                           (name . "^\magit")))
                ("help" (or (mode . help-mode)
                            (mode . Info-mode)
                            (mode . helpful-mode)))
                ("irc" (or (mode . erc-mode)
                           (mode . circe-server-mode)
                           (mode . circe-channel-mode)))
                ("shell" (or (mode . eshell-mode)
                             (mode . shell-mode)
                             (mode . vterm-mode)))
                ("web" (or (mode . elpher-mode)
                           (mode . eww-mode))))))
    (:hook (defun ibuffer@filter-to-default ()
             (ibuffer-auto-mode +1)
             (ibuffer-switch-to-saved-filter-groups "default"))))

  ;; (setup (:straight shackle)
  ;;   (setq shackle-rules
  ;;         `((compilation-mode
  ;;            :select t :align right :size 0.33)
  ;;           (magit-status-mode
  ;;            :select t :align right :size 0.5)
  ;;           ((help-mode helpful-mode)
  ;;            :select t :align right :size 0.4)
  ;;           ((sly-xref-mode "\\*\\(sly-mrepl\\|ielm\\)")
  ;;            :regexp t :noselect t :align below :size 0.24)))
  ;;   (shackle-mode 1))
#+end_src

** Sanity settings
:PROPERTIES:
:header-args: :noweb-ref sanity
:ID:                     aa34e0d9-5c92-4a74-b187-ac2be9dcb824
:END:
Setup Scatch and minibuffer
#+begin_src emacs-lisp

  (setup files
    (setq auto-mode-case-fold nil)
    (setq auto-save-default nil)
    (setq auto-save-list-file-prefix nil)
    (setq backup-inhibited t)
    (setq create-lockfiles nil)
    (setq delete-by-moving-to-trash nil)
    (setq find-file-suppress-same-file-warnings t)
    (setq find-file-visit-truename t)
    (setq load-prefer-newer t)
    (setq make-backup-files nil)
    (setq require-final-newline t)
    (setq vc-follow-symlinks t))


  (setup selection
    (setq kill-do-not-save-duplicates t)
    (setq select-enable-clipboard t)
    (setq select-enable-primary t)
    (setq x-select-enable-clipboard-manager nil))


  #+end_src

  The default way Emacs makes buffer names unique is really ugly and,
  dare I say it, stupid.  Instead, I want them to be uniquified by their
  filesystem paths.

#+begin_src emacs-lisp
  (setup (:require uniquify)
    (setq uniquify-after-kill-buffer-p t)
    (setq uniquify-buffer-name-style 'forward)
    (setq-default
     uniquify-separator "/"
     uniquify-ignore-buffers-re "^\\*"))

#+end_src

** Project Setup
:PROPERTIES:
:header-args: :noweb-ref projet
:ID:                     2a1cf21e-d71d-4d0b-a538-74b7989c18b0
:END:

setup of emacs project
#+begin_src emacs-lisp
(setq project-list-file (expand-file-name "projects" emacs-etc/))

(defalias 'project-switch #'project-switch-project)

(defun project-p ()
  "Return non-nil when located in a project."
  (project-current))

;; Emacs 27
(unless (fboundp 'project-root)
  (cl-defmethod project-root ((project (head transient)))
    (cdr project)))

(defun project-shell-command ()
  "Invoke `shell-command' in the project's root."
  (interactive)
  (if-let* ((project (project-current))
            (root (project-root project)))
      (eval-with-default-dir root
        (call-interactively #'shell-command))
    (user-error "You are not in project")))

(defun project-magit ()
  "Start `magit-status' in the current project's root directory."
  (interactive)
  (magit-status-setup-buffer (project-root (project-current t))))

(setq project-switch-commands
      '((?f "Find file" project-find-file)
        (?g "Find regexp" project-find-regexp)
        (?d "Dired" project-dired)
        (?v "Magit" project-magit)
        (?e "Eshell" project-eshell)))

(use-package rg
  :defer t
  :commands (rg-project)
  :init
  (defalias 'project-find-regexp #'rg-project))
#+end_src
** VCS
:PROPERTIES:
:header-args: :noweb-ref vcs
:ID:                     6862765e-98fc-4855-b14b-1c9300cc9885
:END:
Setup of magit for cool git
#+begin_src emacs-lisp
    (setq-default vc-follow-symlinks t)

    ;; (remove-hook 'find-file-hook #'vc-refrqesh-state)
    ;; (hook-with-delay 'find-file-hook 1 #'vc-refresh-state)

    (use-package magit
      :defer t
      :defines (magit-status-mode-map
                magit-revision-show-gravatars
                magit-display-buffer-function
                magit-diff-refine-hunk)
      :commands (magit-display-buffer-same-window-except-diff-v1
                 magit-stage-file
                 magit-unstage-file)
      :init
      (setq-default magit-git-executable (executable-find "git"))
      :config
      ;; properly kill leftover magit buffers on quit
      (define-key magit-status-mode-map
        [remap magit-mode-bury-buffer]
        #'vcs-quit)

      (setq magit-revision-show-gravatars
            '("^Author:     " . "^Commit:     ")
            magit-display-buffer-function
            #'magit-display-buffer-same-window-except-diff-v1
            ;; show word-granularity on selected hunk
            magit-diff-refine-hunk t))

    (use-package forge
      :commands forge-create-pullreq forge-create-issue
      :init
      (setq-default forge-database-file
                    (expand-file-name "forge/forge-database.sqlite"
                                      emacs-etc/)))

      (setup (:straight git-timemachine)
          (:bind
           "[" git-timemachine-show-previous-revision
           "]" git-timemachine-show-next-revision
           "b" git-timemachine-blame))

  (use-package ediff-wind
    :straight nil
    :defer t
    :init
    (setq ediff-window-setup-function 'ediff-setup-windows-plain
          ediff-split-window-function 'split-window-horizontally))

  (use-package diff-hl
    :defer t
    :hook ((prog-mode . turn-on-diff-hl-mode)
           (text-mode . turn-on-diff-hl-mode)
           (vc-dir-mode . turn-on-diff-hl-mode)
           (dired-mode . diff-hl-dired-mode)))

  (defun vcs-quit (&optional _kill-buffer)
    "Clean up magit buffers after quitting `magit-status'.
  And don't forget to refresh version control in all buffers of
  current workspace."
    (interactive)
    (quit-window)
    (unless (cdr
             (delq nil
                   (mapcar (lambda (win)
                             (with-selected-window win
                               (eq major-mode 'magit-status-mode)))
                           (window-list))))
      (when (fboundp 'magit-mode-get-buffers)
        (mapc #'vcs--kill-buffer (magit-mode-get-buffers)))))

  (defun vcs--kill-buffer (buffer)
    "Gracefully kill `magit' BUFFER.
  If any alive process is related to this BUFFER, wait for 5
  seconds before nuking BUFFER and the process. If it's dead -
  don't wait at all."
    (when (and (bufferp buffer) (buffer-live-p buffer))
      (let ((process (get-buffer-process buffer)))
        (if (not (processp process))
            (kill-buffer buffer)
          (with-current-buffer buffer
            (if (process-live-p process)
                (run-with-timer 5 nil #'vcs--kill-buffer buffer)
              (kill-process process)
              (kill-buffer buffer)))))))

      ;; (setup (:straight magit)
      ;;   (setq git-commit-summary-max-length 120)
      ;;   (setq magit-commit-show-diff nil)
      ;;   (setq magit-delete-by-moving-to-trash nil)
      ;;   (setq magit-display-buffer-function
      ;;         #'magit-display-buffer-same-window-except-diff-v1)
      ;;   (setq magit-log-auto-more t)
      ;;   (setq magit-log-margin-show-committer-date t)
      ;;   (setq magit-revert-buffers 'silent)
      ;;   (setq magit-save-repository-buffers 'dontask)
      ;;   (setq magit-wip-after-apply-mode t)
      ;;   (setq magit-wip-after-save-mode t)
      ;;   (setq magit-wip-before-change-mode t)
      ;;   (setq transient-values
      ;;         '((magit-log:magit-log-mode "--graph" "--color" "--decorate"))))

      (setup magit-wip
        (:load-after magit
          (magit-wip-mode 1)
          (:hide-mode)))

      (setup (:straight magit-todos)
        (:load-after magit
          (magit-todos-mode 1)))
#+end_src
** Emacs *Help* functions
:PROPERTIES:
:ID:                     c0c72f61-3244-412e-9deb-8d9abee533b4
:END:

 Help and which functions

#+begin_src emacs-lisp :noweb-ref pkg-ui

  (setup (:straight helpful)
    (:when-loaded
      (:global-bind
       "C-h f" helpful-callable
       "C-h v" helpful-variable
       "C-h k" helpful-key)
      (defun avy-action-helpful (pt)
        (save-excursion
          (goto-char pt)
          (helpful-at-point))
        (select-window
         (cdr (ring-ref avy-ring 0)))
        t)
      ;; set H as avy dispatch to Help
      (setf (alist-get ?H avy-dispatch-alist) 'avy-action-helpful)

      (:load-after link-hint
        (:bind
         "o" link-hint-open-link-at-point)
        (setq helpful-switch-buffer-function
              (lambda (x)
                (if (eq major-mode 'helpful-mode)
                    (switch-to-buffer x)
                  (pop-to-buffer x)))))))

#+end_src

** Navigation
:PROPERTIES:
:ID:                     73011391-29f2-4810-b02e-b4b9775c1554
:END:
setup Marginalia for navigation
#+begin_src emacs-lisp
  ;; Enable richer annotations using the Marginalia package
  (setup (:straight marginalia)
    (:load-after vertico
		 (marginalia-mode 1))
    (:with-map minibuffer-local-map
      (:bind "M-A" marginalia-cycle)))

#+end_src

*** Completion
:PROPERTIES:
:ID:                     4cac10bb-2e1d-4ca3-8a9b-11ef8ca3611f
:END:
Emacs completion parlava
#+begin_src emacs-lisp :noweb-ref pkg-completion
  (setup (:straight corfu)
    (:with-map corfu-map
      (:bind
       "TAB"  corfu-next
       [tab]  corfu-next
       "S-TAB"  corfu-previous
       [backtab]  corfu-previous
       [remap completion-at-point]  corfu-complete
       "RET"  corfu-complete-and-quit))
    ;; Recommended: Enable Corfu globally.
    ;; This is recommended since dabbrev can be used globally (M-/).
    (corfu-global-mode)
    ;; Optionally enable cycling for `corfu-next' and `corfu-previous'.
    (setq corfu-cycle t)
    (defun corfu-move-to-minibuffer ()
      (interactive)
      (let (completion-cycle-threshold completion-cycling)
        (apply #'consult-completion-in-region completion-in-region--data)))
    (define-key corfu-map "\M-m" #'corfu-move-to-minibuffer)
    (setq corfu-preselect-first t)
    (setq corfu-scroll-margin 4)
    (setq corfu-quit-no-match t)
    (setq corfu-quit-at-boundary t)
    (setq corfu-max-width 100)
    (setq corfu-min-width 42)
    (setq corfu-count 9)
    ;; should be configured in the `indent' package, but `indent.el'
    ;; doesn't provide the `indent' feature.
    (setq tab-always-indent 'complete)
    (defun corfu-complete-and-quit ()
      (interactive)
      (corfu-complete)
      (corfu-quit)))

  ;; Dabbrev works with Corfu
  (setup (:straight dabbrev)
    ;; Swap M-/ and C-M-/
    (:global "M-/"    dabbrev-completion
             "C-M-/"  dabbrev-expand))

  (setup (:straight ripgrep)
    (:needs "rg")
    (setq ripgrep-arguments "--ignore-case"))

  (setup (:straight consult)
    (:global ;; C-c bindings (mode-specific-map)
     "C-c h" consult-history
     ;; "C-c m"  consult-mode-command
     "C-c b" consult-bookmark
     "C-c k" consult-kmacro
     "C-c f" jnf/consult-ripgrep
     ;; C-x bindings (ctl-x-map)
     "C-x M-:" consult-complex-command     ;; orig. repeat-complet-command
     "C-x b" consult-buffer                ;; orig. switch-to-buffer
     "s-b" consult-buffer                ;; orig. switch-to-buffer
     "C-x 4 b" consult-buffer-other-window ;; orig. switch-to-buffer-other-window
     "C-s-b" consult-buffer-other-window
     "C-x 5 b" consult-buffer-other-frame  ;; orig. switch-to-buffer-other-frame
     ;; Custom M-# bindings for fast register access
     "M-#" consult-register-load
     "M-'" consult-register-store          ;; orig. abbrev-prefix-mark (unrelated)
     "C-M-#" consult-register
     ;; Other custom bindings
     "M-y" consult-yank-from-kill-ring                ;; orig. yank-pop
     "<help> a" consult-apropos            ;; orig. apropos-command
     ;; M-g bindings (goto-map)
     "M-g e" consult-compile-error
     "M-g g" consult-goto-line             ;; orig. goto-line
     "M-g M-g" consult-goto-line           ;; orig. goto-line
     "s-l" consult-goto-line           ;; orig. goto-line
     "M-g o" consult-outline
     "M-g m" consult-mark
     "M-g k" consult-global-mark
     "C-x C-SPC" consult-mark
     "M-g i" consult-imenu
     "M-g I" consult-imenu-multi
     ;; M-s bindings (search-map)
     "M-s f" consult-find
     "M-s L" consult-locate
     "M-s g" consult-grep
     "M-s G" consult-git-grep
     "M-s r" consult-ripgrep
     "C-c f" consult-ripgrep
     "M-s l" consult-line
     "M-s m" consult-multi-occur
     "M-s k" consult-keep-lines
     "M-s u" consult-focus-lines
     ;; Customisations that map to ivy
     "s-r" consult-recent-file ;; Deprecate
     "C-c r" consult-recent-file
     "C-c o" consult-file-externally
     "C-y" yank
     "C-s" consult-line ;; I've long favored Swiper mapped to c-s
     ;; Isearch integration
     "M-s e" consult-isearch )
     ;; "s-t" jnf/consult-find-using-fd
     ;; "s-3" consult-imenu-multi
     (:with-map isearch-mode-map
       (:bind "M-e" consult-isearch                 ;; orig. isearch-edit-string
              "M-s e" consult-isearch               ;; orig. isearch-edit-string
              "M-s l" consult-line))                 ;; required by consult-line to detect isearch
     (setq consult-async-min-input 2)
     (setq consult-preview-key (kbd "M-."))
     (setq xref-show-definitions-function #'consult-xref)
     (setq xref-show-xrefs-function #'consult-xref)
     ;; Updating the default to include "--ignore-case"
     (setq consult-ripgrep-command "rg --null --line-buffered --color=ansi --max-columns=1000 --ignore-case --no-heading --line-number . -e ARG OPTS")

     ;; From https://github.com/minad/consult/wiki#find-files-using-fd
     ;; Note: this requires lexical binding
     (defun jnf/consult-find-using-fd (&optional dir initial)
       "Find project files.
  A replacement for `projectile-find-file'."
       (interactive "P")
       (let ((consult-find-command "fd --color=never --hidden --exclude .git/ --full-path ARG OPTS"))
         (consult-find dir initial)))

     (defun jnf/consult-line (consult-line-function &rest rest)
       "Advising function around `CONSULT-LINE-FUNCTION'.
  When there's an active region, use that as the first parameter
  for `CONSULT-LINE-FUNCTION'.  Otherwise, use the current word as
  the first parameter.  This function handles the `REST' of the
  parameters."
       (interactive)
       (apply consult-line-function
              (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
              rest))

     (defun jnf/consult-ripgrep (consult-ripgrep-function &optional dir &rest rest)
       "Use region or thing at point to populate initial parameter for `CONSULT-RIPGREP-FUNCTION'.
  When there's an active region, use that as the initial parameter
  for the `CONSULT-RIPGREP-FUNCTION'.  Otherwise, use the thing at
  point.
  `DIR' use the universal argument (e.g. C-u prefix) to first set
  the directory.  `REST' is passed to the `CONSULT-RIPGREP-FUNCTION'."
       (interactive "P")
       (apply consult-ripgrep-function
              dir
              (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
              rest))

     ;; Optionally tweak the register preview window.
     ;; This adds thin lines, sorting and hides the mode line of the window.
     (advice-add #'register-preview :override #'consult-register-window)
     (advice-add #'consult-line :around #'jnf/consult-line '((name . "wrapper")))
     (advice-add #'consult-ripgrep :around #'jnf/consult-ripgrep '((name . "wrapper")))

     (:load-after projectile
       (setq consult-project-root-function #'projectile-project-root)))
     ;;   (:load-after vertico
     ;;     (setq completion-in-region-function
     ;;           (lambda (&rest args)
     ;;             (apply (if vertico-mode
     ;;                        #'consult-completion-in-region
     ;;                      #'completion--in-region)
     ;;                    args))))
     ;;)

    (setup (:straight embark)
      (:load-after (which-key avy)
        (defun embark-which-key-indicator ()
          (lambda (&optional keymap targets prefix)
            (if (null keymap)
                (which-key--hide-popup-ignore-command)
              (which-key--show-keymap
               (if (eq (plist-get (car targets) :type) 'embark-become)
                   "Become"
                 (format "Agir sur %s '%s'%s"
                         (plist-get (car targets) :type)
                         (embark--truncate-target (plist-get (car targets) :target))
                         (if (cdr targets) "‚Ä¶" "")))
               (if prefix
                   (pcase (lookup-key keymap prefix 'accept-default)
                     ((and (pred keymapp) km) km)
                     (_ (key-binding prefix 'accept-default)))
                 keymap)
               nil nil t (lambda (binding)
                           (not (string-suffix-p "-argument" (cdr binding))))))))
        (setq prefix-help-command #'embark-prefix-help-command)
        (setq embark-indicators '(embark-which-key-indicator embark-highlight-indicator embark-isearch-highlight-indicator))
        (defun avy-action-embark (pt)
          (unwind-protect
              (save-excursion
                (goto-char pt)
                (embark-act))
            (select-window
             (cdr (ring-ref avy-ring 0))))
          t)

        (setf (alist-get ?.   avy-dispatch-alist) 'avy-action-embark)

        (:advise embark-completing-read-prompter :around (fn &rest args)
          (when-let ((win (get-buffer-window which-key--buffer 'visible)))
            (quit-window 'kill-buffer win)
            (let ((embark-indicators (delq #'embark-which-key-indicator
                                           embark-indicators)))
              (apply fn args))))
        (:global "C-," embark-act)))

    (setup (:straight embark-consult)
      (:load-after (embark consult)
        (:with-mode embark-collect-mode
          (:hook consult-preview-at-point-mode))))

    (setup (:straight orderless)
      (setq completion-category-defaults nil)
      (setq completion-category-overrides '((file (styles partial-completion))))
      (setq completion-styles '(orderless)))

    (setup (:straight (vertico :files (:defaults "extensions/*")))
      (:also-load vertico-repeat)
      (:global "M-r" #'vertico-repeat)
      ;; Different scroll margin
      ;; (setq vertico-scroll-margin 0)

      ;; Show more candidates
      ;; (setq vertico-count 20)

      ;; Grow and shrink the Vertico minibuffer
      ;; (setq vertico-resize t)

      ;; Use `consult-completion-in-region' if Vertico is enabled.
      ;; Otherwise use the default `completion--in-region' function.
      (setq completion-in-region-function
            (lambda (&rest args)
              (apply (if vertico-mode
                         #'consult-completion-in-region
                       #'completion--in-region)
                     args)))
      (advice-add #'completing-read-multiple
                  :override #'consult-completing-read-multiple)
      (:with-hook minibuffer-setup-hook
        (:hook vertico-repeat-save))
      ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
      (setq vertico-cycle t))

    ;; A few more useful configurations...
    (setup emacs
      ;; TAB cycle if there are only few candidates
      (setq completion-cycle-threshold 3)

      ;; Enable indentation+completion using the TAB key.
      ;; `completion-at-point' is often bound to M-TAB.
      (setq tab-always-indent 'complete)

      ;; Add prompt indicator to `completing-read-multiple'.
      ;; Alternatively try `consult-completing-read-multiple'.
      (defun crm-indicator (args)
        (cons (concat "[CRM] " (car args)) (cdr args)))
      (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

      ;; Do not allow the cursor in the minibuffer prompt
      (setq minibuffer-prompt-properties
            '(read-only t cursor-intangible t face minibuffer-prompt))
      (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

      ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
      ;; Vertico commands are hidden in normal buffers.
      ;; (setq read-extended-command-predicate
      ;;       #'command-completion-default-include-p)

      ;; recursive minibuffers
      (setq enable-recursive-minibuffers nil))

    (setup (:straight cape)
      (defun enable-cape ()
        (add-hook 'completion-at-point-functions #'cape-dabbrev 90 t)
        (add-hook 'completion-at-point-functions #'cape-file 90 t))
      (:with-mode (prog-mode cider-mode) #'enable-cape))
#+end_src

** Note Taking
:PROPERTIES:
:header-args: :noweb-ref pkg-org
:ID:                     b4494a7b-c67e-401c-b130-7592fb7d7a7c
:END:
*** Vulpea
:PROPERTIES:
:ID:                     b8538a46-829b-43a2-af58-3123de1cf852
:END:
Setup d12frosted's vulpea

#+begin_src emacs-lisp
  (setup (:straight org-cliplink))

  (use-package vulpea
    :straight (vulpea
               :type git
               :host github
               :repo "d12frosted/vulpea")
    :defer t
    :general
    (leader-def
      "n" '(nil :which-key "vulpea...")
      "nd" '(nil :which-key "by date...")
      "ndd" '(vulpea-dailies-date :which-key "arbitrary date")
      "ndt" '(vulpea-dailies-today :which-key "today")
      "ndn" '(vulpea-dailies-next :which-key "next")
      "ndp" '(vulpea-dailies-prev :which-key "previous")
      "nf" '(vulpea-find :which-key "find")
      "nF" '(vulpea-find-backlink :which-key "find backlink")
      "ni" '(vulpea-insert :which-key "insert")
      "nt" '(vulpea-tags-add :which-key "tag")
      "nT" '(vulpea-tags-delete :which-key "untag")
      "na" '(vulpea-alias-add :which-key "alias")
      "nA" '(vulpea-alias-delete :which-key "unalias")
      "ol" '(litnotes :which-key "litnotes"))
    :hook ((before-save . vulpea-pre-save-hook)
           (org-roam-db-autosync-mode . vulpea-db-autosync-enable))
    :init
    (add-to-list 'window-buffer-change-functions
                 #'vulpea-setup-buffer)
    (add-hook 'vulpea-insert-handle-functions
              #'vulpea-insert-handle)
    (setq-default
     vulpea-find-default-filter
     (lambda (note)
       (= (vulpea-note-level note) 0))
     vulpea-insert-default-filter
     (lambda (note)
       (= (vulpea-note-level note) 0))))

  (use-package org
    :hook ((org-mode . visual-line-mode)
           (org-mode . adaptive-wrap-prefix-mode)
           ;; oh, how much I hate it in Org mode buffers
           (org-mode . editor-disable-electric-indent))
    :commands (org-check-agenda-file
               org-link-set-parameters)
    :init
    ;; This is where my ~heart~ org files are.
    (setq org-directory
          (if ENV-IS-TERMUX?
              "~/storage/shared/org"
            vulpea-directory))

    (defun /org-path (path)
      (expand-file-name path org-directory))

    ;;(setq org-default-notes-file (/org-path "inbox.org"))
    ;; Setup list of Org modules that should always be loaded together
    ;; with Org.
    (setq org-modules '(org-id org-attach))

    ;; pretty org files
    (setq
     org-adapt-indentation nil
     org-hidden-keywords nil
     org-hide-emphasis-markers nil
     org-hide-leading-stars nil
     org-image-actual-width '(512)
     org-imenu-depth 1
     org-pretty-entities nil
     org-startup-folded t)

    ;; do not allow invisible edits (...)
    (setq org-catch-invisible-edits 'error)

    ;; formatting for properties
    (setq org-property-format "%-24s %s")

    ;; setup todo keywords
    (setq
     org-todo-keywords
     '((sequence "TODO(t)" "|" "FINI(d!)")
       (sequence "ATTENDRE(w@/!)"
                 "ENATTENTE(h@/!)"
                 "|"
                 "ANNUL√â(c@/!)"
                 "R√âUNION"))

     ;; use fast todo selection
     org-use-fast-todo-selection t

     ;; block parent until children are done
     org-enforce-todo-dependencies t

     ;; allo to fast fix todo state without triggering anything
     org-treat-S-cursor-todo-selection-as-state-change nil

     ;; setup state triggers
     org-todo-state-tags-triggers
     '(("ANNUL√â" ("ANNUL√â" . t))
       ("ATTENDRE" ("ATTENDRE" . t))
       ("ENATTENTE" ("ATTENDRE") ("ENATTENTE" . t))
       (done ("ATTENDRE") ("ENATTENTE") ("FOCUS"))
       ("TODO" ("ATTENDRE") ("ANNUL√â") ("ENATTENTE"))
       ("FINI" ("ATTENDRE") ("ANNUL√â") ("ENATTENTE")))

     ;; use drawer for state changes
     org-log-into-drawer t)

    ;; tags
    (setq
     org-tag-persistent-alist '(("FOCUS" . ?f)
                                ("PROJET" . ?p))
     org-use-tag-inheritance t
     org-tags-exclude-from-inheritance '("projet"
                                         "litnotes"
                                         "people"))

    ;; avoid noisy `org-check-agenda-file'
    (advice-add #'org-check-agenda-file
                :around
                #'vulpea-check-agenda-file)
    :config
    ;; open directory links in `dired'
    (add-to-list 'org-file-apps '(directory . emacs))

    ;; open files in the same window
    (add-to-list 'org-link-frame-setup '(file . find-file))
    (setq org-indirect-buffer-display 'current-window))

  

  (use-package org-clock
    :straight nil
    :defer t
    :commands (org-clock-save)
    :init
    (setq
     org-clock-persist-file (expand-file-name "org-clock-save.el" emacs-etc/ )
     ;; remove clocked tasks with 0:00 duration
     org-clock-out-remove-zero-time-clocks t
     org-clock-persist 'history
     ;; Resume when clocking into task with open clock
     org-clock-in-resume t)
    :config
    (add-hook 'kill-emacs-hook #'org-clock-save))

  

  (use-package org-refile
    :straight nil
    :defer t
    :init
    (setq
     org-outline-path-complete-in-steps nil
     org-refile-targets '((nil :maxlevel . 4)
                          (org-agenda-files :maxlevel . 4))
     org-refile-use-outline-path t
     org-refile-allow-creating-parent-nodes nil
     org-refile-target-verify-function #'vulpea-refile-verify-target))

  

  (use-package org-id
    :straight nil
    :defer t
    :hook ((before-save . vulpea-id-auto-assign)
           (org-capture-prepare-finalize . org-id-get-create))
    :init
    (setq org-id-uuid-program
          "uuidgen | tr \"[:upper:]\" \"[:lower:]\"")
    :config
    (org-link-set-parameters
     "id" :activate-func #'vulpea-activate-link)
    (setq
     org-id-track-globally t
     org-id-extra-files
     (list (expand-file-name ".archive/archive" org-directory)
           (expand-file-name ".archive/archive.org" org-directory))
     org-id-link-to-org-use-id t
     org-id-locations-file (expand-file-name "org-id-locations" emacs-cache/)))

  

  (use-package org-capture
    :straight nil
    :defer t
    :general
    (leader-def
      "c" '(nil :which-key "capture...")
      "cX" '(org-capture :which-key "dispatch")
      "ca" '(vulpea-capture-article :which-key "article")
      "cj" '(vulpea-capture-journal :which-key "journal")
      "cl" '(org-store-link :which-key "link")
      "cm" '(vulpea-capture-meeting :which-key "meeting")
      "cx" '(vulpea-capture-task :which-key "task"))
    :init
    (setq-default org-capture-bookmark nil)
    :config
    (vulpea-capture-setup))

  

  (use-package org-attach
    :straight nil
    :defer t
    :config
    (setq-default
     org-attach-id-dir (expand-file-name ".data/" vulpea-directory)
     org-attach-auto-tag nil
     org-attach-file-list-property nil
     org-attach-store-link-p 'attached))

  

  (use-package org-archive
    :straight nil
    :defer t
    :init
    (setq-default
     org-archive-location
     (concat org-directory ".archive/%s_archive" "::" "datetree/*")
     org-archive-save-context-info
     '(time file ltags itags todo category olpath)))

  

  (use-package org-agenda
    :straight nil
    :defer t
    :general
    (leader-def
      "oA" '(org-agenda :which-key "agenda dispatch")
      "oa" '(vulpea-agenda-main :which-key "agenda")
      "op" '(vulpea-agenda-person :which-key "person"))
    :config
    (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
    (setq
     org-agenda-dim-blocked-tasks nil
     ;; setting it to t speeds up agenda, but... initial visibility is
     ;; not honored, which for me is a bigger issue
     org-agenda-inhibit-startup nil

     ;; also show state change in log mode
     org-agenda-log-mode-items '(closed clock state)

     ;; tags
     org-agenda-show-inherited-tags nil

     ;; priorities
      org-fancy-priorities-list '("‚ö°" "‚¨Ü" "‚¨á" "‚òï")

      org-priority-faces
            `((?A . ,(face-foreground 'error))
              (?B . ,(face-foreground 'warning))
              (?C . ,(face-foreground 'success)))

     ;; more structured view
     org-agenda-prefix-format
     '((agenda . " %(vulpea-agenda-category 24) %?-12t %12s")
       (todo . " %(vulpea-agenda-category 24) ")
       (tags . " %(vulpea-agenda-category 24) ")
       (search . " %(vulpea-agenda-category 24) "))
     org-agenda-todo-keyword-format "%-1s"
     org-agenda-tags-column 0

     ;; show agenda in current window
     org-agenda-window-setup 'current-window

     org-agenda-custom-commands
     `((" " "Agenda"
        (,vulpea-agenda-cmd-refile
         ,vulpea-agenda-cmd-today
         ,vulpea-agenda-cmd-focus
         ,vulpea-agenda-cmd-projects
         ,vulpea-agenda-cmd-waiting)
        ((org-agenda-buffer-name vulpea-agenda-main-buffer-name)))
        ("e" "Calendrier Eisenhower:"
        ( ;;,vulpea-agenda-cmd-eisen
         ,vulpea-agenda-eisen-imp-y-urg
         ,vulpea-agenda-eisen-imp
         ,vulpea-agenda-eisen-urg
         ,vulpea-agenda-eisen-alltodos)
        ((org-agenda-buffer-name vulpea-agenda-main-buffer-name)))))
      ;;tag-alist
      (setq-default
         org-tag-alist
         (quote (("@errand"     . ?e)
                 ("@bureau"    . ?o)
                 ("@maison"    . ?h)
                 ("important"  . ?i)
                 ("urgent"     . ?u)

                 (:newline)
                 ("ATTENDRE"  . ?w)
                 ("SUSPENDU√â" . ?h)
                 ("ANNUL√â"    . ?c)
                 ("R√âUNION"   . ?m)
                 ("T√âL√âPHONE" . ?p)
                 ("french"    . ?f)
                 ("spanish"   . ?s)))))

  

  (use-package org-roam
    :defer t
    :commands (org-roam-db-autosync-enable
               org-roam-db-sync)
    :init
    (setq
     org-roam-v2-ack t
     org-roam-directory vulpea-directory
     org-roam-dailies-directory (expand-file-name
                                 "journal/" org-roam-directory)
     org-roam-db-location (expand-file-name "org-roam.db" emacs-cache/)
     org-roam-completion-everywhere t)
    :config
    ;; For some reason org-roam is loaded on init and twice! Suspect it
    ;; is related to the fact that I am loading it from different
    ;; branch.
    ;;
    ;; So since I need a quick remedy, I noop `org-roam-db-sync' during
    ;; setup, because I sync data base time to time from terminal via
    ;; eru.
    (advice-add #'org-roam-db-sync :around #'fun-noop)
    (ignore-errors
      (org-roam-db-autosync-enable))
    (advice-remove #'org-roam-db-sync #'fun-noop))

  (use-package ox-latex
    :straight nil
    :defer t
    :config
    (add-to-list 'org-latex-packages-alist '("newfloat" "minted"))
    (add-to-list 'org-latex-packages-alist '("" "color"))
    (setq org-preview-latex-image-directory
          (expand-file-name "ltximg/" emacs-cache/))
    (setq org-format-latex-options
          (list :foreground 'auto
                :background 'auto
                :scale 1.5
                :html-foreground "Black"
                :html-background "Transparent"
                :html-scale 1.0
                :matchers '("begin" "$1" "$" "$$" "\\(" "\\[")))
    (setq org-latex-listings 'minted)
    (setq org-latex-pdf-process
          (seq-map
           (lambda (_)
             (string-join '("pdflatex"
                            "-shell-escape"
                            "-interaction nonstopmode"
                            "-output-directory %o %f")
                          " "))
           '(1 2 3))))

  (use-package ox-beamer
    :straight nil
    :defer t
    :config
    (add-to-list
     'org-beamer-environments-extra
     '("onlyenv" "O" "\\begin{onlyenv}%a" "\\end{onlyenv}")))

  

  (use-package ob-plantuml
    :straight nil
    :defer t
    :defines (org-plantuml-jar-path))

  

  (use-package toc-org
    :hook (org-mode . toc-org-mode))

#+end_src
*** Org Workflow
   :PROPERTIES:
   :header-args:    :tangle no
   :ID:                     7dbbb031-83de-45c1-a743-69bd6cd700cb
   :END:
The ever changing Org setup part
#+begin_src elisp :tangle no



  ;; Turn on indentation and auto-fill mode for Org files
  (defun gas/org-mode-setup ()
    (org-indent-mode)       ;; turn on org indent
    (variable-pitch-mode 1) ;; turn on variable-pitch
    (auto-fill-mode 0)      ;; turn off auto-fill
    (visual-line-mode 1)    ;; turn on visual-line-mode
    (show-paren-mode 1)     ;; show parentheses
    )

  (setup (:straight org)
    (:also-load org-tempo)
    ;; (:hook gas/org-mode-setup)
    (:global "C-c a"  org-agenda)
    (:bind   "C-c c"  org-capture
                "C-c l"  org-store-link)
    (setq ;;org-adapt-indentation nil ; don't indent things
     org-capture-bookmark nil
     org-catch-invisible-edits 'smart            ;; try not to accidently do weird stuff in invisible regions
     org-confirm-babel-evaluate nil
     org-cycle-separator-lines 2
     org-edit-src-content-indentation 2
     org-ellipsis " ‚Ä¶"
     org-export-coding-system 'utf-8-unix
     org-export-headline-levels 8
     org-export-in-background t                  ;; run export processes in external emacs process
     org-export-with-section-numbers nil
     org-export-with-smart-quotes t
     org-export-with-sub-superscripts '{}        ;; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
     org-export-with-toc t
     org-fontify-quote-and-verse-blocks t
     org-fontify-whole-heading-line t
     org-hide-block-startup nil
     org-hide-emphasis-markers t                 ;; so dont see text markers aka bold italic
     org-html-coding-system 'utf-8-unix
     org-html-todo-kwd-class-prefix "keyword "
     org-id-link-to-org-use-id 'create-if-interactive
     org-id-locations-file (/org-path ".orgids")
     org-image-actual-width '(300)
     org-list-allow-alphabetical t               ;; have a. A. a\) A\) list bullets
     org-log-done 'time                          ;; having the time a item is done sounds convenient
     org-outline-path-complete-in-steps nil
     org-pretty-entities t                       ;; special symbols, latex
     org-return-follows-link t
     org-src-tab-acts-natively t
     org-src-fontify-natively t
     org-src-preserve-indentation nil
     org-startup-folded 'content
     org-startup-indented t                       ;; removed leading * for nicer view
     org-startup-with-inline-images t
     ;; Use the special C-a, C-e and C-k definitions for Org, which enable some special behaviour in headings.
     org-special-ctrl-a/e t
     org-special-ctrl-k t
     org-use-property-inheritance t              ; it's convenient to have properties inherited
     )

     ;; Setup list of Org modules that should always be loaded together
    ;; with Org.
    (setq org-modules '(org-id org-attach))

    (setq org-refile-targets '((nil :maxlevel . 3)
                   (org-agenda-files :maxlevel . 3))
      org-refile-use-outline-path t)

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (clojure . t)
       (shell . t)
       (python . t)
       ;;(ledger . t)
       ))
    ;;(with-no-warnings
    (setq org-ts-regexp-both-braket "\\([[<]\\)\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} ?[^]\n>]*?\\)\\([]>]\\)")
    (defface org-deadline-custom-braket '((t (:inherit 'default))) "org-deadline" :group 'org)
    (defface org-scheduled-custom-braket '((t (:inherit 'default))) "org-schedule" :group 'org)
    (defface org-priority-hide '((t ())) "org-priority-hide" :group 'org)
    (defface org-scheduled-custom '((t (:inherit 'default))) "org-schedule" :group 'org)
    (defface org-closed-custom '((t (:inherit 'default))) "org-close" :group 'org)
    (defface org-todo-keyword-done '((t ())) "org-done" :group 'org)
    (defface org-todo-keyword-next '((t ())) "org-next" :group 'org)
    (defface org-todo-keyword-proj '((t ())) "org-proj" :group 'org)
    (defface org-todo-keyword-wait '((t ())) "org-wait" :group 'org)
    (defface org-todo-keyword-todo '((t ())) "org-todo" :group 'org)
    (defface org-todo-keyword-kill '((t ())) "org-kill" :group 'org)
    ;;)
    (with-no-warnings
      (custom-declare-face 'org-todo-keyword-next  '((t (:inherit (bold font-lock-constant-face org-todo)))) "")
      (custom-declare-face 'org-todo-keyword-proj '((t (:inherit (bold font-lock-doc-face org-todo)))) "")
      (custom-declare-face 'org-todo-keyword-wait  '((t (:inherit (bold warning org-todo)))) "")
      (custom-declare-face 'org-todo-keyword-kill  '((t (:inherit (bold error org-todo)))) ""))
    ;; change CAPITAL Keywords to lowercase
    (defun org-syntax-convert-keyword-case-to-lower ()
      "Convert all #+KEYWORDS to #+keywords."
      (interactive)
      (save-excursion
    (goto-char (point-min))
    (let ((count 0)
          (case-fold-search nil))
      (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
        (unless (s-matches-p "RESULTS" (match-string 0))
          (replace-match (downcase (match-string 0)) t)
          (setq count (1+ count))))
      (message "Remplacement de %d occurrences" count))))

    (push '("conf-unix" . conf-unix) org-src-lang-modes)
    (:load-after hl-fill-column
         (:hook gas/org-mode-setup)))

#+end_src

*** Fonts, Bullets & Links
   :PROPERTIES:
   :header-args:    :tangle no
   :ID:                     df41daa7-1a79-4a38-9700-4a2a60676302
   :END:
Use bullet characters instead of asterisks, plus set the header font sizes to something more palatable.  A fair amount of inspiration has been taken from [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][this blog post]].

#+begin_src emacs-lisp :tangle no
  (setup (:require org-indent)
    (:load-after org
      (org-indent-mode 1)
      (:hide-mode)))

  (setup (:straight org-appear)
    (:load-after org
    (:option org-appear-autoemphasis t
             org-appear-autoentities t
             org-appear-autokeywords t
             org-appear-autolinks nil
             org-appear-autosubmarkers t
             org-appear-delay 0)
    (:hook-into org-mode)))

  (unless ENV-IS-TERMUX?
    (setup (:straight org-superstar)
      (:load-after org
        (:option org-superstar-remove-leading-stars t
                 org-superstar-special-todo-items t
                 org-superstar-headline-bullets-list '("‚óâ" "‚óã" "‚óè" "‚óã" "‚óè" "‚óã" "‚óè"))
        (:hook-into org-mode)))

    ;; Replace list hyphen with dot
    ;; (font-lock-add-keywords 'org-mode
    ;;                         '(("^ *\\([-]\\) "
    ;;                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "‚Ä¢"))))))

    (setup org-faces
      (:load-after org-indent
        (dolist (face-cons '((org-document-title . 1.75)
                             (org-level-1 . 1.5)
                             (org-level-2 . 1.25)
                             (org-level-3 . 1.12)
                             (org-level-4 . 1.05)
                             (org-level-5 . 1.0)
                             (org-level-6 . 1.0)
                             (org-level-7 . 1.0)
                             (org-level-8 . 1.0)))
          (cl-destructuring-bind (face . height) face-cons
            (set-face-attribute face
                                nil
                                :weight 'bold
                                :font "Iosevka Aile"
                                :height height)))))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
    (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

    ;; Get rid of the background on column views
    (set-face-attribute 'org-column nil :background nil)
    (set-face-attribute 'org-column-title nil :background nil))


  ;; TODO: Others to consider
  ;; '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
  ;; '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
  ;; '(org-property-value ((t (:inherit fixed-pitch))) t)
  ;; '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
  ;; '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
  ;; '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
  ;; '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))
  (setup (:straight toc-org)
    (:load-after org
      (:hook-into org-mode)))
#+end_src

*** Org Roam
    :PROPERTIES:
   :header-args:    :tangle no
    :ID:                     7856eb18-fd30-4e21-8364-2b3990baa874
   :END:
#+begin_src emacs-lisp :tangle no
  (with-eval-after-load 'org
      (defvar dw/org-roam-project-template
        '("p" "projet" plain "** TODO %?"
          :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                 "#+title: ${title}\n#+category: ${title}\n#+filetags: projet\n"
                                 ("T√¢ches"))))

      (defun my/org-roam-filter-by-tag (tagname)
        (lambda (node)
          (member tagname (org-roam-node-tags node))))

      (defun my/org-roam-list-notes-by-tag (tagname)
        (mapcar #'org-roam-node-file
                (seq-filter
                 (my/org-roam-filter-by-tag tagname)
                 (org-roam-node-list))))

      (defun my/org-roam-project-finalise-hook ()
        "Adds the captured project file to `org-agenda-files' if the
                            capture was not aborted."
        ;; Remove the hook since it was added temporarily
        (remove-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalise-hook)

        ;; Add project file to the agenda list if the capture was confirmed
        (unless org-note-abort
          (with-current-buffer (org-capture-get :buffer)
            (add-to-list 'org-agenda-files (buffer-file-name)))))


      (defun my/org-roam-find-project ()
        (interactive)
        ;; Add the project file to the agenda after capture is finished
        (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalise-hook)

        ;; Select a project file to open, creating it if necessary
        (org-roam-node-find
         nil
         nil
         (my/org-roam-filter-by-tag "projet")
         :templates
         '(("p" "projet" plain "* Objectifs\n\n%?\n\n* T√¢ches\n\n** TODO Ajouter des t√¢ches initiales\n\n* Dates\n\n"
            :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: projet")
            :unnarrowed t))))

      (defun my/org-roam-capture-inbox ()
        (interactive)
        (org-roam-capture- :node (org-roam-node-create)
                           :templates '(("i" "inbox" plain "* %?"
                                         :if-new (file+head "inbox.org" "#+title: Bo√Æte de R√©ceptione\n")))))

      (defun my/org-roam-copy-todo-to-today ()
        (interactive)
        (let ((org-refile-keep t) ;; Set this to nil to delete the original!
              (org-roam-dailies-capture-templates
               '(("t" "t√¢ches" entry "%?"
                  :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n#+filetags: projet" ("T√¢ches")))))
              (org-after-refile-insert-hook #'save-buffer)
              today-file
              pos)
          (save-window-excursion
            (org-roam-dailies--capture (current-time) t)
            (setq today-file (buffer-file-name))
            (setq pos (point)))

          ;; Only refile if the target file is different than the current file
          (unless (equal (file-truename today-file)
                         (file-truename (buffer-file-name)))
            (org-refile nil nil (list "T√¢ches" today-file nil pos)))))


      ;; (add-to-list 'org-after-todo-state-change-hook
      ;;              (lambda ()
      ;;                (when (equal org-state "FINI")
      ;;                  (my/org-roam-copy-todo-to-today))))

      (defun org-roam-node-insert-immediate (arg &rest args)
        (interactive "P")
        (let ((args (push arg args))
              (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                        '(:immediate-finish t)))))
          (apply #'org-roam-node-insert args)))

      (defun dw/org-roam-goto-month ()
        (interactive)
        (org-roam-capture- :goto (when (org-roam-node-from-title-or-alias (format-time-string "%Y-%B")) '(4))
                           :node (org-roam-node-create)
                           :templates '(("m" "month" plain "\n* Objectifs\n\n%?* R√©sum√©\n\n"
                                         :if-new (file+head "%<%Y-%B>.org"
                                                            "#+title: %<%Y-%B>\n#+filetags: projet\n")
                                         :unnarrowed t))))

      (defun dw/org-roam-goto-year ()
        (interactive)
        (org-roam-capture- :goto (when (org-roam-node-from-title-or-alias (format-time-string "%Y")) '(4))
                           :node (org-roam-node-create)
                           :templates '(("y" "year" plain "\n* Objectifs\n\n%?* R√©sum√©\n\n"
                                         :if-new (file+head "%<%Y>.org"
                                                            "#+title: %<%Y>\n#+filetags: projet\n")
                                         :unnarrowed t))))

      (defun dw/org-roam-capture-task ()
        (interactive)
        ;; Add the projet file to the agenda after capture is finished
        (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalise-hook)

        ;; Capture the new task, creating the project file if necessary
        (org-roam-capture- :node (org-roam-node-read
                                  nil
                                  (my/org-roam-filter-by-tag "projet"))
                           :templates (list dw/org-roam-project-template)))

      (defun my/org-roam-refresh-agenda-list ()
        (interactive)
        (setq org-agenda-files (my/org-roam-list-notes-by-tag "projet")))

      (defhydra dw/org-roam-jump-menu (:hint nil)
        "
  ^Dailies^        ^Capture^       ^Jump^                  ^^^^^^^^-------------------------------------------------
  _t_: today       _T_: today       _m_: current month
  _r_: tomorrow    _R_: tomorrow    _e_: current year
  _y_: yesterday   _Y_: yesterday   ^ ^
  _d_: date        ^ ^              ^ ^
                              "
        ("t" org-roam-dailies-goto-today)
        ("r" org-roam-dailies-goto-tomorrow)
        ("y" org-roam-dailies-goto-yesterday)
        ("d" org-roam-dailies-goto-date)
        ("T" org-roam-dailies-capture-today)
        ("R" org-roam-dailies-capture-tomorrow)
        ("Y" org-roam-dailies-capture-yesterday)
        ("m" dw/org-roam-goto-month)
        ("e" dw/org-roam-goto-year)
        ("c" nil "cancel"))
      )

    (setup (:straight org-roam)
      (setq org-roam-v2-ack t)
      (setq dw/daily-note-filename "%<%Y-%m-%d>.org"
            dw/daily-note-header "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")


      (:when-loaded
        (org-roam-db-autosync-mode)

        (my/org-roam-refresh-agenda-list)
        (add-to-list 'org-tags-exclude-from-inheritance "projet") ;;stop inheritance from filetags
       ;; (add-hook 'find-file-hook #'vulpea-project-update-tag)
       ;; (add-hook 'before-save-hook #'vulpea-project-update-tag)

      ;;  (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
      ;;  (advice-add 'org-todo-list :before #'vulpea-agenda-files-update)
        )

      (:option
       org-roam-directory "~/org/roam/"
       org-roam-dailies-directory "journal/"
       org-roam-completion-everywhere t
       org-roam-capture-templates
       '(("d" "default" plain "%?"
          :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                             "#+title: ${title}\n")
          :unnarrowed t))
       org-roam-dailies-capture-templates
       `(("d" "default" entry
          "* %?"
          :if-new (file+head ,dw/daily-note-filename
                             ,dw/daily-note-header))
         ("t" "t√¢che" entry
          "* TODO %?\n  %U\n  %a\n  %i"
          :if-new (file+head+olp ,dw/daily-note-filename
                                 ,dw/daily-note-header
                                 ("T√¢ches"))
          :empty-lines 1)
         ("l" "log entry" entry
          "* %<%I:%M %p> - %?"
          :if-new (file+head+olp ,dw/daily-note-filename
                                 ,dw/daily-note-header
                                 ("Log")))
         ("j" "journal" entry
          "* %<%I:%M %p> - Journal  :journal:\n\n%?\n\n"
          :if-new (file+head+olp ,dw/daily-note-filename
                                 ,dw/daily-note-header
                                 ("Log")))
         ("m" "meeting" entry
          "* %<%I:%M %p> - %^{Meeting Title}  :meetings:\n\n%?\n\n"
          :if-new (file+head+olp ,dw/daily-note-filename
                                 ,dw/daily-note-header
                                 ("Log")))))
     )


    ;;(setq  org-capture-templates
    ;;       '(("x" "Note" entry
    ;;          (file+olp+datetree "journal.org")
    ;;          "**** [ ] %U %?" :prepend t :kill-buffer t)
    ;;         ("t" "T√¢ches" entry
    ;;          (file+headline "todo.org" "Bo√Æte de r√©ception")
    ;;          "* [ ] %?\n%i" :prepend t :kill-buffer t)))
    ;;  (setq org-capture-templates
    ;;        `(("i" "inbox" entry (file ,(concat gas/org-agenda-directory "inbox.org"))
    ;;          "* TODO %?")
    ;;         ("e" "email" entry (file+headline ,(concat gas/org-agenda-directory "emails.org") "Emails")
    ;;              "* TODO [#A] Reply: %a :@maison:@bureau:"
    ;;               :immediate-finish t)
    ;;          ("c" "org-protocol-capture" entry (file ,(concat gas/org-agenda-directory "inbox.org"))
    ;;               "* TODO [[%:link][%:description]]\n\n %i"
    ;;               :immediate-finish t)
    ;;          ("w" "Weekly Review" entry (file+olp+datetree ,(concat gas/org-agenda-directory "reviews.org"))
    ;;           (file ,(concat gas/org-agenda-directory "templates/weekly_review.org")))
    ;;           ))
#+end_src
*** Org Agenda
    :PROPERTIES:
   :header-args:    :tangle no
    :ID:                     0b03668d-0ae9-4b3f-b55c-652f1896a833
   :END:
org-capture provides a generic and extensible interface to capturing things into org-mode in
different formats
#+begin_src emacs-lisp :tangle no
    (setup org-agenda
      (:load-after org

        (setq org-todo-keywords
              '((sequence
                 "TODO(t)"  ; A task that needs doing & is ready to do
               ;;  "PROJ(p)"  ; A project, which usually contains other tasks
                 "SUIV(s)"  ; A task that is in progress
                 "ATTE(w)"  ; Something external is holding up this task
                 "SUSP(h)"  ; This task is paused/on hold because of me
                 "|"
                 "FINI(d)"  ; Task successfully completed
                 "KILL(k)") ; Task was cancelled, aborted or is no longer applicable
                (sequence
                 "[ ](T)"   ; A task that needs doing
                 "[-](S)"   ; Task is in progress
                 "[?](W)"   ; Task is being held up or paused
                 "|"
                 "[X](D)")  ; Task was completed
                (sequence
                 "|"
                 "OKAY(o)"
                 "YES(y)"
                 "NO(n)"))
              org-todo-keyword-faces
              '(("[ ]"   . org-todo-keyword-todo)
                ("SUIV" .  org-todo-keyword-next)
                ("[-]"  .  org-todo-keyword-next)
                ("[?]"  .  org-todo-keyword-wait)
                ("ATTE" .  org-todo-keyword-wait)
                ("SUSP" .  org-todo-keyword-wait)
                ("PROJ" .  org-todo-keyword-proj)
                ("KILL" .  org-todo-keyword-kill)
                ("FINI" .  org-todo-keyword-done)
                ("[X]"  .  org-todo-keyword-done)
                ))

        (setq org-agenda-custom-commands
              (quote
               (("n" "Prochaines T√¢ches"
                ((agenda "" ((org-deadline-warning-days 7)))
                 (todo "SUIV"
                       ((org-agenda-overriding-header "Prochaines T√¢ches")))))

               ;; Low-effort next actions
               ("l" tags-todo "+TODO=\"SUIV\"+Effort<15&+Effort>0"
                ((org-agenda-overriding-header "T√¢ches √† faible Effort")
                 (org-agenda-max-todos 20)
                 (org-agenda-files org-agenda-files)))
               ("h" "Habitudes" tags-todo "STYLE=\"habit\""
                ((org-agenda-overriding-header "Habitudes")
                 (org-agenda-sorting-strategy
                  '(todo-state-down priority-down category-keep))))
               ("e" "Eisenhower Matrix"
                ((agenda
                  ""
                  ((org-agenda-overriding-header "Calendrier Eisenhower:")
                   (org-agenda-show-log t)
                   (org-agenda-log-mode-items '(clock state))
                   (org-agenda-category-filter-preset '("-Habitudes"))
                   (org-agenda-span 5)
                   (org-agenda-start-on-weekday t)
                   ;;            (org-agenda-ndays 5)
                   ;;            (org-agenda-start-day "-2d")
                   (org-deadline-warning-days 30)))
                 (tags-todo
   "+important+urgent/!FINI"
      ((org-agenda-overriding-header "T√¢ches importantes et urgentes")
       (org-tags-match-list-sublevels nil)))
                 (tags-todo  "+important-urgent"
                             ((org-agenda-overriding-header "T√¢ches importantes mais non urgentes")
                              (org-tags-match-list-sublevels nil)))
                 (tags-todo "-important+urgent"
                            ((org-agenda-overriding-header "T√¢ches urgentes mais sans importance")
                             (org-tags-match-list-sublevels nil)))
                 (tags-todo "-important-urgent/!TODO"
                            ((org-agenda-overriding-header "T√¢ches non importantes ni urgentes")
                             (org-agenda-category-filter-preset '("-Habitudes"))
                             (org-tags-match-list-sublevels nil)))
                 (tags-todo "values"
                            ((org-agenda-overriding-header "Valeurs")
                             (org-tags-match-list-sublevels nil)))
                 ))
               (" " "Agenda"
                ((agenda ""
                         ((org-agenda-overriding-header "Calendrier d'aujourd'hui:")
                          (org-agenda-show-log t)
                          (org-agenda-log-mode-items '(clock state))
                         ;; (org-agenda-files '(,(/org-path "inbox.org")))
                          (org-agenda-text-search-extra-files nil)
                          ;;   (org-agenda-span 'day)
                          ;;   (org-agenda-ndays 3)
                          (org-agenda-start-on-weekday nil)
                          (org-agenda-start-day "-d")
                          (org-agenda-todo-ignore-deadlines nil)))
                 (tags-todo "+important"
                            ((org-agenda-overriding-header "T√¢ches Importantes √† Venir")
                             (org-tags-match-list-sublevels nil)))
                 (tags-todo "-important/TODO"
                            ((org-agenda-overriding-header "T√¢ches de Travail")
                             (org-agenda-category-filter-preset '("-Habitudes"))
                             (org-agenda-sorting-strategy
                              '(todo-state-down priority-down))))
                 (tags-todo "-important-urgent/TODO"
                            ((org-agenda-overriding-header "Habitudes")
                             (org-agenda-sorting-strategy
                              '(todo-state-down priority-down))))
                 (tags "FINI"
                       ((org-agenda-overriding-header "T√¢ches √† la Repr√©senter")
                        (org-tags-match-list-sublevels nil)))))
               )))))
#+end_src

*** Templates
    :PROPERTIES:
   :header-args:    :tangle no
    :ID:                     0cc1b333-09d8-46ed-9494-40ff0044d9fd
   :END:
These templates enable you to type things like =<el= and then hit =Tab= to expand
the template.  More documentation can be found at the Org Mode [[https://orgmode.org/manual/Easy-templates.html][Easy Templates]]
documentation page.

#+begin_src emacs-lisp

  ;; This is needed as of Org 9.2
  (setup org-tempo
    (:load-after org
      (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
      (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
      (add-to-list 'org-structure-template-alist '("li" . "src lisp"))
      (add-to-list 'org-structure-template-alist '("cli" . "src common-lisp"))
      (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
      (add-to-list 'org-structure-template-alist '("cl" . "src clojure"))
      (add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
      (add-to-list 'org-structure-template-alist '("py" . "src python"))
      (add-to-list 'org-structure-template-alist '("go" . "src go"))
      (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
      (add-to-list 'org-structure-template-alist '("json" . "src json"))))

#+end_src
Trying to fix weird org syntax problems. This just lets Org ignore < and > characters as if they
were regular words. This is necessary because in Clojure I want to make functions with -> in the
name and Org was always insisting on pairing <>. This caused any other paren matching to stop
working. It sucked.

*** Distraction Free
   :PROPERTIES:
   :header-args:    :tangle no
   :ID:                     ad5dade4-6cb2-4fc0-b942-d3986a172fe5
   :END:
setup olivetti to have a distraction free editing mode
#+begin_src emacs-lisp :tangle no
  ;; Distraction-free screen
    (setup (:straight olivetti)
      (setq olivetti-body-width .67)
      (defun distraction-free ()
        "Distraction-free writing environment"
        (interactive)
        (if (equal olivetti-mode nil)
            (progn
              (window-configuration-to-register 1)
              (delete-other-windows)
              (text-scale-increase 2)
              (olivetti-mode t))
          (progn
            (jump-to-register 1)
            (olivetti-mode 0)
            (text-scale-decrease 2))))
      (:bind "<f9>"  #'distraction-free))
#+end_src

** Coding Settings
:PROPERTIES:
:ID:                     7b76837f-f324-4bfa-a3b6-eaf47bb06ad3
:END:
I mostly use Clojure and Clojurescript, so they're setup inheriting from LISP setup
*** Code IDE Setup
:PROPERTIES:
:ID:                     b33e2c0c-2928-4951-982d-f58ebac42a71
:END:

Set basic subword mode and eldoc setting for prog-mode
#+begin_src emacs-lisp :noweb-ref code-paren
  (setup (:require subword)
    (global-subword-mode 1)
    (:hide-mode))

  (setup (:require eldoc)
    (setq eldoc-echo-area-use-multiline-p nil)
    (setq eldoc-idle-delay 0.1)
    (:with-mode prog-mode
      (:hook turn-on-eldoc-mode))
    (:hook-into clojure-mode
		cider-repl-mode
		elisp-mode
		lisp-interactive-mode)
    (:hide-mode))

  (setup (:require elec-pair)
    (electric-pair-mode 1))

#+end_src
  Setup smartparens and rainbow delimiters
#+begin_src emacs-lisp :noweb-ref code-paren
    ;; matching braces
    (setup (:require paren)
      (set-face-attribute 'show-paren-match-expression nil :background "#363e4a")
      (show-paren-mode 1))

    ;; dimm parenthesis
    ;; (setup (:straight paren-face)
    ;;   (:hook-into emacs-lisp-mode
    ;;       ielm-mode sly-repl-mode
    ;;       lisp-mode
    ;;       lisp-interaction-mode
    ;;       clojure-mode))

  ;; C-c @ C-d or C-s hide or show blocks
     (setup hideshow
      (defun +hs-cycle (&optional level)
        (interactive "p")
        (let (message-log-max
          (inhibit-message t))
      (if (= level 1)
          (pcase last-command
            ('+hs-cycle
             (hs-hide-level 1)
             (setq this-command 'hs-cycle-children))
            ('hs-cycle-children
             ;; TODO: Fix this case. `hs-show-block' needs to be
             ;; called twice to open all folds of the parent
             ;; block.
             (save-excursion (hs-show-block))
             (hs-show-block)
             (setq this-command 'hs-cycle-subtree))
            ('hs-cycle-subtree
             (hs-hide-block))
            (_
             (if (not (hs-already-hidden-p))
             (hs-hide-block)
           (hs-hide-level 1)
           (setq this-command 'hs-cycle-children))))
        (hs-hide-level level)
        (setq this-command 'hs-hide-level))))

      (defun +hs-global-cycle ()
        (interactive)
        (pcase last-command
      ('+hs-global-cycle
       (save-excursion (hs-show-all))
       (setq this-command 'hs-global-show))
      (_ (hs-hide-all))))
      (:with-mode hs-minor-mode
        (:hook-into prog-mode)
        (:bind "C-<tab>"   #'+hs-cycle
           "C-S-<tab>" #'+hs-global-cycle)))
    ;; Setup a "Common" ALL Lisp modes MAP

    (setup all-lisp-modes
      (define-minor-mode all-lisp-modes-mode
        "Mode for enabling all modes that are common for ALL lisps.

        \\<all-lisp-modes-mode-map>"
        :lighter " Almm"
        :keymap (make-sparse-keymap))
      (defun all-lisp-modes-indent-or-fill-sexp ()
        "Indent s-expression or fill string/comment."
        (interactive)
        (let ((ppss (syntax-ppss)))
      (if (or (nth 3 ppss)
          (nth 4 ppss))
          (fill-paragraph)
        (save-excursion
          (mark-sexp)
          (indent-region (point) (mark))))))
      (provide 'all-lisp-modes)
      (:with-map all-lisp-modes-mode-map
        (:bind "M-q" all-lisp-modes-indent-or-fill-sexp)))

    (setup (:straight rainbow-mode)
     (:hook-into prog-mode))

    (setup (:straight rainbow-delimiters)
      ;;(setq rainbow-delimiters-max-face-count 2)
      (:hook-into emacs-lisp-mode-hook
          eval-expression-minibuffer-setup-hook
          ielm-mode-hook
          lisp-interaction-mode-hook
          lisp-mode-hook
          sly-mrepl-mode-hook
          clojure-mode)
  ;;    (:hide-mode)
      )

    (setup (:straight smartparens)
      (:require smartparens-config)
       (:with-map smartparens-mode-map
        (:bind "C-M-q" sp-indent-defun
                "A-M-s"
          (defhydra smartparens-hydra ()
            "Smartparens"
            ("d" sp-down-sexp "Down")
            ("e" sp-up-sexp "Up")
            ("u" sp-backward-up-sexp "Up")
            ("a" sp-backward-down-sexp "Down")
            ("f" sp-forward-sexp "Forward")
            ("b" sp-backward-sexp "Backward")
            ("k" sp-kill-sexp "Kill" :color blue)
            ("q" nil "Quit" :color blue))
               "A-/ s"  hydra-smartparens))
      ;;(:with-map all-lisp-modes-mode-map
      ;;  (:bind ";" sp-comment))
      ;; use paredit bindings
      (sp-use-paredit-bindings)
      ;; needs to be set manually, because :bind section runs before :config
      (define-key smartparens-mode-map (kbd "M-r") 'sp-rewrap-sexp)
      (setq sp-cancel-autoskip-on-backward-movement nil)
      (setq sp-echo-match-when-visible nil)
      ;; Overlays are too distracting and not terribly helpful. show-parens does
      ;; this for us already (and is faster), so...
      (setq sp-highlight-pair-overlay nil)
      (setq sp-highlight-wrap-overlay nil)
      (setq sp-highlight-wrap-tag-overlay nil)
      ;; No pair has any business being longer than 4 characters; if they must, set
      ;; it buffer-locally. It's less work for smartparens.
      (setq sp-max-pair-length 2)
      ;; The default is 100, because smartparen's scans are relatively expensive
      ;; (especially with large pair lists for some modes), we reduce it, as a
      ;; better compromise between performance and accuracy.
      (setq sp-max-prefix-length 32)
      (setq sp-message-width nil)
      (setq sp-navigate-consider-sgml-tags nil)
      (setq sp-navigate-skip-match nil)
      (setq sp-show-pair-from-inside t)
      (setq sp-show-pair-delay 0)
      (sp-pair "'" nil :actions :rem)
      (sp-pair "`" nil :actions :rem)
      (sp-pair "(" nil :unless '(:rem sp-point-before-word-p))
      (sp-local-pair 'emacs-lisp-mode "`" "'") ;; adds `' as a local pair in emacs-lisp-mode
      (defun minibuffer-enable-sp ()
        "Enable `smartparens-strict-mode' in the minibuffer, during `eval-expression'."
        (setq-local comment-start ";")
        (sp-local-pair 'minibuffer-pairs "'" nil :actions nil)
        (sp-local-pair 'minibuffer-pairs "`" nil :actions nil)
        (sp-update-local-pairs 'minibuffer-pairs)
        (smartparens-strict-mode 1))


      ;; Define a hydra
       (defhydra hydra-smartparens (:hint nil)
         "
           Sexps (quit with _q_)

           ^Nav^            ^Barf/Slurp^          ^Depth^
           ^---^------------^----------^----------^-----^-----------------------
           _f_: forward     _s_:  slurp forward   _R_:      splice
           _b_: backward    _S_:  barf forward    _r_:      raise
           _a_: begin       _d_:  slurp backward  _<up>_:   raise backward
           _e_: end         _D_:  barf backward   _<down>_: raise forward
           _m_: mark

           ^Kill^           ^Misc^                       ^Wrap^
           ^----^-----------^----^-----------------------^----^------------------
           _w_: copy        _j_: join                    _(_: wrap with ( )
           _k_: kill        _s_: split                   _{_: wrap with { }
           ^^               _t_: transpose               _'_: wrap with ' '
           ^^               _c_: convolute               _\"_: wrap with \" \"
           ^^               _i_: indent defun"
         ("q" nil)
         ;; Wrapping
         ("(" (lambda (a) (interactive "P") (sp-wrap-with-pair "(")))
         ("{" (lambda (a) (interactive "P") (sp-wrap-with-pair "{")))
         ("'" (lambda (a) (interactive "P") (sp-wrap-with-pair "'")))
         ("\"" (lambda (a) (interactive "P") (sp-wrap-with-pair "\"")))
         ;; Navigation
         ("f" sp-beginning-of-next-sexp)
         ("b" sp-beginning-of-previous-sexp)
         ("a" sp-beginning-of-sexp)
         ("e" sp-end-of-sexp)
         ("m" sp-mark-sexp)
         ;; Kill/copy
         ("w" sp-copy-sexp :exit t)
         ("k" sp-kill-sexp :exit t)
         ;; Misc
         ("t" sp-transpose-sexp)
         ("j" sp-join-sexp)
         ("c" sp-convolute-sexp)
         ("i" sp-indent-defun)
         ;; Depth changing
         ("R" sp-splice-sexp)
         ("r" sp-splice-sexp-killing-around)
         ("<up>" sp-splice-sexp-killing-backward)
         ("<down>" sp-splice-sexp-killing-forward)
         ;; Barfing/slurping
         ("s" sp-forward-slurp-sexp)
         ("S" sp-forward-barf-sexp)
         ("D" sp-backward-barf-sexp)
         ("d" sp-backward-slurp-sexp))
      (:with-hook (emacs-lisp-mode-hook
           expression-minibuffer-setup-hook
           ielm-mode-hook
           lisp-interaction-mode-hook
           lisp-mode-hook
           all-lisp-modes-mode-map
           sly-mrepl-mode-hook
           clojure-mode-hook
           clojurescript-mode-hook
           cider-repl-mode-hook)
        (:hook smartparens-strict-mode))
       (:hide-mode)
      )
#+end_src
*** Emacs Lisp
:PROPERTIES:
:ID:                     177c09d9-4bc3-4fd8-8fa1-de4580519c38
:END:
ielm setup
#+begin_src emacs-lisp :noweb-ref code-elisp
  (setup (:require pulse)
    (defgroup +pulse nil
      "Extra customisations for `pulse'."
      :group 'pulse
      :prefix "+pulse-")

    (defcustom +pulse-location-commands '(scroll-up-command
                                          scroll-down-command
                                          recenter-top-bottom
                                          other-window
                                          switch-to-buffer
                                          redraw-frame)
      "Commands to pulse the current line after.
  Good for finding location."
      :type '(repeat function))

    (defcustom +pulse-location-function '+pulse-line-current-window
      "What function to call after `+pulse-location-commands'."
      :type 'function)

    ;; XXX: this doesn't work yet.  I only want to pulse the line in the
    ;; active window, so when I have the same buffer viewed in multiple
    ;; windows I can still see where my cursor is.  To see the issue, C-x
    ;; 2 then C-x o a few times.
    (defun +pulse-line-current-window (&rest _)
      "Pulse the current line, but only if this window is active."
      (pulse-momentary-highlight-one-line
       (window-point (selected-window))))

    (defun +pulse--advice-remove (symbol where function &optional props)
      "Remove advice SYMBOL from FUNCTION.
  This uses the same args as `advice-add' for easy toggling.
  WHERE and PROPS are discarded."
      (ignore where props)
      (advice-remove symbol function))

    (define-minor-mode +pulse-location-mode
      "After moving locations, pulse where we are."
      :global t
      :keymap nil
      (dolist (command +pulse-location-commands)
        (funcall
         (if +pulse-location-mode 'advice-add '+pulse--advice-remove)
         command :after +pulse-location-function)))
    (:option pulse-flag nil
             pulse-delay 0.5
             pulse-iterations 1)
    (dolist (command '(+ace-window-or-switch-buffer
                       pop-mark pop-globl-mark))
      (add-to-list '+pulse-location-commands command))
    (+ensure-after-init #'+pulse-location-mode))

  (setup elisp-mode
    (defun +elisp-eval-region-or-buffer ()
      (interactive)
      (if (region-active-p)
          (eval-region (region-beginning) (region-end))
        (+eval-region@pulse (lambda (_ _) (eval-buffer)) (point-min) (point-max))))

    (defun +eval-region@pulse (advised beg end &rest args)
      "ADVICE to pulse an eval'd region."
      (apply advised beg end args)
      (pulse-momentary-highlight-region beg end))

    (:option eval-expression-print-length nil
             eval-expression-print-level nil)
    (:with-map (emacs-lisp-mode-map lisp-interaction-mode-map)
      (:bind "C-c C-c" #'eval-defun
             "C-c C-k" #'+elisp-eval-region-or-buffer
             "C-c C-z" #'ielm )
    (advice-add #'eval-region :around #'+eval-region@pulse)))

  (setup (:straight elisp-slime-nav)
    (:load-after ielm
      (:hook-into emacs-lisp-mode ielm-mode)
      (:hide-mode)))

  (setup (:straight ielm)
    (:load-after comint
      (:with-map ielm-map
        (:bind
         [up] comint-previous-input
         [down] comint-next-input))))

  (setup (:straight macrostep)
    (:with-map macrostep-keymap
      (:bind
       [tab] macrostep-next-macro
       [backtab] macrostep-prev-macro
       "c" macrostep-collapse
       "e" macrostep-expand
       "q" macrostep-collapse-all))
    (:hide-mode))
#+end_src
*** Common LISP
:PROPERTIES:
:ID:                     91288bc3-f9f3-4b78-bd8d-5077decdeef0
:END:
SLY setup
#+begin_src emacs-lisp :noweb-ref code-common-lisp
  (defun mf/sly-ask ()
    (interactive)
    (let ((current-prefix-arg '-))
      (sly nil nil t)))

  (setup (:straight sly)
    (:when-loaded
      (sly-setup '(sly-fancy)))
    (setq sly-command-switch-to-existing-lisp 'always)
    (setq sly-complete-symbol-function 'sly-flex-completions)
    (setq sly-enable-evaluate-in-emacs t)
    (setq sly-kill-without-query-p t)
    (setq sly-mrepl-history-file-name (/etc-file "sly-repl-history"))
    (setq sly-mrepl-pop-sylvester nil)
    (setq sly-mrepl-prevent-duplicate-history 'move)
    (setq sly-net-coding-system 'utf-8-unix)
    (:hide-mode))

#+end_src
*** Clojure
:PROPERTIES:
:ID:                     0c4cf23b-280e-4fbc-ae81-e091f8f8bc8d
:END:
Editing Clojure / Clojurescript code is best done using a REPL, which is provided with the cider package.
Cider has a lot of options to customise, and here are the ones I think are most critical.
Source comes from: [[https://stackoverflow.com/a/31080940]]
#+begin_src elisp :noweb-ref code-clojure

  (setup (:straight clojure-mode)
    (:with-hook (clojure-mode
		 clojurec-mode
		 clojurescript-mode)
      (:bind "<M-return>" 'clerk-show)
      (:file-match (rx "/.edn" eos))
      (defun clojure-mode-setup ()
	"Setup Clojure buffer."
	(all-lisp-modes-mode)
	(clojure-set-compile-command)
	(flycheck-mode))
      (:hook #'clojure-mode-setup)
      (defvar org-babel-default-header-args:clojure '((:results . "silent")))'
      (defun clerk-show ()
	(interactive)
	(save-buffer)
	(let
	    ((filename
	      (buffer-file-name)))
	  (when filename
	    (cider-interactive-eval
	     (concat "(nextjournal.clerk/show! \"" filename "\")")))))

      (defun org-babel-execute:clojure (body params)
	"Evaluate a block of Clojure code with Babel."
	(lisp-eval-string body))
      (defun clojure-set-compile-command ()
	(let ((project-dir (clojure-project-dir)))
	  (cond ((and (file-exists-p (expand-file-name "project.clj" project-dir))
		      (executable-find "lein"))
		 (setq-local compile-command "lein "))
		((and (file-exists-p (expand-file-name "deps.edn" project-dir))
		      (executable-find "clojure"))
		 (setq-local compile-command "clojure ")))))))

  (setup (:straight cider)
    (:load-after clojure-mode
      (:option nrepl-log-messages nil
	       nrepl-use-ssh-fallback-for-remote-hosts t
	       nrepl-hide-special-buffers t
	       cider-allow-jack-in-without-project t
	       cider-enrich-classpath t
	       cider-font-lock-dynamically '(macro var deprecated)
	       cider-repl-clear-help-banner t
	       cider-repl-display-help-banner nil
	       cider-repl-tab-command #'indent-for-tab-command
	       ;;cider-repl-use-pretty-printing t
	       ;;cider-repl-pop-to-buffer-on-connect t
	       cider-save-file-on-load nil
	       cider-test-show-report-on-success t
	       cider-use-fringe-indicators nil)
      (:bind "C-c C-S-o" cider-repl-clear-buffer )
      ;; (cider-result-overlay-face ((t (:box (:line-width -1 :color "grey50")))))
      ;; (cider-error-highlight-face ((t (:inherit flymake-error))))
      ;; (cider-warning-highlight-face ((t (:inherit flymake-warning))))
      (
       :with-mode cider-repl-mode clojure-mode)
      (:hook eldoc-mode)))

  ;; Allow cider-repl to be cleared with shortcut
  ;;(add-hook 'cider-repl-mode-hook
			 ;;;          '(lambda () (define-key cider-repl-mode-map (kbd "C-c M-b")
					  ;                        'cider-repl-clear-buffer)))

  ;; (add-hook 'cider-mode-hook (lambda () (show-paren-mode 1)))
  ;; (add-hook 'cider-mode-hook #'eldoc-mode)

  ;;(add-hook 'cider-repl-mode-hook #'enable-paredit-mode)
  ;;(add-hook 'cider-mode-hook #'imenu-add-menubar-index)


  (setup (:straight async))
  (setup (:straight ob-async))
  (setup (:straight ob-clojurescript))
  ;;(setup (:straight ob-babel-eval-in-repl))

  (setup (:straight flycheck-clj-kondo)
    :only-if (executable-find "clj-kondo"))

  ;;(setup (:straight eval-in-repl))

#+end_src


**** clj templates
:PROPERTIES:
:ID:                     330e9ad1-9bd0-4386-ac8d-0a678ebb1626
:END:
Insertion templates can be used to speed up project setups. This is code of my own creation, so use at your own risk. The template files are in ~.emacs.d/templates/lib.org~.

***** slurp
:PROPERTIES:
:ID:                     0828d7f4-cd5d-4c67-96ca-3d258df3de6c
:END:
#+begin_src elisp
(defun slurp (file)
  (with-temp-buffer
    (insert-file-contents file)
    (buffer-substring-no-properties
     (point-min)
     (point-max))))

#+end_src

***** template-reader
:PROPERTIES:
:ID:                     b3a54fa3-459b-4042-98e0-cdb2a87ed925
:END:
#+begin_src elisp
(defun template-reader (file replace)
  (let ((lines (split-string (slurp file) "\n")))
    (->> lines
         (mapcar (lambda (x) (replace-regexp-in-string "_str_" replace x)))
         (mapcar (lambda (x) (concat x "\n")))
         (-concat)
         (apply 'concat))))

#+end_src

***** clj-org-templates
:PROPERTIES:
:ID:                     7d6c4f18-4510-4ebc-951d-94c4233407a5
:END:
I use org mode and literate programming ideas to build my clj/cljs projects. So, it is helpful to have skeletons that take .org template files that tangle into a nice clojure project setup. Currently I only have one template, but the idea is to be able to have a few which you just bind to different keys as needed. The idea is demonstrated with 'Project' and 'Library'.

#+begin_src elisp :tangle no
(define-skeleton cljc-lib-skeleton
  "Inserts a .org template with user's project name input.
   Use in empty file and save to desired project directory.
   Tangle will create project structure on save."
  ""
  (template-reader "~/.config/emacs/templates/lib.org" (skeleton-read "Library name: ")))

(define-skeleton cljc-project-skeleton
  "Inserts a .org template with user's project name input.
   Use in empty file and save to desired project directory.
   Tangle will create project structure on save."
  ""
  (template-reader "~/.emacs.d/templates/lib.org" (skeleton-read "Project name: ")))

;;(global-set-key (kbd "C-S-L") 'cljc-lib-skeleton)
;;(global-set-key (kbd "C-S-P") 'cljc-project-skeleton)

#+end_src
*** Fennel
:properties:
:header-args: :noweb-ref code-fennel
:ID:                     a8e738f4-2a6a-4fe4-8efe-9cedd4aaedd3
:end:
Setup of Fennel and Lua

#+begin_src emacs-lisp

(setup (:straight lua-mode))

(setup (:straight fennel-mode)
(:bind "C-c C-k"  eval-each-sexp)
(put 'global 'fennel-indent-function 1)
  (put 'local 'fennel-indent-function 1)
  (put 'var 'fennel-indent-function 1)
  (defvar org-babel-default-header-args:fennel '((:results . "silent")))
  (defun org-babel-execute:fennel (body _params)
    "Evaluate a block of Fennel code with Babel."
    (save-window-excursion
      (unless (bufferp fennel-repl--buffer)
        (fennel-repl nil))
      (let ((inferior-lisp-buffer fennel-repl--buffer))
        (lisp-eval-string body))))
  (defun eval-each-sexp ()
    "Evaluate each s-expression in the buffer consequentially.

  If prefix ARG specified, call `fennel-reload' function.  If
  double prefix ARG specified call `fennel-reload' function and ask
  for the module name."
      (interactive)
      (save-excursion
        (save-restriction
          (goto-char (point-min))
          (while (save-excursion
                   (search-forward-regexp "[^[:space:]]." nil t))
            (forward-sexp)
            (when (and (not (nth 4 (syntax-ppss)))
                       (looking-back "." 1))
              (lisp-eval-last-sexp)))))
      (when fennel-mode-switch-to-repl-after-reload
        (switch-to-lisp t)))
  )

  (setup (:straight ssh-config-mode)
  (:file-match (rx "/.ssh/config" eos)
               (rx "/ssh" (? "d") "_config" eos))
  (:with-mode ssh-known-hosts-mode
    (:file-match (rx "/knownhosts" eos)))
  (:with-mode ssh-authorized-keys-mode
    (:file-match (rx "/authorized_keys" (? "2") eos))))
#+end_src
*** Statistics
:PROPERTIES:
:ID:                     8384410a-5ec8-43e5-a0bc-fdecdfe79daa
:END:
Emacs Speaks Statistics
#+begin_src emacs-lisp :noweb-ref ess
  (setup (:straight ess)
    ;;(:require ess-r-mode)
    (setq ess-ask-for-ess-directory nil)
    (setq ess-local-process-name "R")
    (setq-default inferior-R-program-name "/usr/local/bin/R")
    (setq ess-eval-visibly 'nowait)
    (setq comint-input-ring-size 1000)
    (setq ess-indent-level 4)
    (setq ess-arg-function-offset 4)
    (setq ess-else-offset 4)

    ;; Autocomplete
    (:require auto-complete-config)
    (ac-config-default)
    (setq ess-use-auto-complete t)

    ;; Read pdfs outside emacs
    (:require openwith)
    (openwith-mode t)
    (setq openwith-associations '(("\\.pdf\\'" "open" (file))))
	;;;; create a new frame for each help instance
    (setq ess-help-own-frame t)
    (setq ess-offset-continued 'straight
	  ess-use-flymake 1
	  ess-nuke-trailing-whitespace-p t
	  ess-style 'DEFAULT
	  ess-history-directory (expand-file-name "ess-history/" emacs-cache/))
    ;; Make the arrow keys refer to previous commands
    (defun my-ess-mode-hook ()
      (local-set-key '[up] 'comint-previous-input)
      (local-set-key '[down] 'comint-next-input)
      (local-set-key '[C-x \t] 'comint-dynamic-complete-filename))

      (add-hook 'inferior-ess-mode-hook 'my-ess-mode-hook))

 (defhydra hydra-polymode ()
  "Polymode Hydra"
  ("j" polymode-next-chunk-same-type "Next chunk, same type" :column "Movement")
  ("k" polymode-previous-chunk-same-type "Previous chunk, same type" :column "Movement")
  ("i" polymode-insert-new-chunk "Insert new chunk" :column "Insert")
  ("I" jth/insert-image "Insert image from file" :column "Insert")
  ("c" polymode-mark-or-extend-chunk "Mark chunk" :column "Chunk")
  ("u" polymode-insert-new-chunk-code-only "Insert chunk (code only)" :column "Insert")
  ("U" polymode-insert-new-chunk-output-only "Insert chunk (output only)" :column "Insert")
  ("p" polymode-insert-new-plot "Insert plot" :column "Insert")
  ("o" polymode-insert-yaml "Insert YAML" :column "Insert")
  ("d" polymode-kill-chunk "Kill chunk" :column "Chunk")
  ("m" my/add-pipe "Add pipe" :column "Insert")
  ("e" polymode-export "Export" :column "Export")
  ("E" polymode-set-exporter "Set exporter" :column "Export")
  ("w" polymode-weave "Weave" :column "Export")
  ("W" polymode-set-weaver "Set weaver" :column "Export")
  ("$" polymode-show-process-buffer "Show process buffer" :column "Evaluation")
  ("," polymode-eval-region-or-chunk "Eval chunk" :column "Evaluation")
  ("N" polymode-eval-buffer "Eval buffer" :column "Evaluation")
  ("1" polymode-eval-buffer-from-beg-to-point "Eval to here" :column "Evaluation")
  ("0" polymode-eval-buffer-from-point-to-end "Eval to end" :column "Evaluation"))
#+end_src

* Keybindings
:PROPERTIES:
:header-args: :noweb-ref keyboard
:ID:                     fd9b171e-7f6a-4140-86e6-57a4b3d726e9
:END:
Change the Mac modifiers to my liking. I also disable passing Control characters to the system, to avoid that C-M-space launches the Character viewer instead of running mark-sexp.
#+begin_src emacs-lisp
(cond (ENV-IS-MAC?
       (setq mac-command-modifier      'meta
              mac-option-modifier         'alt
              mac-right-option-modifier   'alt
              mac-pass-control-to-system nil)))
#+end_src
When at the beginning of the line, make Ctrl-K remove the whole line, instead of just emptying it.
#+begin_src emacs-lisp
(setq kill-whole-line t)
#+end_src
*** Emulating Vi's % key
:PROPERTIES:
:ID:                     80396951-51ce-4299-8b88-7fc72c7fd079
:END:
One of the few things I missed in Emacs from vi was the % key, which jumps to the parenthesis, bracket or brace which matches the one below the cursor. This function implements this functionality, bound to the same key. Inspired by NavigatingParentheses, but modified to use smartparens instead of the default commands, and to work on brackets and braces.
#+begin_src emacs-lisp
  (setup
      (:straight smartparens)
    (defun zz/goto-match-paren (arg)
      "Go to the matching paren/bracket, otherwise (or if ARG is not
      nil) insert %.  vi style of % jumping to matching brace."
      (interactive "p")
      (if (not (memq last-command '(set-mark
				    cua-set-mark
				    zz/goto-match-paren
				    down-list
				    up-list
				    end-of-defun
				    beginning-of-defun
				    backward-sexp
				    forward-sexp
				    backward-up-list
				    forward-paragraph
				    backward-paragraph
				    end-of-buffer
				    beginning-of-buffer
				    backward-word
				    forward-word
				    mwheel-scroll
				    backward-word
				    forward-word
				    mouse-start-secondary
				    mouse-yank-secondary
				    mouse-secondary-save-then-kill
				    move-end-of-line
				    move-beginning-of-line
				    backward-char
				    forward-char
				    scroll-up
				    scroll-down
				    scroll-left
				    scroll-right
				    mouse-set-point
				    next-buffer
				    previous-buffer
				    previous-line
				    next-line
				    back-to-indentation
				    )))
	  (self-insert-command (or arg 1))
	(cond ((looking-at "\\s\(") (sp-forward-sexp) (backward-char 1))
	      ((looking-at "\\s\)") (forward-char 1) (sp-backward-sexp))
	      (t (self-insert-command (or arg 1)))))
      )
    (:global "%" 'zz/goto-match-paren))
#+end_src

* Maybe to applied - not tangled at present
:PROPERTIES:
:ID:                     be23b9fc-341c-484f-a0d6-57402277cd14
:END:
#+begin_src elisp :tangle no

    ;; enable line-numbers
     (column-number-mode)

     ;; Enable line numbers for some modes
     (dolist (mode '(text-mode-hook
                     prog-mode-hook
                     conf-mode-hook))
       (add-hook mode (lambda () (display-line-numbers-mode 1))))

     ;; Override some modes which derive from the above
     (dolist (mode '(org-mode-hook))
       (add-hook mode (lambda () (display-line-numbers-mode 0))))



#+end_src


* Tangling config noweb
:PROPERTIES:
:ID:                     65bbc8e3-5a87-434f-b70b-f920af75b954
:END:
** Header & disclaimer
:PROPERTIES:
:header-args: :noweb-ref disclaimer
:ID:                     f9031214-0bc2-4e91-a037-06fc4375292d
:END:

#+begin_src emacs-lisp
;; Copyright (C) 2021 Gas

;; Author: Gas <gas@tuatara.red>
;; Version: 1.0
;; Package-Version: 0.1
;; Created: Sometime during the Covid-19 lockdown
;; Keywords: configuration, emacs
;; URL: https://github.com/frap/emacs.d
;; Package-Requires: ((emacs "27.2"))

;; Time-stamp: <>
;; This file is not part of GNU Emacs.

;;; Commentary:
;; This file is automatically tangled from config.org.
;; Hand edits will be overwritten!
;; Je t'ai pr√©venu putain!

#+end_src
** Emacs paths & directories
:PROPERTIES:
:header-args: :tangle lisp/config-path.el :noweb yes
:ID:       06227072-5f8a-46ee-abd6-d216972267b6
:END:

Setup emacs paths and directory constants


#+begin_src emacs-lisp
;;; config-path.el --- Path constants -*- lexical-binding: t -*-

<<disclaimer>>
;;
;; This module defines path constants used across other modules.
;;
;;; Code:

<<path-config>>

(provide 'config-path)
;;; config-path.el ends here
#+end_src
** Shell Environment
:PROPERTIES:
:header-args: :tangle lisp/init-env.el :noweb yes
:ID:       b9e98d24-b79e-4982-abf5-9b403dc76990
:END:

Setup emacs paths and directory constants


#+begin_src emacs-lisp
;;; init-env.el --- Setup Environment -*- lexical-binding: t -*-

<<disclaimer>>
;;
;; This module uses doom load-envars to load shell ENV
;;
;;; Code:


<<environment>>


(provide 'init-env)
;;; init-env.el ends here
#+end_src
** Keyboard
:PROPERTIES:
:header-args: :tangle lisp/init-kbd.el :noweb yes
:ID:       53f268fc-1d6f-4fe4-a047-945da3ceb14c
:END:

Setup keyboard

#+begin_src emacs-lisp
  ;;; init-kbd.el --- Setup Keyboard -*- lexical-binding: t -*-

  <<disclaimer>>
  ;;
  ;; This module sets up keyboard
  ;;
  ;;; Code:

  (require 'init-elpa)
  (require 'init-env)
  (+with-message "KeyBoard Setup"
   <<keyboard>>

   <<keybindings>>
   )

  (provide 'init-kbd)
  ;;; init-kbd.el ends here
#+end_src
** My Utility fns and macros
:PROPERTIES:
:header-args: :tangle lisp/init-fn-macros.el :noweb yes
:ID:       32254b01-c611-4923-a3b2-69b7c1e09a18
:END:

File for my constants, macros and functions
#+begin_src emacs-lisp
;;; init-fn-macros.el --- Util fns -*- lexical-binding: t -*-

<<disclaimer>>

(+with-message "Util Fns & macros"
;;; Code:

;;; ============================================================================
;;; Variables
;;; ============================================================================

<<variables>>

;;; ============================================================================
;;; Macros
;;; ============================================================================

<<macros>>

;;; ============================================================================
;;; Functions
;;; ============================================================================

<<functions>>

) ;; end of +with-message

(provide 'init-fn-macros)
;;; init-fn-macros.el ends here
#+end_src

** ELPA package management
:PROPERTIES:
:header-args: :tangle lisp/init-elpa.el :noweb yes
:ID:       d0ccd1fd-61de-4673-96cb-3d4550fef601
:END:

"Setup" of setup.el the emacs package manager and package setup to replace use-package


#+begin_src emacs-lisp
   ;;; init-elpa.el --- Initialise ELPA -*- lexical-binding: t -*-
   <<disclaimer>>
   ;;
   ;; Setup Emacs for installing packages from MELPA and Git
   ;; repositories. Enable configuration via `setup'.
   ;;; Code:

   (require 'config-path)
   ;;(+with-message "setup ELPA"

     <<straight-setup>>
     ;; Install setup.el. We use this to concisely perform repetitive tasks, such as
     ;; installing and loading packages.
     <<setup-pkgmgr>>
   ;;;============================================================================
   ;;; Custom setup.el local macros
   ;;; ============================================================================

     <<setup-macros>>
   ;;) ;; end of +with-message

   (provide 'init-elpa)
   ;;; init-elpa.el ends here
#+end_src
** Sanity & User setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-emacs-sanity.el :noweb yes
:ID:       ec18e2f5-2fad-4939-8c18-c5b7154bb002
:END:

"Setup" of Emacs to some sort of sanity

#+begin_src emacs-lisp
  ;;; enfer-emacs-sanity.el --- Sanity -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

(+with-message "Emacs Sanity settings"

  <<user-config>>

  (setup misc
    (setq ad-redefinition-action 'accept)
    (setq bidi-inhibit-bpa t)
    (setq command-line-ns-option-alist nil)
    (setq confirm-kill-processes nil)
   ;; (setq custom-file (/etc-file "custom.el"))
    ;;(setq default-input-method "TeX")
    (setq ffap-machine-p-known 'reject)
    (setq inhibit-compacting-font-caches t)
    (setq inhibit-default-init t)
    (setq jit-lock-defer-time nil)
    (setq jka-compr-verbose nil)
    (setq native-comp-async-report-warnings-errors nil)
    (setq read-file-name-completion-ignore-case t)
    (setq read-process-output-max (* 64 1024))
    (setq redisplay-skip-fontification-on-input t)
    (setq ring-bell-function 'ignore)
    (setq-default fill-column 100)
    (setq-default lexical-binding t))

  <<sanity>>

  ) ;; end of +with-message
  (provide 'enfer-emacs-sanity)
;;; enfer-emacs-sanity.el ends here
#+end_src

** Emacs Startup enhancements and GC
:PROPERTIES:
:header-args: :tangle lisp/enfer-emacs-startup.el :noweb yes
:ID:       4ec8d416-737b-4443-b7d9-a7141e810a70
:END:

Setup auto-compile, no littering and GMCH

#+begin_src emacs-lisp
  ;;; enfer-emacs-startup.el --- Startup -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

 (+with-message "Startup enhancements"
  <<emacs-startup>>

  )
  (provide 'enfer-emacs-startup)
  ;;; enfer-emacs-startup.el ends here
#+end_src
** Emacs Builtins
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-builtin.el :noweb yes
:ID:       f5f2cd71-51af-48bd-a328-62092db7df6f
:END:

Setup Emacs builtins


#+begin_src emacs-lisp
    ;;; enfer-pkg-builtin.el --- Builtins -*- lexical-binding: t -*-
    <<disclaimer>>
    ;;; Code:

   (+with-message "Builtins"

    (setup abbrev
      (:option abbrev-file-name (sync/ "abbrev.el")
               save-abbrevs 'silent)
      (:hook-into text-mode
                  circe-chat-mode))

        (setup auto-fill
          (:with-feature simple
            (:with-mode (text-mode org-mode)
              (:hook turn-on-auto-fill))
            (:with-mode prog-mode
              (:hook (fn (setq-local comment-auto-fill-only-comments t)
                         (auto-fill-mode 1))))
            (:hide-mode auto-fill-function)))

        (setup (:require autorevert)
          (setq auto-revert-check-vc-info t)
          (setq auto-revert-remote-files t)
          (setq global-auto-revert-non-file-buffers t)
          (setq auto-revert-verbose nil)
          (global-auto-revert-mode 1)
          (:hide-mode auto-revert))

        (setup comint
          (setq ansi-color-for-comint-mode t)
          (setq comint-buffer-maximum-size 4096)
          (setq comint-prompt-read-only t))

        (unless ENV-IS-TERMUX?
          (setup compile
          (add-hook 'compilation-filter #'ansi-color-compilation-filter)
          (:option compilation-always-kill t
                   compilation-ask-about-save nil
                   compilation-scroll-output 'first-error)
          (defmacro compile-add-error-syntax (name regexp file line &optional col level)
            "Register new compilation error syntax.

        Add NAME symbol to `compilation-error-regexp-alist', and then add
        REGEXP FILE LINE and optional COL LEVEL info to
        `compilation-error-regexp-alist-alist'."
            (declare (indent 1))
            `(progn (add-to-list 'compilation-error-regexp-alist ',name)
                    (add-to-list 'compilation-error-regexp-alist-alist
                                 '(,name ,regexp ,file ,line ,col ,level))))
          (compile-add-error-syntax kaocha-tap
                                    "^not ok.*(\\([^:]*\\):\\([0-9]*\\))$"
                                    (1 "src/%s" "test/%s") 2)
          (compile-add-error-syntax kaocha-fail
                                    ".*FAIL in.*(\\([^:]*\\):\\([0-9]*\\))$"
                                    (1 "src/%s" "test/%s") 2)
          (compile-add-error-syntax clojure-reflection-warning
                                    "^Reflection warning,[[:space:]]*\\([^:]+\\):\\([0-9]+\\):\\([0-9]+\\).*$"
                                    (1 "src/%s" "test/%s") 2 3)
          (compile-add-error-syntax clojure-syntax-error
                                    "^Syntax error macroexpanding at (\\([^:]+\\):\\([0-9]+\\):\\([0-9]+\\)).$"
                                    (1 "src/%s" "test/%s") 2 3)
          (compile-add-error-syntax lua-stacktrace
                                    "\\(?:^[[:space:]]+\\([^
        :]+\\):\\([[:digit:]]+\\):[[:space:]]+in.+$\\)"
                                    1 2)
          (compile-add-error-syntax fennel-compile-error
                                    "\\(?:^Compile error in[[:space:]]+\\([^:]+\\):\\([[:digit:]]+\\)$\\)"
                                    1 2)
          ))

          (setup dired
          (:also-load dired-x)
          (:straight dired-collapse
                dired-git-info
                dired-single
                dired-subtree
                diredfl
                dired+)
          (:option dired-recursive-copies 'always
                   dired-recursive-deletes 'always
                   dired-create-destination-dirs 'always
                   dired-do-revert-buffer t
                   dired-hide-details-hide-symlink-targets nil
                   dired-isearch-filenames 'dwim
                   delete-by-moving-to-trash t
                   dired-auto-revert-buffer t
                   dired-listing-switches "-Al"
                   ls-lisp-dirs-first t
                   dired-ls-F-marks-symlinks t
                   dired-clean-confirm-killing-deleted-buffers nil
                   dired-no-confirm '(byte-compile
                                      load chgrp chmod chown
                                      copy move hardlink symlink
                                      shell touch)
                   dired-dwim-target t)
          (:local-set truncate-lines t)
          (:bind
           "<backspace>" #'dired-up-directory
           "TAB" #'dired-subtree-cycle
           "i" #'dired-subtree-toggle
           ")" #'dired-git-info-mode
           "q" #'quit-window)
          (:hook #'dired-collapse-mode
                 #'dired-hide-details-mode
                 #'hl-line-mode)
          (:global "C-x C-j" #'dired-jump)
            (setq dired-recursive-copies 'top)
            (setq dired-recursive-deletes 'top)
            (diredfl-global-mode 1)
          )

        (setup executable
          (setq executable-prefix-env t)
          (:with-hook after-save-hook
            (:hook executable-make-buffer-file-executable-if-script-p)))

        (setup (:require goto-addr)
          (:with-mode prog-mode
            (:hook goto-address-prog-mode))
          (:with-mode text-mode
            (:hook goto-address-mode)))

        (setup (:require help-mode)
          (setq help-window-select t))

        (setup (:require recentf)
          (setq recentf-auto-cleanup 'mode)
          (setq recentf-exclude `(,#'/cache-dir-p
                                  "^/tmp/"
                                  "COMMIT_EDITMSG$"
                                  ".gz$"))
          (setq recentf-filename-handlers '(abbreviate-file-name))
          (setq recentf-max-menu-items 100)
          (setq recentf-max-saved-items nil)
          (recentf-mode 1)
          (run-at-time nil 120 (fn (quiet! (recentf-save-list))))
          (:with-hook kill-emacs-hook
            (:hook recentf-cleanup recentf-save-list)))

        (setup (:require savehist)
          (setq history-delete-duplicates t)
          (setq history-length t)
          (setq savehist-additional-variables
                '(extended-command-history
                  global-mark-ring
                  kill-ring
                  mark-ring
                  regexp-search-ring
                  search-ring))
          (setq savehist-autosave-interval 60)
          (setq savehist-file (/etc-file "history"))
          (setq savehist-save-minibuffer-history t)
          (savehist-mode 1))

        (setup (:require saveplace)
          (setq save-place-file (/etc-file "places"))
          (setq save-place-forget-unreadable-files nil)
          (save-place-mode 1))

        (setup (:require server)
          (unless (server-running-p)
            (server-start)))

        (setup (:require url)
          (setq url-cookie-file (/etc-file "url-cookies")))


        ) ;; end of +with-message

   (provide 'enfer-pkg-builtin)
   ;;; enfer-pkg-builtin.el ends here
#+end_src
** Utility package
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-util.el :noweb yes
:ID:       502d74d1-022e-4f86-a512-00cc0f156769
:END:

Setup utility packages
#+begin_src emacs-lisp
  ;;; enfer-pkg-util.el --- Utilities -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-utils>>

  (provide 'enfer-pkg-util)
  ;;; enfer-pkg-util.el ends here
#+end_src
** Emacs Editor Setup
:PROPERTIES:
:header-args: :tangle lisp/init-editor.el :noweb yes
:ID:       fb6a2518-a1da-442f-8eb5-e9326e219897
:END:

Setup Editor functions

#+begin_src emacs-lisp
  ;;; init-editor.el --- Editor  -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  (require 'init-elpa)
  (require 'init-kbd)
  (require 'lib-vcs)
  (require 'lib-string)

  (+with-message  "Editing functions"

    <<pkg-editor>>

    );; end of +with-message
  (provide 'init-editor)
   ;;; init-editor.el ends here
#+end_src
** Emacs UI Appearance
:PROPERTIES:
:header-args: :tangle lisp/init-ui.el :noweb yes
:ID:       e3e7b492-40ac-4c41-9597-abf9e91ca8f9
:END:

Setup UI

#+begin_src emacs-lisp
    ;;; init-ui.el --- UI Setup -*- lexical-binding: t -*-
    <<disclaimer>>
    ;;; Code:

    (+with-message  "frap UI!"

    <<pkg-ui>>

    )
    (provide 'init-ui)
     ;;; init-ui.el ends here
#+end_src
** Buffers
:PROPERTIES:
:header-args: :tangle lisp/init-buffer.el :noweb yes
:ID:       88f9dfdd-935b-4ecc-a218-d27176f7e643
:END:

Setup the Emacs buffer

#+begin_src emacs-lisp
  ;;; init-buffer.el --- Buffer Setup -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  (require 'config-path)
  (require 'init-kbd)

  (+with-message "Buffer setup"

  <<buffers>>
  )
  (provide 'init-buffer)
   ;;; init-buffer.el ends here
#+end_src

*** lib-buffer
:PROPERTIES:
:header-args: :tangle lisp/lib-buffer.el :noweb yes
:ID:       081b340c-6b34-4573-86c0-a1658a326077
:END:

Autoloads for buffers
#+begin_src emacs-lisp
    ;;; lib-buffer.el --- Utilities for working with Buffers -*- lexical-binding: t -*-
  <<disclaimer>>
    ;;; Code:

  ;;;###autoload
  (defun buffer-content (buffer-or-name)
    "Return content of BUFFER-OR-NAME.
  Resulting string is full of properties. Consider using
  `substring-no-properties':
    (substring-no-properties (buffer-content BUFFER-OR-NAME))"
    (with-current-buffer buffer-or-name
      (buffer-substring (point-min)
                        (point-max))))

  ;;;###autoload
  (defun buffer-lines (buffer-or-name)
    "Return lines of BUFFER-OR-NAME.
  Each line is a string with properties. Trailing newline character
  is not present."
    (buffer-lines-map buffer-or-name #'identity))

  ;;;###autoload
  (defun buffer-lines-map (buffer-or-name fn)
    "Call FN on each line of BUFFER-OR-NAME and return resulting list.
  As opposed to `buffer-lines-each', this function accumulates
  result.
  Each line is a string with properties. Trailing newline character
  is not present."
    (declare (indent 1))
    (with-current-buffer buffer-or-name
      (goto-char (point-min))
      (let ((result))
        (while (not (eobp))
          (setq
           result
           (cons
            (funcall fn (buffer-substring
                         (line-beginning-position)
                         (line-end-position)))
            result))
          (forward-line))
        (reverse result))))

  ;;;###autoload
  (defun buffer-lines-each (buffer-or-name fn)
    "Call FN on each line of BUFFER-OR-NAME.
  As opposed to `buffer-lines-map', this function does not
  accumulate any result and should used for side-effects.
  Each line is a string with properties. Trailing newline character
  is not present."
    (declare (indent 1))
    (with-current-buffer buffer-or-name
      (goto-char (point-min))
      (while (not (eobp))
        (funcall fn (buffer-substring
                     (line-beginning-position)
                     (line-end-position)))
        (forward-line))))

  ;;;###autoload
  (defun buffer-lines-each-t (buffer-or-name fn)
    "Call FN on each line of BUFFER-OR-NAME and replace it by result.
  Each line is a string with properties. Trailing newline character
  is not present."
    (declare (indent 1))
    (with-current-buffer buffer-or-name
      (goto-char (point-min))
      (let (l0 l1 s)
        (while (not (eobp))
          (setq l0 (line-beginning-position))
          (setq l1 (line-end-position))
          (setq s (buffer-substring l0 l1))
          (replace-region-contents l0 l1 (lambda () (funcall fn s)))
          (forward-line)))))

  ;;;###autoload
  (defun buffer-generate (name &optional unique inhibit-buffer-hooks)
    "Create and return a buffer with a name based on NAME.
  Unless UNIQUE, choose the buffer‚Äôs name using
  ‚Äògenerate-new-buffer-name‚Äô. Otherwise if buffer with NAME already
  exists, recreate it.
  See ‚Äòget-buffer-create‚Äô for the meaning of INHIBIT-BUFFER-HOOKS."
    (when unique
      (when-let ((buffer (get-buffer name)))
        (kill-buffer buffer)))
    (generate-new-buffer name inhibit-buffer-hooks))

  (provide 'lib-buffer)
  ;;; lib-buffer.el ends here

#+end_src
** Emacs Completion Frameworks
:PROPERTIES:
:header-args: :tangle lisp/init-selection.el :noweb yes
:ID:       364ebd72-5f4a-4c3d-9883-836916245ef8
:END:

Setup embark, vertico and consult


#+begin_src emacs-lisp
  ;;; init-selection.el --- Completion -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  (+with-message "Completion or Selection"

  <<pkg-completion>>

  )
  (provide 'init-selection)
   ;;; init-selection.el ends here
#+end_src
** Emacs Windows
:PROPERTIES:
:header-args: :tangle lisp/init-window.el :noweb yes
:ID:       dff15b7b-84eb-4992-b32f-716a3b47c36a
:END:

windose

#+begin_src emacs-lisp
  ;;; init-window.el --- Windose -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  (+with-message "Windose(w)"
  <<windose>>
  )
  (provide 'init-window)
   ;;; init-window.el ends here
#+end_src
** Projects
:PROPERTIES:
:header-args: :tangle lisp/init-project.el :noweb yes
:ID:       66274ebe-f4ac-4bc6-ba63-89dfc122e18e
:END:

Setup projects


#+begin_src emacs-lisp
  ;;; init-project.el --- Projects -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

(require 'lib-eval)
(require 'config-path)
(require 'init-vcs)
(require 'init-kbd)
(require 'project)
  (+with-message "Projets"

    <<projet>>

    )

  (provide 'init-project)
 ;;; init-project.el ends here
#+end_src
** VCS
:PROPERTIES:
:header-args: :tangle lisp/init-vcs.el :noweb yes
:ID:       17898bf9-267b-4ce2-9cde-37fcdec5cf13
:END:

Setup Magit & Git

#+begin_src emacs-lisp
  ;;; init-vcs.el --- Magit  -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  ;;(require 'lib-hook)
  (require 'config-path)
  (require 'init-elpa)
  (+with-message "Git.."

    <<vcs>>

    )

  (provide 'init-vcs)
;;; init-vcs.el ends here
#+end_src
** Org mode workflow
:PROPERTIES:
:header-args: :tangle lisp/init-notes.el :noweb yes
:ID:       324cd406-d1af-4262-a7e1-8afab24f987c
:END:

Setup org-mode

#+begin_src emacs-lisp
  ;;; init-notes.el --- Org/Roam Workflow -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:
  (require 'config-path)
  (require 'init-elpa)
  (require 'init-env)
  (require 'init-selection)
  (require  'config-orgmode)

  (+with-message "Notes/Roam Workflow"

  <<pkg-org>>

  )
  (provide 'init-notes)
   ;;; init-notes.el ends here
#+end_src

*** Vulpea Setup
:PROPERTIES:
:header-args: :tangle lisp/lib-vulpea.el :noweb yes
:ID:       d6e1bd4d-dbb6-4a19-8e8a-e26a97053ccb
:END:
#+begin_src emacs-lisp
;;; lib-vulpea.el --- Vulpea utilities -*- lexical-binding: t; -*-
<<disclaimer>>
(require 'init-elpa)

(require 'config-orgmode)
(require 'lib-directory)
(require 'lib-litnotes)

(require 'vulpea)
(require 'org-roam)
(require 'org-roam-db)
(require 'org-roam-dailies)

(defun vulpea-buffer-p ()
  "Return non-nil if the currently visited buffer is a note."
  (and buffer-file-name
       (eq major-mode 'org-mode)
       (string-suffix-p "org" buffer-file-name)
       (string-prefix-p
        (expand-file-name (file-name-as-directory vulpea-directory))
        (file-name-directory buffer-file-name))))



(defun vulpea-project-p ()
  "Return non-nil if current buffer has any todo entry.
TODO entries marked as done are ignored, meaning the this
function returns nil if current buffer contains only completed
tasks. The only exception is headings tagged as REFILE."
  (org-element-map
      (org-element-parse-buffer 'headline)
      'headline
    (lambda (h)
      (or (eq 'todo (org-element-property :todo-type h))
          (seq-contains-p (org-element-property :tags h)
                          "REFILE")))
    nil 'first-match))

;;;###autoload
(defun vulpea-project-files ()
  "Return a list of note files containing 'projet' tag." ;
  (seq-uniq
   (seq-map
    #'car
    (org-roam-db-query
     [:select [nodes:file]
      :from tags
      :left-join nodes
      :on (= tags:node-id nodes:id)
      :where (like tag (quote "%\"projet\"%"))]))))



;;;###autoload
(defun vulpea-insert-handle (note)
  "Hook to be called on NOTE after `vulpea-insert'."
  (when-let* ((title (vulpea-note-title note))
              (tags (vulpea-note-tags note)))
    (when (seq-contains-p tags "people")
      (save-excursion
        (ignore-errors
          (org-back-to-heading)
          (when (eq 'todo (org-element-property
                           :todo-type
                           (org-element-at-point)))
            (org-set-tags
             (seq-uniq
              (cons
               (vulpea--title-to-tag title)
               (org-get-tags nil t))))))))))



;;;###autoload
(defun vulpea-tags-add ()
  "Add a tag to current note."
  (interactive)
  (org-with-point-at 1
    (when (call-interactively #'org-roam-tag-add)
      (vulpea-ensure-filetag))))

;;;###autoload
(defun vulpea-tags-delete ()
  "Delete a tag from current note."
  (interactive)
  (call-interactively #'org-roam-tag-remove))

;;;###autoload
(defun vulpea-ensure-filetag ()
  "Add missing FILETAGS to the current note."
  (let* ((file (buffer-file-name))
         (path-tags
          (when file
            (seq-filter
             (lambda (x) (not (string-empty-p x)))
             (split-string
              (string-remove-prefix
               vulpea-directory
               (file-name-directory file))
              "/"))))
         (original-tags (vulpea-buffer-tags-get))
         (tags (append original-tags path-tags)))

    ;; process people
    (when (seq-contains-p tags "people")
      (let ((tag (vulpea--title-as-tag)))
        (unless (seq-contains-p tags tag)
          (setq tags (cons tag tags)))))

    ;; process litnotes
    (setq tags (litnotes-ensure-filetags tags))

    ;; process projects
    (if (vulpea-project-p)
        (setq tags (cons "projet" tags))
      (setq tags (remove "projet" tags)))

    (setq tags (seq-uniq tags))

    ;; update tags if changed
    (when (or (seq-difference tags original-tags)
              (seq-difference original-tags tags))
      (apply #'vulpea-buffer-tags-set (seq-uniq tags)))))



;;;###autoload
(defun vulpea-alias-add ()
  "Add an alias to current note."
  (interactive)
  (call-interactively #'org-roam-alias-add))

;;;###autoload
(defun vulpea-alias-delete ()
  "Delete an alias from current note."
  (interactive)
  (call-interactively #'org-roam-alias-remove))

;;;###autoload
(defun vulpea-alias-extract ()
  "Extract an alias from current note as a separate note.
Make all the links to this alias point to newly created note."
  (interactive)
  (if-let* ((node (org-roam-node-at-point 'assert))
            (aliases (org-roam-node-aliases node)))
      (let* ((alias (completing-read
                     "Alias: " aliases nil 'require-match))
             (backlinks (seq-map
                         #'org-roam-backlink-source-node
                         (org-roam-backlinks-get node)))
             (id-old (org-roam-node-id node)))
        (org-roam-alias-remove alias)
        (org-roam-db-update-file (org-roam-node-file node))
        (let* ((note (vulpea-create
                      alias
                      "%<%Y%m%d%H%M%S>-${slug}.org"
                      :immediate-finish t
                      :unnarrowed t)))
          (seq-each
           (lambda (node)
             (vulpea-utils-with-file (org-roam-node-file node)
               (goto-char (point-min))
               (let ((link-old
                      (org-link-make-string
                       (concat "id:" id-old)
                       alias))
                     (link-new
                      (vulpea-utils-link-make-string note)))
                 (while (search-forward link-old nil 'noerror)
                   (replace-match link-new))))
             (org-roam-db-update-file (org-roam-node-file node)))
           backlinks)))
    (user-error "Pas d'alias √† extraire")))



;;;###autoload
(defun vulpea-setup-buffer (&optional _)
  "Setup current buffer for notes viewing and editing."
  (when (and (not (active-minibuffer-window))
             (vulpea-buffer-p))
    (org-with-point-at 1
      (org-hide-drawer-toggle 'off))
    (setq-local tab-width 1)
    (vulpea-ensure-filetag)))

;;;###autoload
(defun vulpea-pre-save-hook ()
  "Do all the dirty stuff when file is being saved."
  (when (and (not (active-minibuffer-window))
             (vulpea-buffer-p))
    (vulpea-ensure-filetag)))



;;;###autoload
(defun vulpea-dailies-today ()
  "Find a daily note for today."
  (interactive)
  (org-roam-dailies-goto-today))

;;;###autoload
(defun vulpea-dailies-date ()
  "Find a daily note for date specified using calendar."
  (interactive)
  (org-roam-dailies-goto-date))

;;;###autoload
(defun vulpea-dailies-prev ()
  "Find a daily note that comes before current."
  (interactive)
  (org-roam-dailies-goto-previous-note))

;;;###autoload
(defun vulpea-dailies-next ()
  "Find a daily note that comes after current."
  (interactive)
  (org-roam-dailies-goto-next-note))



;;;###autoload
(defun vulpea-db-build ()
  "Update notes database."
  (when (file-directory-p vulpea-directory)
    (org-roam-db-sync)
    (org-roam-update-org-id-locations)))



;;;###autoload
(defun vulpea-subdir-select ()
  "Select notes subdirectory."
  (interactive)
  (let ((dirs (cons
               "."
               (seq-map
                (lambda (p)
                  (string-remove-prefix vulpea-directory p))
                (directory-subdirs vulpea-directory 'recursive)))))
    (completing-read "Subdir: " dirs nil t)))



(defun vulpea--title-as-tag ()
  "Return title of the current note as tag."
  (vulpea--title-to-tag (vulpea-buffer-prop-get "title")))

(defun vulpea--title-to-tag (title)
  "Convert TITLE to tag."
  (concat "@" (s-replace " " "" title)))



;;;###autoload
;; org-check-agenda-file
(defun vulpea-check-agenda-file (&rest _)
  "A noop advice for `org-check-agenda-file'.
Since this function is called from multiple places, it is very
irritating to answer this question every time new note is created.
Also, it doesn't matter if the file in question is present in the
list of `org-agenda-files' or not, since it is built dynamically
via `vulpea-agenda-files-update'.")



;;;###autoload
(defun vulpea-activate-link (start end path _brackets)
  "Activate a link between START and END for PATH."
  (let ((visible-start (or (match-beginning 3)
                           (match-beginning 2)))
        (visible-end (or (match-end 3) (match-end 2))))
    (when-let* ((uuid-p (string-match-p string-uuid-regexp path))
                (note (vulpea-db-get-by-id path))
                (tags (vulpea-note-tags note))
                (icon (cond
                       ((seq-contains-p tags litnotes-tag)
                        (litnotes-content-display
                         (litnotes-entry-content
                          (litnotes-entry note))
                         :height 0.8 :v-adjust 0.04))
                       ((seq-contains-p tags "people")
                        (concat
                         (all-the-icons-material
                          "person" :height 0.8 :v-adjust 0.04)
                         "\t"))
                       ((seq-contains-p tags "grape")
                        (concat "üçá" "\t"))
                       ((seq-contains-p tags "cellar")
                        (concat "üç∑" "\t"))
                       ((seq-contains-p tags "aroma")
                        (concat
                         (all-the-icons-material
                          "local_florist" :height 0.8 :v-adjust 0.04)
                         "\t"))))
                (desc (buffer-substring visible-start visible-end))
                (desc (concat icon desc))
                (desc (s-truncate (- end start) desc))
                (l (length desc))
                (hidden `(invisible
                          ,(or (org-link-get-parameter "id" :display)
                               'org-link))))
      (remove-text-properties start visible-start hidden)
      (remove-text-properties visible-end end hidden)
      (add-text-properties (+ start l) end hidden)
      (put-text-property start end 'display desc))))



(provide 'lib-vulpea)
;;; lib-vulpea.el ends here
#+end_src

*** Directory Utilities
:PROPERTIES:
:header-args: :tangle lisp/lib-directory.el :noweb yes
:ID:       d3d0dbea-9c32-46ca-a0be-0a0676bf748a
:END:
#+begin_src emacs-lisp
;;; lib-directory.el --- Directory utilities -*- lexical-binding: t; -*-
<<disclaimer>>
;;; Commentary:
;;
;; Various utilities for files and directories.
;;
;;; Code:

(defun directory-subdirs (directory &optional rec)
  "Return subdirs or files of DIRECTORY.
If REC is non-nil then do recursive search."
  (let ((res
         (seq-map
          #'file-name-as-directory
          (seq-remove
           (lambda (file)
             (or (string-match "\\`\\."
                               (file-name-nondirectory file))
                 (string-match "\\`#.*#\\'"
                               (file-name-nondirectory file))
                 (string-match "~\\'"
                               (file-name-nondirectory file))
                 (not (file-directory-p file))))
           (directory-files directory t)))))
    (if rec
        (apply
         #'append
         (seq-map (lambda (p) (cons p (directory-subdirs p)))
                  res))
      res)))

(provide 'lib-directory)
;;; lib-directory.el ends here
#+end_src
*** Literature Notes
:PROPERTIES:
:header-args: :tangle lisp/lib-litnotes.el :noweb yes
:ID:                     7b61e449-59c1-4bf8-a3b4-464f9d9b4306
:END:
#+begin_src emacs-lisp
;;; lib-litnotes.el --- Utilities for working with litnotes -*- lexical-binding: t; -*-
<<disclaimer>>
;;; Commentary:
;;
;; This module provides various utilities for viewing and managing
;; litnotes.
;;
;;; Code:

(require 'vulpea)
(require 'lister)
(require 'lister-highlight)
(require 'all-the-icons)



(defconst litnotes-tag "litnotes"
  "Tag of all them litnotes.")



(defface litnotes-group-title-face
  '((t (:inherit org-roam-header-line)))
  "Face for displaying group title."
  :group 'litnotes)

(defface litnotes-group-counter-face
  '((t (:inherit font-lock-comment-face)))
  "Face for displaying group counter."
  :group 'litnotes)

(defface litnotes-entry-title-face
  '((t (:inherit org-document-title)))
  "Face for displaying entry title."
  :group 'litnotes)

(defface litnotes-entry-authors-face
  '((t (:inherit font-lock-comment-face)))
  "Face for displaying entry authors."
  :group 'litnotes)



(defvar litnotes-status-values '("ongoing" "new" "done" "dropped")
  "List with all valid values of status.")

(defun litnotes-status-compare (a b)
  "Compare status A with status B."
  (< (seq-position litnotes-status-values a)
     (seq-position litnotes-status-values b)))

(defun litnotes-status-display (status &rest icon-args)
  "Display STATUS.
ICON-ARGS are properties that are passed to `all-the-icons'
functions. You may use it to pass :height and :v-adjust."
  (let ((icon-fn (pcase status
                   (`"ongoing" #'all-the-icons-faicon)
                   (`"new" #'all-the-icons-faicon)
                   (`"done" #'all-the-icons-faicon)
                   (`"dropped" #'all-the-icons-faicon)))
        (icon-name (pcase status
                     (`"ongoing" "spinner")
                     (`"new" "inbox")
                     (`"done" "check")
                     (`"dropped" "times"))))
    (if (featurep 'all-the-icons)
        (concat
         (apply icon-fn icon-name icon-args)
         ;; this way we align everything horizontally
         "\t"
         status)
      "")))

(defconst litnotes-status-tag-prefix "status/"
  "Prefix of the status tag.")

(defun litnotes-status-to-tag (status)
  "Return a tag representing STATUS."
  (concat litnotes-status-tag-prefix status))

(defun litnotes-status-from-tag (tag)
  "Return a status representing as TAG."
  (string-remove-prefix litnotes-status-tag-prefix tag))

(defun litnotes-status-tag-p (tag)
  "Return non-nil when TAG represents a status."
  (string-prefix-p litnotes-status-tag-prefix tag))

(defun litnotes-status-read (&optional old-status)
  "Read a status excluding OLD-STATUS."
  (completing-read
   "Status: "
   (-remove-item old-status litnotes-status-values)))



(defvar litnotes-content-types '("book"
                                 "article"
                                 "video"
                                 "course"
                                 "game")
  "List with all valid content types.")

(defun litnotes-content-compare (a b)
  "Compare content A with content B."
  (< (seq-position litnotes-content-types a)
     (seq-position litnotes-content-types b)))

(defun litnotes-content-display (content &rest icon-args)
  "Display CONTENT.
ICON-ARGS are properties that are passed to `all-the-icons'
functions. You may use it to pass :height and :v-adjust."
  (let ((icon-fn (pcase content
                   (`"book" #'all-the-icons-material)
                   (`"article" #'all-the-icons-material)
                   (`"video" #'all-the-icons-material)
                   (`"game" #'all-the-icons-material)
                   (`"course" #'all-the-icons-material)))
        (icon-name (pcase content
                     (`"book" "local_library")
                     (`"article" "insert_drive_file")
                     (`"video" "videocam")
                     (`"game" "videogame_asset")
                     (`"course" "school"))))
    (if (featurep 'all-the-icons)
        (concat
         (apply icon-fn icon-name icon-args)
         ;; this way we align everything horizontally
         "\t")
      "")))

(defconst litnotes-content-tag-prefix "content/"
  "Prefix of the content tag.")

(defun litnotes-content-to-tag (content)
  "Return a tag representing CONTENT."
  (concat litnotes-content-tag-prefix content))

(defun litnotes-content-from-tag (tag)
  "Return a content representing as TAG."
  (string-remove-prefix litnotes-content-tag-prefix tag))

(defun litnotes-content-tag-p (tag)
  "Return non-nil when TAG represents a content."
  (string-prefix-p litnotes-content-tag-prefix tag))



(cl-defstruct litnotes-entry
  note
  title
  status
  content
  authors)

(defun litnotes-entry (note)
  "Create a `litnotes-entry' from NOTE."
  (make-litnotes-entry
   :note note
   :title (vulpea-note-title note)
   :status (litnotes-status-from-tag
            (seq-find
             #'litnotes-status-tag-p
             (vulpea-note-tags note)))
   :content (string-remove-prefix
             "content/"
             (seq-find
              (lambda (x)
                (string-prefix-p "content/" x))
              (vulpea-note-tags note)))
   :authors (vulpea-note-meta-get-list note "authors" 'note)))

(defun litnotes-entry-compare (a b)
  "Compare entries A and B by title."
  (string< (litnotes-entry-title a)
           (litnotes-entry-title b)))

(defun litnotes-entry-visit (entry &optional other-window)
  "Visit a litnote ENTRY possible in OTHER-WINDOW."
  (org-roam-node-visit
   (org-roam-node-from-id
    (vulpea-note-id (litnotes-entry-note entry)))
   other-window))



(defun litnotes-entries ()
  "Fetch a list of `litnotes-entry' entries."
  (seq-map
   #'litnotes-entry
   (seq-remove
    #'vulpea-note-primary-title
    (vulpea-db-query
     (lambda (x)
       (seq-contains-p (vulpea-note-tags x)
                       litnotes-tag))))))



(defvar-local litnotes-buffer-data nil
  "Associative list of all litnotes grouped by status.")

;;;###autoload
(define-derived-mode litnotes-mode
  lister-mode "litnotes"
  "Major mode for browsing litnotes."
  (lister-setup (current-buffer) #'litnotes-buffer-mapper))

(defconst litnotes-mode-map
  (let ((map (make-sparse-keymap)))
    ;; inherit standard key bindings:
    (set-keymap-parent map lister-mode-map)
    (define-key map "\t"          #'litnotes-buffer-expand)
    (define-key map (kbd "<RET>") #'litnotes-buffer-visit)
    (define-key map (kbd "g")     #'litnotes-buffer-refresh)
    (define-key map (kbd "s")     #'litnotes-buffer-set-status)
    map)
  "Key map for `litnotes-mode'.")

;;;###autoload
(defun litnotes ()
  "Display a list of litnotes."
  (interactive)
  (let* ((name "*litnotes*")
         (buffer (buffer-generate name 'unique)))
    (with-current-buffer buffer
      (litnotes-mode)
      (setq litnotes-buffer-data (litnotes-buffer-data))
      (setq-local tab-width 4)
      (lister-highlight-mode 1)
      (lister-insert-sequence
       buffer (point) litnotes-status-values)
      (lister-goto buffer :first)
      (litnotes-buffer-expand-sublist buffer (point)))
    (switch-to-buffer buffer)))

(defun litnotes-buffer-data ()
  "Get data for litnotes buffer."
  (seq-sort-by
   #'car
   #'litnotes-status-compare
   (seq-group-by #'litnotes-entry-status
                 (seq-sort
                  #'litnotes-entry-compare
                  (litnotes-entries)))))

(defun litnotes-buffer-mapper (data)
  "DATA mapper for `litnotes-mode'."
  (if (stringp data)
      (concat
       (propertize
        (litnotes-status-display data)
        'face 'litnotes-group-title-face)
       " "
       (propertize
        (concat "("
                (number-to-string
                 (length (cdr (assoc data litnotes-buffer-data))))
                ")")
        'face 'litnotes-group-counter-face))
    (concat
     (litnotes-content-display
      (litnotes-entry-content data))
     (propertize
      (litnotes-entry-title data)
      'face 'litnotes-entry-title-face)
     (when (litnotes-entry-authors data)
       (concat
        " by "
        (string-join
         (seq-map
          (lambda (note)
            (propertize
             (vulpea-note-title note)
             'face 'litnotes-entry-authors-face))
          (litnotes-entry-authors data))
         ", "))))))

(defun litnotes-buffer-groups-refresh (buffer)
  "Refresh groups in litnotes BUFFER."
  (lister-walk-all
   buffer
   (lambda (data)
     (lister-replace buffer (point) data))
   #'stringp))

(defun litnotes-buffer-refresh ()
  "Refresh litnotes buffer."
  (interactive)
  (let ((pos (point)))
    (litnotes)
    (goto-char pos)))

(defun litnotes-buffer-expand (buffer pos)
  "Perform expansion on item at POS in litnotes BUFFER."
  (interactive (list (current-buffer) (point)))
  (let ((item (lister-get-data buffer pos)))
    (cond
     ((litnotes-entry-p item)
      (litnotes-entry-visit item 'other-window))

     ((ignore-errors (lister-sublist-below-p buffer pos))
      (lister-remove-sublist-below buffer pos))

     (t (litnotes-buffer-expand-sublist buffer pos)))))

(defun litnotes-buffer-expand-sublist (buffer pos)
  "Expand litnotes in the current list.
BUFFER must be a valid lister buffer populated with litnotes
items. POS can be an integer or the symbol `:point'."
  (interactive (list (current-buffer) (point)))
  (let* ((position
          (pcase pos
            ((and (pred integerp) pos) pos)
            (:point (with-current-buffer buffer (point)))
            (_ (error "Valeur invalide pour POS: %s" pos))))
         (item (lister-get-data buffer position))
         (sublist (cdr (assoc item litnotes-buffer-data))))
    (if sublist
        (with-temp-message "Insertion des r√©sultats d'expansion..."
          (lister-insert-sublist-below buffer position sublist))
      (user-error "Aucune extension trouv√©e"))))

(defun litnotes-buffer-visit (buffer pos)
  "Visit a litnote at POS from BUFFER."
  (interactive (list (current-buffer) (point)))
  (let* ((item (lister-get-data buffer pos)))
    (if (litnotes-entry-p item)
        (litnotes-entry-visit item)
      (user-error "Not a litnote"))))

(defun litnotes-buffer-set-status ()
  "Set status of a litnote at point."
  (interactive)
  (let* ((buffer (current-buffer))
         (pos (point))
         (item (lister-get-data buffer pos)))
    (if (litnotes-entry-p item)
        (let* ((old-status (litnotes-entry-status item))
               (status (litnotes-status-read old-status))
               (note (litnotes-entry-note item))
               (file (vulpea-note-path note)))
          (vulpea-utils-with-file file
            (litnotes-status-set status))
          (setf (litnotes-entry-status item) status)
          (setq litnotes-buffer-data
                (litnotes-buffer-data-change-group
                 item old-status status))
          (litnotes-buffer-change-group buffer pos item status)
          (litnotes-buffer-groups-refresh buffer))
      (user-error "Not a litnote"))))

(defun litnotes-buffer-change-group (buffer pos item new-group)
  "Move ITEM at POS to NEW-GROUP in litnotes BUFFER."
  ;; basically, remove whatever is in point
  (lister-remove buffer pos)

  ;; add to new group if it's expanded
  (lister-walk-all
   buffer
   (lambda (_)
     (let ((pos (point)))
       (when (ignore-errors
               (lister-sublist-below-p buffer pos))
         (let* ((next-item (lister-end-of-lines buffer pos))
                (next-level (lister-get-level-at buffer next-item)))
           (lister-insert
            buffer
            next-item
            item
            next-level)))))
   (lambda (data)
     (and (stringp data)
          (string-equal new-group data)))))

(defun litnotes-buffer-data-change-group (item old-group new-group)
  "Move ITEM from OLD-GROUP to NEW-GROUP in cached data."
  (seq-map
   (lambda (kvs)
     (cond
      ((string-equal old-group (car kvs))
       (cons (car kvs)
             (seq-remove
              (lambda (x)
                (string-equal
                 (vulpea-note-id (litnotes-entry-note x))
                 (vulpea-note-id (litnotes-entry-note item))))
              (cdr kvs))))
      ((string-equal new-group (car kvs))
       (cons (car kvs)
             (cons item (cdr kvs))))
      (t kvs)))
   litnotes-buffer-data))

;; TODO: add filtering
;; TODO: add other groupings



;;;###autoload
(defun litnotes-ensure-filetags (tags)
  "Ensure that TAGS contain the right set of tags."
  (when (seq-contains-p tags litnotes-tag)
    (unless (seq-find #'litnotes-status-tag-p tags)
      (setq tags (cons (litnotes-status-to-tag "new") tags)))
    (unless (seq-find #'litnotes-content-tag-p tags)
      (setq tags (cons
                  (litnotes-content-to-tag
                   (completing-read
                    "Content:"
                    litnotes-content-types))
                  tags))))
  tags)



;;;###autoload
(defun litnotes-status-set (&optional status)
  "Change STATUS tag of the current litnote."
  (interactive)
  (when-let*
      ((file (buffer-file-name (buffer-base-buffer)))
       (id (vulpea-db-get-id-by-file file))
       (tags (vulpea-buffer-tags-get))
       (old-status (litnotes-status-from-tag
                    (seq-find #'litnotes-status-tag-p tags)))
       (status (or status (litnotes-status-read old-status)))
       (new-tags (litnotes-tags-set-status tags status)))
    (vulpea-buffer-prop-set-list "filetags" new-tags)
    (org-time-stamp-format (current-time) 'interactive)
    (unless (vulpea-meta-get id "added")
      (vulpea-meta-set
       id "added"
       (litnotes-format-time (current-time) t 'inactive)
       'append))
    (pcase status
      (`"ongoing"
       (vulpea-meta-remove id "completed")
       (vulpea-meta-remove id "dropped")
       (vulpea-meta-set
        id "started"
        (litnotes-format-time (current-time) 'with-hm 'inactive)
        'append))
      (`"done"
       (vulpea-meta-remove id "dropped")
       (vulpea-meta-set
        id "completed"
        (litnotes-format-time (current-time) 'with-hm 'inactive)
        'append))
      (`"dropped"
       (vulpea-meta-remove id "completed")
       (vulpea-meta-set
        id "dropped"
        (litnotes-format-time (current-time) 'with-hm 'inactive)
        'append)))
    (org-roam-db-update-file file)
    (save-buffer)))



(defun litnotes-tags-set-status (tags status)
  "Add STATUS to TAGS and return result.
STATUS is converted into proper tag, an any other status tag is
removed from TAGS."
  (cons
   (litnotes-status-to-tag status)
   (seq-remove
    #'litnotes-status-tag-p
    tags)))



(defun litnotes-format-time (time &optional with-hm inactive extra)
  "Format a date stamp for the date given by the internal TIME.
See `format-time-string' for the format of TIME.
WITH-HM means use the stamp format that includes the time of the
day.
INACTIVE means use square brackets instead of angular ones, so
that the stamp will not contribute to the agenda.
EXTRA is unknown thing."
  (let ((fmt (funcall (if with-hm 'cdr 'car)
                      org-time-stamp-formats)))
    (when inactive
      (setq fmt (concat "[" (substring fmt 1 -1) "]")))
    (when (listp extra)
      (setq extra (car extra))
      (if (and (stringp extra)
               (string-match "\\([0-9]+\\):\\([0-9]+\\)" extra))
          (setq extra (format
                       "-%02d:%02d"
                       (string-to-number (match-string 1 extra))
                       (string-to-number (match-string 2 extra))))
        (setq extra nil)))
    (when extra
      (setq fmt (concat (substring fmt 0 -1)
                        extra
                        (substring fmt -1))))
    (concat (format-time-string fmt time))))



(provide 'lib-litnotes)
;;; lib-litnotes.el ends here
#+end_src
*** Vulpea Refile
:PROPERTIES:
:header-args: :tangle lisp/lib-vulpea-refile.el :noweb yes
:ID:       444211ec-1ebc-4afd-abc3-9178b246808f
:END:
#+begin_src emacs-lisp
;;; lib-vulpea-refile.el --- Note refiling utilities -*- lexical-binding: t; -*-
<<disclaimer>>
;;; Commentary:
;;
;; This module provides utilities for refiling vulpea notes.
;;
;;; Code:

(require 'org)

(defvar vulpea-refile-ignored-tags '("JOURNAL" "REFILE")
  "List of tags to ignore during refile.")

;;;###autoload
(defun vulpea-refile-verify-target ()
  "Exclude todo keywords with a done state from refile targets."
  (let ((tags-at (org-get-tags)))
    (and
     ;; doesn't have done keyword
     (not (member (nth 2 (org-heading-components)) org-done-keywords))

     ;; doesn't have blacklisted tag
     (or (null tags-at)
         (cl-member-if-not
          (lambda (x)
            (member (if (listp x) (car x) x)
                    vulpea-refile-ignored-tags))
          tags-at)))))

(provide 'lib-vulpea-refile)
;;; lib-vulpea-refile.el ends here
#+end_src
*** Vulpea Capture
:PROPERTIES:
:header-args: :tangle lisp/lib-vulpea-capture.el :noweb yes
:ID:       6098e5d7-4526-4010-804f-b32a0f22fd0c
:END:
#+begin_src emacs-lisp
;;; lib-vulpea-capture.el --- Capturing tasks and notes -*- lexical-binding: t; -*-
<<disclaimer>>
;;; Commentary:
;;
;; Various utilities for capturing tasks and notes.
;;
;;; Code:

(require 'init-env)
(require 'config-orgmode)
(require 'lib-fun)

;; external dependencies
(require 'vulpea)
(require 'org)
(require 'org-capture)
(require 'org-roam)
(require 'org-cliplink)

(defvar vulpea-capture-inbox-file
  "inbox.org"   ;; (format "inbox-%s.org" env-sys-name)
  "The path to the inbox file.
It is relative to `vulpea-directory', unless it is absolute.")

;;;###autoload
(defun vulpea-capture-setup ()
  "Wire all bits for capturing."
  (dolist (var '(vulpea-capture-inbox-file))
    (set var (expand-file-name (symbol-value var) vulpea-directory)))
  (unless org-default-notes-file
    (setq org-default-notes-file vulpea-capture-inbox-file))
  (setq
   org-capture-templates
   '(("t" "todo" plain (file vulpea-capture-inbox-file)
      "* TODO %?\n%U\n" :clock-in t :clock-resume t)

     ("m" "Reunion" entry
      (function vulpea-capture-meeting-target)
      (function vulpea-capture-meeting-template)
      :clock-in t
      :clock-resume t))
   org-roam-capture-templates
   '(("d" "default" plain "%?"
      :if-new (file+head
               "%(vulpea-subdir-select)/%<%Y%m%d%H%M%S>-${slug}.org"
               "#+title: ${title}\n\n")
      :unnarrowed t))
   org-roam-dailies-capture-templates
   `(("d" "default" entry
      "* %<%H:%M>\n\n%?"
      :if-new (file+head
               ,(expand-file-name "%<%Y-%m-%d>.org"
                                  org-roam-dailies-directory)
               ,(string-join '("#+title: %<%A, %d %B %Y>"
                               "#+filetags: journal"
                               "\n")
                             "\n"))))))

;;;###autoload
(defun vulpea-capture-task ()
  "Capture a task."
  (interactive)
  (org-capture nil "t"))

(defun vulpea-capture-meeting ()
  "Capture a meeting."
  (interactive)
  (org-capture nil "m"))

(defun vulpea-capture-meeting-target ()
  "Return a target for a meeting capture."
  (let ((person (org-capture-get :meeting-person)))
    ;; unfortunately, I could not find a way to reuse
    ;; `org-capture-set-target-location'
    (if (vulpea-note-id person)
        (let ((path (vulpea-note-path person))
              (headline "Reuniones"))
          (set-buffer (org-capture-target-buffer path))
          ;; Org expects the target file to be in Org mode, otherwise
          ;; it throws an error. However, the default notes files
          ;; should work out of the box. In this case, we switch it to
          ;; Org mode.
          (unless (derived-mode-p 'org-mode)
            (org-display-warning
             (format
              "Capture requirement: switching buffer %S to Org mode"
              (current-buffer)))
            (org-mode))
          (org-capture-put-target-region-and-position)
          (widen)
          (goto-char (point-min))
          (if (re-search-forward
               (format org-complex-heading-regexp-format
                       (regexp-quote headline))
               nil t)
              (beginning-of-line)
            (goto-char (point-max))
            (unless (bolp) (insert "\n"))
            (insert "* " headline "\n")
            (beginning-of-line 0)))
      (let ((path vulpea-capture-inbox-file))
        (set-buffer (org-capture-target-buffer path))
        (org-capture-put-target-region-and-position)
        (widen)))))

(defun vulpea-capture-meeting-template ()
  "Return a template for a meeting capture."
  (let ((person (vulpea-select-from
                 "Person"
                 (vulpea-db-query-by-tags-every '("people")))))
    (org-capture-put :meeting-person person)
    (if (vulpea-note-id person)
        "* R√âUNION [%<%Y-%m-%d %a>] :REFILE:R√âUNION:\n%U\n\n%?"
      (concat "* R√âUNION avec "
              (vulpea-note-title person)
              " on [%<%Y-%m-%d %a>] :R√âUNION:\n%U\n\n%?"))))

;;;###autoload
(defun vulpea-capture-article ()
  "Capture an article using `vulpea-capture-article-template'.
User is asked to provide an URL, title and authors of the article
being captured.
Title is inferred from URL, but user may edit it.
Stored under roam-directory/litnotes
Authors can be created on the fly. See
`vulpea-capture-person-template' for more information."
  (interactive)
  (when-let*
      ((url (read-string "URL: "))
       (title (org-cliplink-retrieve-title-synchronously url))
       (title (read-string "Title: " title))
       (people (fun-collect-while
                (lambda ()
                  (let ((person
                         (vulpea-select-from
                          "Person"
                          (vulpea-db-query-by-tags-every '("people")))))
                    (if (vulpea-note-id person)
                        person
                      (vulpea-create
                       (vulpea-note-title person)
                       "people/%<%Y%m%d%H%M%S>-${slug}.org"
                       :immediate-finish t))))
                nil))
       (note (vulpea-crea
              title
              "litnotes/%<%Y%m%d%H%M%S>-${slug}.org"
              :tags '("litnotes" "content/article")
              :properties (list (cons "ROAM_REFS" url))
              :immediate-finish t)))
    (vulpea-meta-set note "authors" people t)
    (find-file (vulpea-note-path note))
    (litnotes-status-set "new")
    (save-buffer)))

(defun vulpea-capture-journal ()
  "Capture a journal entry.
By default it uses current date to find a daily. With
\\[universal-argument] user may select the date."
  (interactive)
  (cond
   ((equal current-prefix-arg '(4))     ; select date
    (org-roam-dailies-capture-date))
   (t
    (org-roam-dailies-capture-today))))

(provide 'lib-vulpea-capture)
;;; lib-vulpea-capture.el ends here
#+end_src
*** Vulpea Agenda
:PROPERTIES:
:header-args: :tangle lisp/lib-vulpea-agenda.el :noweb yes
:ID:       53e78065-65e3-435a-a63c-222e5470e9a2
:END:
#+begin_src emacs-lisp
   ;;; lib-vulpea-agenda.el --- Utilities for building agenda -*- lexical-binding: t; -*-
   ;;; Commentary:
   ;;
   ;; This module provides various utilities for building agenda buffer.
   ;;
   ;;; Code:

   (require 'init-elpa)
   (require 'lib-vulpea)
   (require 'lib-compat)

   (require 'org)
   (require 'org-habit)
   (require 'vulpea)

   

   (defvar vulpea-agenda-hide-scheduled-and-waiting-next-tasks t
     "Non-nil means to hide scheduled and waiting tasks.
   Affects the following commands:
   - `vulpea-agenda-cmd-focus'
   - `vulpea-agenda-cmd-waiting'")

   (defvar vulpea-agenda-main-buffer-name "*agenda:main*"
     "Name of the main agenda buffer.")

   

   ;;;###autoload
   (defun vulpea-agenda-main ()
     "Show main `org-agenda' view."
     (interactive)
     (org-agenda nil " "))

   ;;;###autoload
   (defun vulpea-agenda-person ()
     "Show main `org-agenda' view."
     (interactive)
     (let* ((person (vulpea-select-from
                     "Person"
                     (vulpea-db-query-by-tags-some '("people"))))
            (node (org-roam-node-from-id (vulpea-note-id person)))
            (names (cons (org-roam-node-title node)
                         (org-roam-node-aliases node)))
            (tags (seq-map #'vulpea--title-to-tag names))
            (query (string-join tags "|")))
       (let ((org-agenda-overriding-arguments (list t query)))
         (org-agenda nil "M"))))

   

   ;;;###autoload
   (defun vulpea-agenda-files-update (&rest _)
     "Update the value of `org-agenda-files'."
     (setq org-agenda-files (vulpea-project-files)))

   
   ;; Commands

   ;;;###autoload
   (defconst vulpea-agenda-cmd-refile
     '(tags
       "REFILE"
       ((org-agenda-overriding-header "T√¢ches √† la Representer")
        (org-tags-match-list-sublevels nil))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-today
     '(agenda
       ""
       ((org-agenda-overriding-header "Calendrier d'aujourd'hui:")
        (org-agenda-span 'day)
        (org-agenda-log-mode-items '(clock state))
        (org-agenda-skip-deadline-prewarning-if-scheduled t)
        (org-agenda-sorting-strategy '(habit-down
                                       time-up
                                       category-keep
                                       todo-state-down
                                       priority-down)))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-eisen
     '(agenda
       "e" "Matrice d'Eisenhower"
        ((org-agenda-overriding-header "Calendrier Eisenhower:")
                      (org-agenda-show-log t)
                      (org-agenda-log-mode-items '(clock state))
                      (org-agenda-span 5)
                      (org-agenda-start-on-weekday t)
                      ;;            (org-agenda-ndays 5)
                      (org-agenda-start-day "-1d")
                      (org-deadline-warning-days 30))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-focus
     '(tags-todo
       "FOCUS"
       ((org-agenda-overriding-header
         (concat "Pour se concentrer sur"
                 (if vulpea-agenda-hide-scheduled-and-waiting-next-tasks
                     ""
                   " (y compris les t√¢ches ATTENDRE et PROGRAMM√âES)")))
        (org-agenda-skip-function 'vulpea-agenda-skip-habits)
        (org-tags-match-list-sublevels t)
        (org-agenda-todo-ignore-scheduled
         vulpea-agenda-hide-scheduled-and-waiting-next-tasks)
        (org-agenda-todo-ignore-deadlines
         vulpea-agenda-hide-scheduled-and-waiting-next-tasks)
        (org-agenda-todo-ignore-with-date
         vulpea-agenda-hide-scheduled-and-waiting-next-tasks)
        (org-agenda-tags-todo-honor-ignore-options t)
        (org-agenda-sorting-strategy
         '(todo-state-down priority-down effort-up category-keep)))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-stuck-projects
     '(tags-todo
       "PROJET-ANNUL√â-ENATTENTE/!"
       ((org-agenda-overriding-header "Projets Bloqu√©s")
        (org-agenda-skip-function 'vulpea-agenda-skip-non-stuck-projects)
        (org-agenda-sorting-strategy
         '(todo-state-down priority-down effort-up category-keep)))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-projects
     '(tags-todo
       "PROJET-ENATTENTE"
       ((org-agenda-overriding-header (concat "Projets"))
        (org-tags-match-list-sublevels t)
        (org-agenda-skip-function 'vulpea-agenda-skip-non-projects)
        (org-agenda-tags-todo-honor-ignore-options t)
        (org-agenda-sorting-strategy
         '(todo-state-down priority-down effort-up category-keep)))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-waiting
     '(tags-todo
       "-ANNUL√â+ATTENDRE-READING-FOCUS|+ENATTENTE/!"
       ((org-agenda-overriding-header
         (concat "T√¢ches en attente et report√©es"
                 (if
                  vulpea-agenda-hide-scheduled-and-waiting-next-tasks ""
" (y compris les t√¢ches ATTENDRE et PROGRAMM√âES)")))
        (org-agenda-skip-function 'vulpea-agenda-skip-non-tasks)
        (org-tags-match-list-sublevels nil)
        ;;(org-agenda-todo-ignore-scheduled vulpea-agenda-hide-scheduled-and-waiting-next-tasks)
        (org-agenda-todo-ignore-deadlines
         vulpea-agenda-hide-scheduled-and-waiting-next-tasks))))

   ;;;###autoload
   (defconst vulpea-agenda-eisen-imp-y-urg
    '(tags-todo
      "+important+urgent/!"
         ((org-agenda-overriding-header "T√¢ches importantes et urgentes")
          (org-tags-match-list-sublevels nil))))

   ;;;###autoload
   (defconst vulpea-agenda-eisen-imp
    '(tags-todo
      "+important-urgent"
      ((org-agenda-overriding-header "T√¢ches importantes mais non urgentes")
       (org-tags-match-list-sublevels nil))))


   ;;;###autoload
   (defconst vulpea-agenda-eisen-urg
    '(tags-todo
      "-important+urgent"
      ((org-agenda-overriding-header "T√¢ches urgentes mais sans importance")
       (org-tags-match-list-sublevels nil))))

   ;;;###autoload
    (defconst vulpea-agenda-eisen-alltodos
     ' (tags-todo
        "-important-urgent/!TODO"
        ((org-agenda-overriding-header "T√¢ches non importantes ni urgentes")
         (org-agenda-category-filter-preset '("-Habitudes"))
        ;; (org-tags-match-list-sublevels nil)
)))
   
   ;; Utilities to build agenda commands -- skip

   ;;;###autoload
   (defun vulpea-agenda-skip-habits ()
     "Skip tasks that are habits."
     (save-restriction
       (widen)
       (let ((subtree-end (save-excursion (org-end-of-subtree t))))
         (cond
          ((org-is-habit-p)
           subtree-end)
          (t
           nil)))))

   ;;;###autoload
   (defun vulpea-agenda-skip-non-projects ()
     "Skip trees that are not projects."
     (if (save-excursion (vulpea-agenda-skip-non-stuck-projects))
         (save-restriction
           (widen)
           (let ((subtree-end (save-excursion (org-end-of-subtree t))))
             (cond
              ((vulpea-agenda-project-p)
               nil)
              ((and (vulpea-agenda-project-subtree-p)
                    (not (vulpea-agenda-task-p)))
               nil)
              (t
               subtree-end))))
       (save-excursion (org-end-of-subtree t))))

   ;;;###autoload
   (defun vulpea-agenda-skip-non-tasks ()
     "Show non-project tasks.
   Skip project and sub-project tasks, habits, and project related
   tasks."
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion
                              (or (outline-next-heading)
                                  (point-max)))))
         (cond
          ((vulpea-agenda-task-p)
           nil)
          (t
           next-headline)))))

   ;;;###autoload
   (defun vulpea-agenda-skip-non-stuck-projects ()
     "Skip trees that are not stuck projects."
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion
                              (or (outline-next-heading)
                                  (point-max)))))
         (if (vulpea-agenda-project-p)
             (let* ((subtree-end (save-excursion
                                   (org-end-of-subtree t)))
                    (has-next ))
               (save-excursion
                 (forward-line 1)
                 (while (and (not has-next)
                             (< (point) subtree-end)
                             (re-search-forward "^\\*+ TODO "
                                                subtree-end t))
                   (unless (member "ATTENDRE" (org-get-tags))
                     (setq has-next t))))
               (if has-next
                   next-headline
                 nil)) ; a stuck project, has subtasks but no next task
           next-headline))))

   
   ;; Utilities to build agenda commands -- predicates

   ;;;###autoload
   (defun vulpea-agenda-project-p ()
     "Return non-nil if the heading at point is a project.
   Basically, it's any item with some todo keyword and tagged as
   PROJECT."
     (let* ((comps (org-heading-components))
            (todo (nth 2 comps))
            (tags (split-string (or (nth 5 comps) "") ":")))
       (and (member todo org-todo-keywords-1)
            (member "PROJET" tags))))

   ;;;###autoload
   (defun vulpea-agenda-project-subtree-p ()
     "Any task with a todo keyword that is in a project subtree.
   Callers of this function already widen the buffer view."
     (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                 (point))))
       (save-excursion
         (vulpea-agenda-find-project-task)
         (if (equal (point) task)
             nil
           t))))

   ;;;###autoload
   (defun vulpea-agenda-task-p ()
     "Any task with a todo keyword and no subtask."
     (save-restriction
       (widen)
       (let ((has-subtask)
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (is-a-task (member (nth 2 (org-heading-components))
                                org-todo-keywords-1)))
         (save-excursion
           (forward-line 1)
           (while (and (not has-subtask)
                       (< (point) subtree-end)
                       (re-search-forward "^\\*+ " subtree-end t))
             (when (member (org-get-todo-state) org-todo-keywords-1)
               (setq has-subtask t))))
         (and is-a-task (not has-subtask)))))

   
   ;; Utilities to build agenda commands -- search

   ;;;###autoload
   (defun vulpea-agenda-find-project-task ()
     "Move point to the parent (project) task if any."
     (save-restriction
       (widen)
       (let ((parent-task (save-excursion
                            (org-back-to-heading 'invisible-ok)
                            (point))))
         (while (org-up-heading-safe)
           (when (member (nth 2 (org-heading-components))
                         org-todo-keywords-1)
             (setq parent-task (point))))
         (goto-char parent-task)
         parent-task)))

   

   ;;;###autoload
   (defun vulpea-agenda-category (&optional len)
     "Get category of item at point for agenda.
   Category is defined by one of the following items:
   - CATEGORY property
   - TITLE keyword
   - TITLE property
   - filename without directory and extension
   When LEN is a number, resulting string is padded right with
   spaces and then truncated with ... on the right if result is
   longer than LEN.
   Usage example:
     (setq org-agenda-prefix-format
           '((agenda . \" %(vulpea-agenda-category) %?-12t %12s\")))
   Refer to `org-agenda-prefix-format' for more information."
     (let* ((file-name (when buffer-file-name
                         (file-name-sans-extension
                          (file-name-nondirectory buffer-file-name))))
            (title (vulpea-buffer-prop-get "title"))
            (category (org-get-category))
            (result
             (or (if (and
                      title
                      (string-equal category file-name))
                     title
                   category)
                 "")))
       (if (numberp len)
           (s-truncate len (s-pad-right len " " result))
         result)))

   

   (provide 'lib-vulpea-agenda)
   ;;; lib-vulpea-agenda.el ends here
#+end_src
*** Vulpea org ID
:PROPERTIES:
:header-args: :tangle lisp/lib-vulpea-id.el :noweb yes
:ID:       d174c967-bfcf-4fd3-b74d-1aa86da54b68
:END:
#+begin_src emacs-lisp
;;; lib-vulpea-id.el --- ID utilities -*- lexical-binding: t; -*-
<<disclaimer>>
;;; Commentary:
;;
;; Various ID utilities.
;;
;; Automatic ID generation is controlled by `vulpea-id-auto-targets'.
;; It can be configured from init.el file, or from .dir-locals.el file
;; (for example ,to disable automatic generation):
;;
;;   ((org-mode . ((vulpea-id-auto-targets . nil))))
;;
;;; Code:

(require 'org-id)

(defvar vulpea-id-auto-targets '(file headings)
  "Targets for automatic ID assignment.
Each element of this list can be one of the following:
- file - to automatically set ID on the file level;
- headings - to automatically set ID for each heading in the file.
Empty list means no id assignment is needed.")

;;;###autoload
(defun vulpea-id-auto-assign ()
  "Add ID property to the current file.
Targets are defined by `vulpea-id-auto-targets'."
  (when (and vulpea-id-auto-targets
             (derived-mode-p 'org-mode)
             (eq buffer-read-only nil))
    (save-excursion
      (widen)
      (goto-char (point-min))
      (when (seq-contains-p vulpea-id-auto-targets 'file)
        (org-id-get-create))
      (when (seq-contains-p vulpea-id-auto-targets 'headings)
        (org-map-entries #'org-id-get-create)))))

(provide 'lib-vulpea-id)
;;; lib-vulpea-id.el ends here
#+end_src
** Coding
:PROPERTIES:
:ID:                     a1bbc1a9-e27e-4f24-b62d-c5dbae52689c
:END:
Setup Coding languages

*** Basic IDE
:PROPERTIES:
:ID:                     bbc17bb5-e026-4a01-83c7-19a4d1924c96
:END:
Setup the basic Coding IDE

*** LISP setup
:Properties:
:header-args: :tangle lisp/init-lisp.el :noweb yes
:ID:       e285fd8e-e55c-4b82-bc3a-e42634c4b6b2
:END:
LISP Common setup here
#+begin_src emacs-lisp
  ;;; init-lisp.el --- Code LISP -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-paren>>

  (provide 'init-lisp)
   ;;; init-lisp.el ends here
#+end_src

**** Eval lib
:PROPERTIES:
:header-args: :tangle lisp/lib-eval.el :noweb yes
:ID:       2aad25fa-9a36-4484-b2a6-4397d836773c
:END:
Smartparens setup here
#+begin_src emacs-lisp
  ;;; lib-eval.el --- Eval utilities -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:
(defmacro eval-with-default-dir (dir &rest body)
  "Invoke in DIR the BODY."
  (declare (debug t) (indent 1))
  `(let ((default-directory ,dir))
     ,@body))

(cl-flet ((always-yes (&rest _) t))
  (defun eval-no-confirm (fun &rest args)
    "Apply FUN to ARGS, skipping user confirmations."
    (cl-letf (((symbol-function 'y-or-n-p) #'always-yes)
              ((symbol-function 'yes-or-no-p) #'always-yes))
      (apply fun args))))

  (provide 'lib-eval)
   ;;; lib-eval.el ends here
#+end_src
*** Emacs-lisp setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-elisp.el :noweb yes
:ID:       c07e92e9-c358-4938-977c-b6aa393c7277
:END:
#+begin_src emacs-lisp
  ;;; enfer-code-elisp.el --- Emacs LISP -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-elisp>>

  (provide 'enfer-code-elisp)
   ;;; enfer-code-elisp.el ends here
#+end_src
*** Common LISP setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-common-lisp.el :noweb yes
:ID:       7c6c8865-ce5d-4b09-ac24-81cff979efb1
:END:
#+begin_src emacs-lisp
  ;;; enfer-code-common-lisp.el --- Common-LISP -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-common-lisp>>

  (provide 'enfer-code-common-lisp)
   ;;; enfer-code-common-lisp.el ends here
#+end_src
*** Clojure setup
:PROPERTIES:
:header-args: :tangle lisp/init-clojure.el :noweb yes
:ID:       7f8725fd-d78e-4f0d-9599-566cf5173112
:END:
#+begin_src emacs-lisp
  ;;; init-clojure.el --- Clojure -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-clojure>>

  (provide 'init-clojure)
  ;;; init-clojure.el ends here
#+end_src
*** Fennel/LUA setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-fennel.el :noweb yes
:ID:       afda404b-1889-4438-9efd-40a0aff2218d
:END:
#+begin_src emacs-lisp
  ;;; enfer-code-fennel.el --- Fennel LUA  -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-fennel>>

  (provide 'enfer-code-fennel)
  ;;; enfer-code-fennel.el ends here
#+end_src
*** ESS setup
:Properties:
:header-args: :tangle lisp/init-ess.el :noweb yes
:ID:       a04b95ad-e2ca-4aa3-8f4a-301f6986cda8
:END:
Emacs Speaks Statisitcs setup here
#+begin_src emacs-lisp
  ;;; init-ess.el --- Code ESS -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  (+with-message  "stats R baby!"

  <<ess>>

  )
  (provide 'init-ess)
   ;;; init-ess.el ends here
#+end_src

**** Eval lib
:PROPERTIES:
:header-args: :tangle lisp/lib-eval.el :noweb yes
:ID:       5b4b0991-3552-42c0-b352-64de8428927a
:END:
Smartparens setup here
#+begin_src emacs-lisp
  ;;; lib-eval.el --- Eval utilities -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:
(defmacro eval-with-default-dir (dir &rest body)
  "Invoke in DIR the BODY."
  (declare (debug t) (indent 1))
  `(let ((default-directory ,dir))
     ,@body))

(cl-flet ((always-yes (&rest _) t))
  (defun eval-no-confirm (fun &rest args)
    "Apply FUN to ARGS, skipping user confirmations."
    (cl-letf (((symbol-function 'y-or-n-p) #'always-yes)
              ((symbol-function 'yes-or-no-p) #'always-yes))
      (apply fun args))))

  (provide 'lib-eval)
   ;;; lib-eval.el ends here
#+end_src

** Communications
:PROPERTIES:
:header-args: :tangle lisp/init-telega.el :noweb yes
:ID:                     2b35cb3e-c354-4899-96f6-d16d8097f7ac
:END:

*** Telega setup
    :PROPERTIES:
    :ID:       73cb0290-d331-403b-91ad-6fb88437c065
    :END:

#+begin_src emacs-lisp
  ;;; init-telega.el --- personal configuration -*- lexical-binding: t -*-
(require 'init-elpa)
(require 'init-kbd)

(use-package telega
  :straight (telega
             :type git
             :host github
             :repo "zevlg/telega.el"
             :branch "releases"
             :files (:defaults "contrib" "etc" "server" "Makefile"))
  :defer t
  :hook ((telega-chat-mode . ui-reset-line-spacing)
         (telega-chat-mode . editor-disable-electric-pair))
  :general
  (leader-def
    "t" '(:keymap telega-prefix-map))
  :init
  (when elpa-bootstrap-p
    (require 'telega-server)
    (require 'lib-nix)
    (let ((exec-path (cons telega-directory exec-path))
          (default-directory telega--lib-directory))
      (unless (executable-find "telega-server")
        (nix-shell-command
         :message-intro "building telega-server..."
         :message-error "Failed to build telega-server"
         :deps '("pkg-config" "tdlib")
         :command (concat
                   (or (executable-find "gmake")
                       "make")
                   " "
                   "LIBS_PREFIX="
                   (expand-file-name telega-server-libs-prefix) " "
                   "INSTALL_PREFIX="
                   (expand-file-name telega-directory) " "
                   "server-reinstall"))))))
#+end_src


*** Compatibility Utilities
:PROPERTIES:
:header-args: :tangle lisp/lib-compat.el :noweb yes
:ID:       3cae4486-262c-4e62-bb92-645abbe5ddc6
:END:

#+begin_src emacs-lisp
  ;;; lib-compat.el --- Compatibility utilities  -*- lexical-binding: t -*-
    <<disclaimer>>
    ;;; Code:

  ;;;###autoload
  (defun cl--plist-remove (plist member)
    "Remove MEMBER from PLIST.
  `telega' needs this function."
    (cond
     ((null plist) nil)
     ((null member) plist)
     ((eq plist member) (cddr plist))
     (t `(,(car plist) ,(cadr plist)
          ,@(cl--plist-remove (cddr plist) member)))))

    ;;; SYSTEM-DEPENDENT SETTINGS
    ;; at home
    (eval-and-compile
      (when (memq system-type '(gnu gnu/linux darwin))
        <<linux-specific>>
        ))

    ;; at work
    (eval-and-compile
      (when (memq system-type '(ms-dos windows-nt))
        <<windows-specific>>
        ))

  (provide 'lib-compat)
  ;;; lib-compat.el ends here
#+end_src
*** Ease of editing
:PROPERTIES:
:header-args: :tangle no
:ID:                     de45708b-cfcc-4add-a59b-8cbc64b4f85e
:END:

#+begin_src emacs-lisp :noweb-ref functions
  (defun enfer/find-config ()
    "Find `config.org'."
    (interactive)
    (find-file (locate-user-emacs-file "config.org")))
#+end_src

Bind it to =C-z i= because =C-z C-c= is taken for capture.

#+begin_src emacs-lisp :noweb-ref bindings
;;(define-key acdw/leader (kbd "i") #'acdw/find-config)
#+end_src

*** Ease of reloading
:PROPERTIES:
:header-args: :tangle no
:ID:                     510ef849-87e9-4def-abb8-a28f040752a4
:END:

#+begin_src emacs-lisp :noweb-ref functions
  (defun acdw/reload ()
    "Tangle and reload Emacs configuration."
    (interactive)
    (let ((config (locate-user-emacs-file "config.org")))
      ;; tangle
      (with-current-buffer (find-file-noselect config)
        (message "Tangling config.org...")
        (let ((prog-mode-hook nil)
              (inhibit-redisplay t)
              (inhibit-message t))
          (add-to-list 'load-path (locate-user-emacs-file
                                   "straight/build/org/"))
          (require 'org)
          (org-babel-tangle)))
      (message "Tangling config.org... Done.")
      ;; load init files
      (load (locate-user-emacs-file "early-init.el"))
      (load (locate-user-emacs-file "init.el"))
      ;;(load (locate-user-emacs-file "config.el"))
))
#+end_src

#+begin_src emacs-lisp :noweb-ref bindings
  (define-key acdw/leader (kbd "C-M-r") #'acdw/reload)
#+end_src

** init.el
:PROPERTIES:
:header-args: :tangle init.el :noweb yes
:ID:       77eb9838-8f26-4400-b097-c607b10fcfe4
:END:
The goal of this file is to require all init-xxx files. The structure is trivial:

- Add lisp folder to load-path, so we can use require.
- Adjust garbage collection thresholds, so things run smoother.
- Load config-path declaring various path constants.
- Load init-elpa which ‚Äòbootstraps‚Äô your package and configuration management tools.
- Load autoloads file.
- Load all other init-xxx files.
- Load custom-file, even if you are not using customize interface, you need this to use .dir-locals.el.

#+begin_src emacs-lisp
    ;;; init.el --- Std Init -*- lexical-binding: t -*-
    <<disclaimer>>
    ;;; Code:
    (defmacro +with-message (message &rest body)
      "Execute BODY, with MESSAGE.
                If body executes without errors, ** MESSAGE... termin√© will be displayed."
      (declare (indent 1))
      (let ((msg (gensym)))
        `(let ((,msg ,message))
           (unwind-protect (progn (message "%s..." ,msg)
                                  ,@body)
             (message "** %s... termin√©!!" ,msg)))))
    ;;; Set up extra load paths and functionality
    ;; Since we might be running in CI or other environments, stick to
    ;; XDG_CONFIG_HOME value if possible.
    (let ((/emacs-home (if-let ((xdg (getenv "XDG_CONFIG_HOME")))
                           (expand-file-name "emacs/" xdg)
                         user-emacs-directory)))
      ;; Add Lisp directory to `load-path'.
      (add-to-list 'load-path (expand-file-name "lisp" /emacs-home)))

    ;;; bootstrap
    ;;; ============================================================================
    ;;; Specify some directory paths & constants
    ;;; ============================================================================
    (require 'config-path)

    <<constants>>
    ;;; ============================================================================
    ;;; Set up the package manager
    ;;; ============================================================================
    (require 'init-elpa)

    ;; Setup `custom-file`.
    (setq custom-file (concat emacs-config/ "custom.el"))

    ;; load autoloads file
    (unless elpa-bootstrap-p
      (unless (file-exists-p path-autoloads-file)
        (error "Le fichier autoloads n'existe pas, veuillez ex√©cuter '%s'"
               "eru install emacs"))
      (load path-autoloads-file nil 'nomessage))
#+end_src

#+begin_src emacs-lisp
    ;;; core
    (require 'init-env)
    (require 'init-kbd)
    (require 'init-fn-macros)
    (require 'init-editor)
    (require 'init-ui)
    (require 'init-buffer)
    (require 'init-window)
    ;;  (require 'enfer-emacs-sanity)
    (require 'enfer-emacs-startup)
  ;;; utilities
    (require 'init-selection)
    (require 'init-project)
    (require 'init-vcs)
    ;;  (require 'init-ide)
    ;;(require 'enfer-pkg-builtin)

  ;;; languages
    (require 'init-lisp)
    (require 'enfer-code-elisp)
    (require 'enfer-code-common-lisp)
    (require 'init-clojure)
    (require 'enfer-code-fennel)
    (require 'init-ess)
    ;;(require 'enfer-pkg-util)
    (require 'init-notes)
    ;; I don't use `customize' interface, but .dir-locals.el put 'safe'
    ;; variables into `custom-file'. And to be honest, I hate to allow
    ;; them every time I restart Emacs.
    (when (file-exists-p custom-file)
      (load custom-file nil 'nomessage))

    (provide 'init)
      ;;; init.el ends here
#+end_src
*** Load the config -disabled
:PROPERTIES:
:ID:                     a40cbe30-7947-492b-a365-5dbba82a37a4
:END:

I keep most of my config in =config.el=, which is tangled directly from
this file.  This init just loads that file, either from lisp
or directly from Org if it's newer.  /Note/ the longish comment before
the =unless= form -- it was pretty tough for me to wrap my head around
the needed boolean expression to tangle config.org.  Booleans, yall!

#+begin_src emacs-lisp :tangle no
  (let* (;; Speed up init
        ;; (gc-cons-threshold most-positive-fixnum)
         ;; (gc-cons-percentage 0.6)
         ;;(file-name-handler-alist nil)
         ;; Config file names
         (config (expand-file-name "config"
                                   user-emacs-directory))
         (config.el (concat config ".el"))
         (config.org (concat config ".org"))
         (straight-org-dir (locate-user-emacs-file "straight/build/org")))
    ;; Okay, let's figure this out.
    ;; `and' evaluates each form, and returns nil on the first that
    ;; returns nil.  `unless' only executes its body if the test
    ;; returns nil.  So.
    ;; 1. Test if config.org is newer than config.el.  If it is (t), we
    ;;    *want* to evaluate the body, so we need to negate that test.
    ;; 2. Try to load the config.  If it errors (nil), it'll bubble that
    ;;    to the `and' and the body will be evaluated.
    (unless (and (not (file-newer-than-file-p config.org config.el))
                 (load config :noerror))
      ;; A plain require here just loads the older `org'
      ;; in Emacs' install dir.  We need to add the newer
      ;; one to the `load-path', hopefully that's all.
      (when (file-exists-p straight-org-dir)
        (add-to-list 'load-path straight-org-dir))
      ;; Load config.org
      (require 'org)
      (org-babel-load-file config.org)))

  ;;; init.el ends here
#+end_src

** early-init.el
:PROPERTIES:
:header-args: :tangle early-init.el :noweb yes
:ID:       115da072-e944-4419-a49c-013c2d6368c4
:END:

Beginning with 27.1, Emacs also loads an =early-init.el= file, before
the package manager or the UI code.

#+begin_src emacs-lisp
    ;;; early-init.el --- Early Customisations -*- lexical-binding: t; no-byte-compile: t; -*-
    <<disclaimer>>
    ;;; Code:

    (message "Chargement en cours early-init.el...")

    (define-advice load (:before (feature &rest _))
      "Message the user when loading a library."
      (with-temp-message (format "En cours de chargement de la biblioth√®que: '%s'" feature)))
    ;;; ============================================================================
    ;;; Some constants for conditional compliation
    ;;; ============================================================================
    <<constants>>

    ;;; ============================================================================
    ;;; Emacs startup optimisations
    ;;; ============================================================================
    <<garbage-filehandler>>

    ;;; ============================================================================
    ;;; Frame parameters for faster startup
    ;;; ============================================================================
    <<early-init-frame>>

   (message "Chargement du early-init.el termin√©!")
   (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

** Libraries & Config
:PROPERTIES:
:ID:                     19f2b8c1-c022-4c5d-8a4d-92bc544213f2
:END:
*** String
:PROPERTIES:
:header-args: :tangle lisp/lib-string.el :noweb yes
:ID:       c636d0e2-9f57-4e6b-bb90-12cf537f603f
:END:
#+begin_src emacs-lisp
    ;;; lib-string.el --- String Utilities -*- lexical-binding: t -*-
  <<disclaimer>>
    ;;; Code:

  (require 'init-elpa)
  (require 's)

  ;;;###autoload
  (defun string-match-1 (regexp val)
    "Get the first group from REGEXP match of the VAL.
  VAL can be either a string or a region (beg . end) of the
  buffer."
    (string-match-n 1 regexp val))

  ;;;###autoload
  (defun string-match-n (n regexp val)
    "Get the Nth group from REGEXP match of the VAL.
  VAL can be either a string or a region (beg . end) of the
  buffer."
    (let ((s (if (stringp val)
                 val
               (buffer-substring (car val) (cdr val)))))
      (string-match regexp s)
      (match-string n s)))

  ;;;###autoload
  (defun string-join-g (strs sep)
    "Join a list of STRS using SEP."
    (pcase strs
      (`nil "")
      (`(,str) str)
      (_ (mapconcat #'identity strs sep))))

  ;;;###autoload
  (defun string-chop-prefix-regexp (prefix s)
    "Remove PREFIX regexp if it is at the start of S."
    (s-chop-prefix (car (s-match prefix s)) s))

  ;;;###autoload
  (defun string-chop-suffix-regexp (suffix s)
    "Remove SUFFIX regexp if it is at the end of S."
    (s-chop-suffix (car (s-match suffix s)) s))

  (defvar string-http-url-regexp
    "\\(https?://.*\\)"
    "HTTP(s) URL regexp.")

  (defvar string-uuid-regexp
    (concat
     "\\("
     "[a-zA-Z0-9]\\{8\\}"
     "-"
     "[a-zA-Z0-9]\\{4\\}"
     "-"
     "[a-zA-Z0-9]\\{4\\}"
     "-"
     "[a-zA-Z0-9]\\{4\\}"
     "-"
     "[a-zA-Z0-9]\\{12\\}"
     "\\)")
    "UUID regexp.")

  (defun string-from (value)
    "Convert VALUE to string."
    (cond
     ((stringp value) value)
     ((numberp value) (number-to-string value))
     ((symbolp value) (symbol-name value))
     (t (user-error
         "Unsupported type of \"%s\"" value))))

  (cl-defun string-table (&key data
                               pad-type
                               pad-str
                               sep
                               row-start
                               row-end)
    "Format DATA as a table.
  DATA is list of lists. Each column is aligned by padding with
  PAD-STR either on left or right depending on value of PAD-TYPE.
  Each row begins with ROW-START and ends with ROW-END. Each value
  in row is separated by SEP."
    (let* ((widths (seq-reduce
                    (lambda (r v)
                      (seq-map-indexed
                       (lambda (a i)
                         (max
                          (length (string-from a))
                          (or (nth i r)
                              0)))
                       v))
                    data
                    nil))
           (pad-fn (pcase (or pad-type 'left)
                     (`left #'s-pad-left)
                     (`right #'s-pad-right)))
           (pad-str (or pad-str " "))
           (row-start (or row-start ""))
           (row-end (or row-end ""))
           (sep (or sep " ")))
      (seq-reduce
       (lambda (r v)
         (concat
          r
          row-start
          (string-join
           (seq-map-indexed
            (lambda (a i)
              (funcall pad-fn
                       (nth i widths)
                       pad-str
                       (string-from a)))
            v)
           sep)
          row-end
          "\n"))
       data
       "")))

  (provide 'lib-string)
    ;;; lib-string.el ends here
#+end_src
*** orgmode config
:PROPERTIES:
:header-args: :tangle lisp/config-orgmode.el :noweb yes
:ID:       7df49a2c-aad7-472a-a186-c8db756aeb44
:END:
#+begin_src emacs-lisp
  ;;; config-orgmode.el --- Org-mode Directory -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:
  (require 'config-path)

 (defvar vulpea-directory
  (expand-file-name "org/roam" path-home/)
  "Directory containing notes.")

  (provide 'config-orgmode)
  ;;; config-orgmode.el ends here
#+end_src
*** function lib
:PROPERTIES:
:header-args: :tangle lisp/lib-fun.el :noweb yes
:ID:       70df19e8-852a-472f-8d78-d24d1d45dd06
:END:
#+begin_src emacs-lisp
  ;;; lib-fun.el --- Extra function -*- lexical-binding: t -*-
  <<disclaimer>>
  ;; Utilities to build functions.
;;
;;; Code:

;;;###autoload
(defun fun-unquote (exp)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

;;;###autoload
(defun fun-collect-while (fn filter &rest args)
  "Repeat FN and collect it's results until `C-g` is used.
Repeat cycle stops when `C-g` is used or FILTER returns nil.
If FILTER is nil, it does not affect repeat cycle.
If FILTER returns nil, the computed value is not added to result.
ARGS are passed to FN."
  (let (result
        value
        (continue t)
        (inhibit-quit t))
    (with-local-quit
      (while continue
        (setq value (apply fn args))
        (if (and filter
                 (null (funcall filter value)))
            (setq continue nil)
          (setq result (cons value result)))))
    (setq quit-flag nil)
    (seq-reverse result)))

;;;###autoload
(defun fun-repeat-while (fn filter &rest args)
  "Repeat FN and return the first unfiltered result.
Repeat cycle stops when `C-g` is used or FILTER returns nil.
ARGS are passed to FN."
  (let (value
        (continue t)
        (inhibit-quit t))
    (with-local-quit
      (while continue
        (setq value (apply fn args))
        (when (null (funcall filter value))
          (setq continue nil))))
    (setq quit-flag nil)
    (when (null continue)
      value)))

;;;###autoload
(defun fun-noop (&rest _)
  "Do nothing.
Useful for temporarily disabling a function.")

(provide 'lib-fun)
;;; lib-fun.el ends here
#+end_src
*** VCS
:PROPERTIES:
:header-args: :tangle lisp/lib-vcs.el :noweb yes
:ID:       05d0ed58-40b0-49a0-829b-7436db557594
:END:
#+begin_src emacs-lisp
  ;;; lib-vcs.el --- Libaray -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  (require 'init-kbd)



(defvar vcs-url-github-issue-regexp
  (format "\\(%s/\\(%s\\)/\\(%s\\)/\\(%s\\)/\\(%s\\)\\).*"
          "https://github\\.com"
          "[-\\.[:alnum:]]+"
          "[-\\.[:alnum:]]+"
          "[[:alpha:]]+"
          "[[:alnum:]]+")
  "GitHub issue/pull URL regexp.
- 1st group is whole URL.
- 2nd group is owner.
- 3rd group is repository name.
- 4th group is type of the object - issue/pull/miliestone/commit.
- 5th group is the number of the object.")

(defvar vcs-url-github-project-regexp
  (format "\\(%s/\\(%s\\)/\\(%s\\)/?\\)"
          "https://github\\.com"
          "[-\\.[:alnum:]]+"
          "[-\\.[:alnum:]]+")
  "GitHub project URL regexp.
- 1st group is whole URL.
- 2nd group is owner.
- 3rd group is repository name.")

(defvar vcs-url-known-github-users '("frap"
                                     "agasson")
  "List of 'known' GitHub users.")



;;;###autoload
(defun vcs-url-format-github-issue (owner repo type number)
  "Format GitHub issue.
Depending on the TYPE format can be one of the following:
- OWNER/REPO#NUMBER if TYPE is not milestone;
- OWNER/REPOmNUMBER otherwise.
In case OWNER is a member of `vcs-url-known-github-users', then OWNER
part of format is omitted."
  (concat
   (if (seq-contains-p vcs-url-known-github-users owner)
       repo
     (concat owner "/" repo))
   (if (string-equal type "milestone")
       "m"
     "#")
   (if (string-equal type "commit")
       (substring number 0 (min 7 (length number)))
     number)))

;;;###autoload
(defun vcs-url-format-github-project (owner repo)
  "Format GitHub REPO.
In case OWNER is a member of `vcs-url-known-github-users', then OWNER
part of format is omitted."
  (concat
   (if (seq-contains-p vcs-url-known-github-users owner)
       repo
     (concat owner "/" repo))))

  (provide 'lib-vcs)
  ;;; lib-vcs.el ends here
#+end_src

*** File Templates aka YASSnippett
:PROPERTIES:
:header-args: :tangle lisp/init-file-templates.el :noweb yes
:ID:       68ae83b4-14d3-4eb7-9c99-fd05cb6d9053
:END:
#+begin_src emacs-lisp
;;; init-file-templates.el --- File templates support -*- lexical-binding: t; -*-
  <<disclaimer>>
 ;; Commentary:
;;
;; This module configures yasnippet.
;;
;;; Code:

(require 'init-project)

(defvar file-templates-dir
  (expand-file-name "templates/" emacs-config/ )
  "The path to yasnippet folders.")

(defvar file-templates-default-trigger "__"
  "The default yasnippet trigger key (a string).
Used for file template rules that don't have a :trigger property
in `file-templates-alist'.")

(defvar file-templates-alist
  `(
    ;; elisp
    ("dir-locals.el$"
     :ignore t)
    ("settings.el$"
     :ignore t)
    (emacs-lisp-mode
     :trigger "__package")
    (snippet-mode))
  "An alist of file template rules.
The CAR of each rule is either a major mode symbol or regexp
string.
The CDR is a plist. See `file-templates-set' for more
information.")

(use-package yasnippet
  :diminish yas-minor-mode
  :commands (yas-minor-mode-on
             yas-expand
             yas-expand-snippet
             yas-lookup-snippet
             yas-insert-snippet
             yas-new-snippet
             yas-visit-snippet-file
             yas-reload-all
             yas-dropdown-prompt
             yas--all-templates
             yas--get-snippet-tables
             yas--template-key)
  :hook ((text-mode . yas-minor-mode-on)
         (prog-mode . yas-minor-mode-on)
         (conf-mode . yas-minor-mode-on)
         (snippet-mode . yas-minor-mode-on))
  :init
  (add-hook 'find-file-hook #'file-templates-check)
  :config
  (setq yas-prompt-functions (delq #'yas-dropdown-prompt
                                   yas-prompt-functions)
        yas-snippet-dirs '(file-templates-dir))
  ;; Ensure file templates in `file-templates-dir' are visible
  (yas-reload-all))

(defun file-templates-check ()
  "Check the current buffer for file template expansion.
Returns non-nil when current buffer is a candidate for file
template expansion.
The buffer must be non-read-only, empty, and there must be a rule
in `file-templates-alist' that applies to it."
  (when (and (not buffer-read-only)
             (bobp) (eobp)
             (not (string-match-p "^ *\\*" (buffer-name))))
    (let ((rule (cl-find-if #'file-templates-p
                            file-templates-alist)))
      (when rule (apply #'file-templates--expand rule)))))

(defun file-templates--set (pred plist)
  "Register a file template.
Refer to `file-templates-set' documentation on the meaning of
PRED and PLIST."
  (if (null (car-safe plist))
      (setq file-templates-alist
            (delq (assoc pred file-templates-alist)
                  file-templates-alist))
    (push `(,pred ,@plist) file-templates-alist)))

(defun file-templates-set (pred &rest plist)
  "Register a file template.
PRED can either be a regexp string or a major mode symbol.
PLIST may contain these properties:
  :when FUNCTION
    Provides a secondary predicate. This function takes no
    arguments and is executed from within the target buffer. If
    it returns nil, this rule will be skipped over.
  :trigger STRING|FUNCTION
    If a string, this is the yasnippet trigger keyword used to
    trigger the target snippet.
    If a function, this function will be run in the context of
    the buffer to insert a file template into. It is given no
    arguments and must insert text into the current buffer
    manually.
    If omitted, `file-templates-default-trigger' is used.
  :mode SYMBOL
    What mode to get the yasnippet snippet from. If omitted,
    either PRED (if it's a major-mode symbol) or the mode of the
    buffer is used.
  :project BOOL
    If non-nil, ignore this template if this buffer isn't in a
    project.
  :ignore BOOL
    If non-nil, don't expand any template for this file and don't
    test any other file template rule against this buffer.
\(fn PRED &key WHEN TRIGGER MODE PROJECT IGNORE)"
  (declare (indent defun))
  (file-templates--set pred plist))

(cl-defun file-templates--expand
    (pred &key project mode trigger ignore _when)
  "Auto insert a yasnippet snippet into current file.
See `file-templates-set' for information about PRED,
PROJECT, MODE, TRIGGER, IGNORE and _WHEN arguments."
  (when (and pred (not ignore))
    (when (if project (project-p) t)
      (unless mode
        (setq mode (if (symbolp pred) pred major-mode)))
      (unless mode
        (user-error "Couldn't determine mode for %s file template"
                    pred))
      (unless trigger
        (setq trigger file-templates-default-trigger))
      (if (functionp trigger)
          (funcall trigger)
        (require 'yasnippet)
        (unless yas-minor-mode
          (yas-minor-mode-on))
        (when yas-minor-mode
          (yas-expand-snippet
           (yas-lookup-snippet trigger mode)))))))

(defun file-templates-p (rule)
  "Return non-nil if the RULE apply to the current buffer."
  (let ((pred (car rule))
        (plist (cdr rule)))
    (and (cond
          ((and (stringp pred)
                buffer-file-name)
           (string-match-p pred buffer-file-name))
          ((symbolp pred)
           (eq major-mode pred)))
         (or (not (plist-member plist :when))
             (funcall (plist-get plist :when)
                      buffer-file-name))
         rule)))

(defun file-templates-debug ()
  "Output the file template rule for current buffer.
Test the current buffer and outputs the file template rule most
appropriate for it. This is used for testing."
  (interactive)
  (message
   "Found %s"
   (cl-find-if
    #'file-templates-p
    file-templates-alist)))

(provide 'init-file-templates)
;;; init-file-templates.el ends here
#+end_src

*** Dash-functional fixup
:PROPERTIES:
:header-args: :tangle lisp/dash-functional.el :noweb yes
:ID:       5c50f26c-4d6f-4030-a94f-c2c5c0729585
:END:
#+begin_src emacs-lisp
  ;;; dash-functional.el --- Mocking dash-functional -*- lexical-binding: t; -*-
  <<disclaimer>>
  ;;; Commentary:
;;
;; Unfortunately, dash-functional is obsolete. And instead of talking
;; to popular libraries, they simply put a warning inside this
;; package, meaning that people treating warnings as errors have no
;; way to load this module (even transitively).
;;
;; Thanks, folks! I really appreciate it.
;;
;; So this module is a fake to avoid byte compilation error.
;;
;;; Code:

(require 'dash)

(provide 'dash-functional)
;;; dash-functional.el ends here
#+end_src

** License
:PROPERTIES:
:header-args: :tangle LICENSE
:ID:       544ee924-beef-403c-b654-6fc255528de9
:END:

Copyright ¬© 2021 Gas <gas@tuatara.red>

This work is free.  You can redistribute it and/or modify it under the
terms of the Do What the Fuck You Want To Public License, Version 2,
as published by Sam Hocevar.  See the =LICENSE= file, tangled from the
following source block, for details.

#+begin_src text
  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE

  Version 2, December 2004

  Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>

  Everyone is permitted to copy and distribute verbatim or modified copies of
  this license document, and changing it is allowed as long as the name is changed.

  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE

  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. You just DO WHAT THE FUCK YOU WANT TO.
#+end_src
