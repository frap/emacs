#+title: Literate  Clojure Emacs Config
#+author: Gas
#+startup: overview
#+property: header-args :cache yes :results output :mkdirp yes :padline no
#+auto_tangle: yes

* About me
Some scripts to setup whether I am on work computer or not
#+begin_src emacs-lisp :noweb-ref user-config
(if (getenv "USER")
     (defconst IS-WORK (string-match "Gas" (getenv "USER")))
     (defconst IS-WORK nil))

(if IS-WORK
    (setq
     user-full-name "Gas"'
     user-mail-address "gasson@somecompany.nz")
  (setq
   user-full-name "Andrés Gasson"
   user-mail-address "gas@tuatara.red"
   github-account-name "frap")
  )

#+end_src

** Where am I?
#+begin_src emacs-lisp :noweb-ref user-config
(setq calendar-location-name "Kapiti, NZ"
      calendar-latitude -41.28
      calendar-longitude 174.78)

#+end_src

** Auth-sources
Here feels like as good a place as any to setup =auth-sources=.

#+begin_src emacs-lisp :noweb-ref user-config
(setq-default auth-sources (expand-file-name "authinfo.gpg"  XDG_CACHE/  )
              auth-source-cache-expiry nil) ; default is 7200 (2h)

#+end_src
** init-usersetup tangle
:PROPERTIES:
:header-args: :tangle lisp/init-usersetup.el :noweb yes
:END:

#+begin_src emacs-lisp
;;; init-usersetup.el --- User Setup -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<user-config>>

(provide 'init-usersetup)
;;; init-usersetup.el ends here
#+end_src
* Emacs Startup

** Path & Directories
:PROPERTIES:
:header-args: :noweb-ref path-config
:end:
Need to setup some constants and try to keep state in a "clean" directory structure
#+begin_src emacs-lisp
;; For the rest of the Emacs configuration, set this directory to something
;; inside the standard cache directory, so we do not pollute our emacs.d
;; directory with files that we would then have to ignore with Git.
(defconst EMACS_CONFIG/ user-emacs-directory)

(defconst GAS_DEV/ (expand-file-name "Dev/" (or (getenv "HOME") "~/"))
  "Gas Project directory root")

(defconst XDG_CACHE/ (or (getenv "XDG_CACHE_HOME") "~/.cache/"))

(defconst EMACS_CACHE/
  (expand-file-name "emacs/" XDG_CACHE/ )
  "Directory for Emacs volatile storage.
   Use this for files that change often.")

(defconst EMACS_ETC/ (concat EMACS_CACHE/ "etc/")
  "Directory for non-volatile storage.
      Use this for files that don't change much, like servers binaries,
      external dependencies or long-term shared data.")

(defconst my-env-file (concat EMACS_CACHE/  "env"))
;; For the rest of the Emacs configuration, set this directory to something
;; inside the standard cache directory, so we do not pollute our emacs.d
;; directory with files that we would then have to ignore with Git.
;;(setq user-emacs-directory EMACS_CACHE/)

#+end_src
** Native Compilation for >= Emacs28
:properties:
:header-args: noweb-ref native-compile
:end:
setting some compliation default settings on early-init
#+begin_src emacs-lisp
;; For the list of native compilation ELN cache directories, delete all but the
;; last element, which is always assumed to be the system path, and then cons a
;; new path in our cache directory to the front. This effectively removes the
;; entry for the original ~/.emacs.d/eln-cache/ and any others that are
;; unwanted.
(when (featurep 'native-compile)
  (setq native-comp-eln-load-path
         (cons (expand-file-name "eln-cache/" EMACS_CACHE/ )
               (last native-comp-eln-load-path)))
  (defvar native-comp-deferred-compilation)
  (setq native-comp-deferred-compilation t)
  (defvar native-comp-async-report-warnings-errors)
  (setq native-comp-async-report-warnings-errors nil))

#+end_src
** Garbage Collection & File handlers
:PROPERTIES:
:header-args: :noweb-ref garbage-filehandler
:END:
Make startup faster by reducing the frequency of garbage collection and then use a hook to measure Emacs startup time.

#+begin_src emacs-lisp
;; Garbage collection slows down startup time, so we maximise the threshold for
;; it to run, and we will later reset it.
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6
      file-name-handler-alist nil
      site-run-file nil
      read-process-output-max (* 10 1024 1024)
      bidi-inhibit-bpa t)

(defvar gas/gc-cons-threshold (* 100 1024 1024))   ;; 100mb

(add-hook 'emacs-startup-hook
          #'(lambda () (setq gc-cons-threshold gas/gc-cons-threshold
                             gc-cons-percentage 0.1)))

;; file-name-handler-alist is consulted on various I/O functions such as
;; REQUIRE, slowing down startup time, so we set it to NIL, and establish
;; a hook to restore when Emacs is finished starting.
(unless (or (daemonp) noninteractive)
  (let ((file-name-handler-alist/old file-name-handler-alist))
    (setq file-name-handler-alist nil)
    (add-hook 'emacs-startup-hook
              (lambda ()
                (let ((value (delete-dups
                              (append file-name-handler-alist
                                      file-name-handler-alist/old))))
                  (setq file-name-handler-alist value))))))

(unless (daemonp)
  (advice-add #'tty-run-terminal-initialization :override #'ignore)
  (add-hook 'window-setup-hook
            (lambda ()
              (advice-remove #'tty-run-terminal-initialization #'ignore)
              (tty-run-terminal-initialization (selected-frame) nil t))))

#+end_src
** Initial frame setup
:PROPERTIES:
:header-args: :noweb-ref early-init-frame
:END:

I don't want the frame to resize when I change fonts and stuff, and I
want it to resize by pixels -- we /are/ using a GUI, after all.

*** Frame use pixel resize
#+begin_src emacs-lisp
(setq-default
 initial-frame-alist '((width . 170)
                       (height . 56)
                       (tool-bar-lines . 0)
                       (tooltip-mode 0)
                       (vertical-scroll-bars . 0)
                       (bottom-divider-width . 0)
                       (right-divider-width . 1)
                       (font . "Iosevka Curly 14")
                       (blink-cursor-mode 0)
                       (column-number-mode 1)
                       (display-time-mode 0)
                       (fringe-mode '(4 . 0))
                       (window-divider-mode 1)
                       )
 default-frame-alist initial-frame-alist
 frame-inhibit-implied-resize t           ;; dont resize
 frame-resize-pixelwise t                 ;; as GUI use pixels
 x-gtk-resize-child-frames 'resize-mode
 fringe-indicator-alist (assq-delete-all 'truncation fringe-indicator-alist))

(setq truncate-partial-width-windows nil)

#+end_src

*** Turn off Tool & scroll bars
#+begin_src emacs-lisp
(when (fboundp #'tool-bar-mode)
  (tool-bar-mode -1))

(when (fboundp #'scroll-bar-mode)
  (scroll-bar-mode -1))
#+end_src

*** Minibuffer Setup hooks
#+begin_src emacs-lisp
(add-hook 'minibuffer-setup-hook #'(lambda ()
                                     (setq gc-cons-threshold most-positive-fixnum)))
(add-hook 'minibuffer-exit-hook #'(lambda ()
                                    (garbage-collect)
                                    (setq gc-cons-threshold gas/gc-cons-threshold)))
#+end_src
** early-init.el tangle
:PROPERTIES:
:header-args: :tangle early-init.el :noweb yes
:END:
Beginning with 27.1, Emacs also loads an =early-init.el= file, before
the package manager or the UI code.

#+begin_src emacs-lisp
;;; early-init.el --- Early Customisations -*- lexical-binding: t; no-byte-compile: t; -*-
<<disclaimer>>
;;
;;; Code:

(message "Chargement en cours early-init.el...")

(define-advice load (:before (feature &rest _))
    "Message the user when loading a library."
    (with-temp-message (format "En cours de chargement de la bibliothèque: '%s'" feature)))

;;; ============================================================================
;;; Turn off Emacs "package" manager
;;; ============================================================================
<<turnoff-package>>

;;; ============================================================================
;;; Emacs startup optimisations
;;; ============================================================================
<<garbage-filehandler>>

;;; ============================================================================
;;; Frame parameters for faster startup
;;; ============================================================================
<<early-init-frame>>

(message "Chargement du early-init.el terminé!")
(provide 'early-init)
;;; early-init.el ends here
#+end_src

** init.el tangle
:PROPERTIES:
:header-args: :tangle init.el :noweb yes
:END:
The goal of this file is to require all init-xxx files. The structure is trivial:

- Add lisp folder to load-path, so we can use require.
- Adjust garbage collection thresholds, so things run smoother.
- Load config-path declaring various path constants.
- Load init-elpa which ‘bootstraps’ your package and configuration management tools.
- Load autoloads file.
- Load all other init-xxx files.
- Load custom-file, even if you are not using customize interface, you need this to use .dir-locals.el.

#+begin_src emacs-lisp
;;; init.el --- Gas Emacs Init -*- lexical-binding: t -*-
<<disclaimer>>

;;; Code:

(eval-when-compile
  (require 'subr-x)) ;; adds string-trim
;;; Bootstrap
;;; Avoid the "loaded old bytecode instead of newer source" pitfall.
(setq load-prefer-newer t)
;; Add our custom lisp modules to the Emacs load path so they can be discovered.
(push (expand-file-name "lisp/" (file-name-directory user-init-file)) load-path)
;;; ============================================================================
;;; Specify the directory paths
;;; ============================================================================
(require 'config-path)

;;;============================================================================
;;; Set up the package manager
;;; ============================================================================
(require 'init-elpa)

;;; core
;; sanity settings
(require 'init-sanity)

;; startup packages & gcmh
;;(require 'init-startup)
(require 'init-kbd)

;; navigation & Editor setup
;;(require 'init-selection)
(require 'init-editor)
;;(use-package corgi-editor)
;;(use-package corgi-commands)

;;; utilities
(require 'init-selection)
(require 'init-project)
;; Powerful Git integration. Corgi already ships with a single keybinding for
;; Magit, which will be enabled if it's installed (`SPC g s' or `magit-status').
(require 'init-vcs)
;;(require 'ínit-kbd)

;;; Setup the Theme
(require 'init-ui)
;;(require 'init-buffer)
;;(require 'init-window)

;;; Coding Setup
(require 'init-ide)
;;(require 'init-lisp)
(require 'init-elisp)
;;(require 'init-clisp)
(require 'init-clojure)
;;(require 'init-fennel)
;; R
(require 'init-ess)
;;(require 'init-utils)
(require 'init-javascript)
(require 'init-utils-coding)

;; Org Note Taking
(require 'init-notes)
(require 'init-file-templates)

;;; user config & some defaults
(require 'init-usersetup)

;; I don't use `customize' interface, but .dir-locals.el put 'safe'
;; variables into `custom-file'. And to be honest, I hate to allow
;; them every time I restart Emacs.
(when (file-exists-p custom-file)
  (load custom-file nil 'nomessage))

(provide 'init)
;;; init.el ends here
#+end_src
*** Load the config -disabled
:PROPERTIES:
:ID:                     a40cbe30-7947-492b-a365-5dbba82a37a4
:END:

I keep most of my config in =config.el=, which is tangled directly from
this file.  This init just loads that file, either from lisp
or directly from Org if it's newer.  /Note/ the longish comment before
the =unless= form -- it was pretty tough for me to wrap my head around
the needed boolean expression to tangle config.org.  Booleans, yall!

#+begin_src emacs-lisp :tangle no
  (let* (;; Speed up init
        ;; (gc-cons-threshold most-positive-fixnum)
         ;; (gc-cons-percentage 0.6)
         ;;(file-name-handler-alist nil)
         ;; Config file names
         (config (expand-file-name "config"
                                   user-emacs-directory))
         (config.el (concat config ".el"))
         (config.org (concat config ".org"))
         (straight-org-dir (locate-user-emacs-file "straight/build/org")))
    ;; Okay, let's figure this out.
    ;; `and' evaluates each form, and returns nil on the first that
    ;; returns nil.  `unless' only executes its body if the test
    ;; returns nil.  So.
    ;; 1. Test if config.org is newer than config.el.  If it is (t), we
    ;;    *want* to evaluate the body, so we need to negate that test.
    ;; 2. Try to load the config.  If it errors (nil), it'll bubble that
    ;;    to the `and' and the body will be evaluated.
    (unless (and (not (file-newer-than-file-p config.org config.el))
                 (load config :noerror))
      ;; A plain require here just loads the older `org'
      ;; in Emacs' install dir.  We need to add the newer
      ;; one to the `load-path', hopefully that's all.
      (when (file-exists-p straight-org-dir)
        (add-to-list 'load-path straight-org-dir))
      ;; Load config.org
      (require 'org)
      (org-babel-load-file config.org)))

  ;;; init.el ends here
#+end_src

* Emacs Package Management
** Turn of legacy Emacs "package" Manager
#+begin_src emacs-lisp :noweb-ref turnoff-package
;; Pre-configure the package manager settings before it is loaded.
(setq package-enable-at-startup nil)
(setq package-quickstart nil)

#+end_src
** Straight Bootstrap
:PROPERTIES:
:header-args: :noweb-ref straight-setup
:END:
Use Straight for package Management.
#+begin_src emacs-lisp
;; Install the Straight package manager

;; uncomment this line here to shorten emacs-init-time
(setq straight-check-for-modifications '(check-on-save find-when-checking))

(defvar bootstrap-version)

(let ((install-url "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el")
     ;; (straight-base-dir EMACS_CACHE/ )
      (bootstrap-file (expand-file-name "straight/repos/straight.el/bootstrap.el" EMACS_CACHE/ ))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer (url-retrieve-synchronously install-url 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

;; Install the use-package convenience macro
(straight-use-package 'use-package)

;; using use-package to configure straight
(use-package straight
  :custom
  (straight-use-package-by-default t)
  :config
  (setq straight-use-package-by-default t)

  (setq straight-vc-git-default-clone-depth '(1 single-branch))  ;; instead of the default 'full
  (setq use-package-verbose nil) ;; use 't' to see execution profile at startup
  (setq straight-profiles `((nil . ,(expand-file-name "lockfile" EMACS_CACHE/ ))))

  ;; Corgi freezes versions
  (when (not (file-exists-p (expand-file-name "straight/versions/default.el" straight-base-dir)))
  (straight-freeze-versions))

  ;; Additional post-setup of straight.el.
  (require 'straight-x)
  ;;; Appendix
  ;; Get rid of a dumb alias.  straight-ಠ_ಠ-mode really slows down all
  ;; minibuffer completion functions.  Since it's a (rarely-used, even)
  ;; alias anyway, I just define it back to nil.  By the way, the alias
  ;; is `straight-package-neutering-mode'.
  (defalias 'straight-ಠ_ಠ-mode nil))

;; Enable the corgi-packages repository so we can install our packages with
;; Straight. This also runs some Corgi initialization code, notably copying over
;; Corgi's version file, so you get the same versions of packages that Corgi was
;; tested with.

(use-package corgi-packages
  :straight (corgi-packages
             :type git
             :host github
             :repo "corgi-emacs/corgi-packages"))

(add-to-list 'straight-recipe-repositories 'corgi-packages)

#+end_src
Sometimes it's good to clean up unused repositories if I've removed packages from my configuration.
Use =straight-remove-unused-repos= for this purpose.

** Emacs Environment inherited from shell
:PROPERTIES:
:header-args: :noweb-ref environment
:END:
Setup the Emacs environment from the local env
#+begin_src emacs-lisp
(defun my-load-envvars-file (file &optional noerror)
  "Read and set envvars from FILE.
If NOERROR is non-nil, don't throw an error if the file doesn't exist or is
unreadable. Returns the names of envvars that were changed."
  (if (not (file-readable-p file))
      (unless noerror
        (signal 'file-error (list "Couldn't read envvar file" file)))
    (let (envvars environment)
      (with-temp-buffer
        (save-excursion
          (insert "\n")
          (insert-file-contents file))
        (while (re-search-forward "\n *\\([^#= \n]*\\)=" nil t)
          (push (match-string 1) envvars)
          (push (buffer-substring
                 (match-beginning 1)
                 (1- (or (save-excursion
                           (when (re-search-forward "^\\([^= ]+\\)=" nil t)
                             (line-beginning-position)))
                         (point-max))))
                environment)))
      (when environment
        (setq process-environment
              (append (nreverse environment) process-environment)
              exec-path
              (if (member "PATH" envvars)
                  (append (split-string (getenv "PATH") path-separator t)
                          (list exec-directory))
                exec-path)
              shell-file-name
              (if (member "SHELL" envvars)
                  (or (getenv "SHELL") shell-file-name)
                shell-file-name))
        envvars))))
 ;; to create doom env file doom env -o ~/.cache/emacs/env

(when (and (or (display-graphic-p)
               (daemonp))
           (file-exists-p my-env-file))
  (my-load-envvars-file my-env-file))

;; (use-package exec-path-from-shell
;;   :when (memq window-system '(mac ns))
;;   :hook (emacs-startup . (lambda ()
;;                (setq exec-path-from-shell-arguments '("-l")) ; removed the -i for faster startup
;;                (exec-path-from-shell-initialize)))
;;    :config
;;    (exec-path-from-shell-copy-envs
;;     '("GOPATH"  "GOPROXY" "HOMEBREW_PREFIX"
;;       "XDG_CACHE_HOME" "XDG_CONFIG_HOME"
;;   ;;    "NPMBIN" "LC_ALL" "LANG" "LC_TYPE"
;;       "SSH_AGENT_PID" "SSH_AUTH_SOCK" "SHELL"
;;       "JAVA_HOME"))
;;   )

#+end_src
*** Shell Environment init-env
:PROPERTIES:
:header-args: :tangle lisp/init-env.el :noweb yes
:END:
load environment for Emacs from shell

#+begin_src emacs-lisp
;;; init-env.el --- Setup Environment -*- lexical-binding: t -*-

<<disclaimer>>
;;
;;; Code:

<<environment>>

(provide 'init-env)
;;; init-env.el ends here
#+end_src
** init-elpa tangle
*** Straight and use-package
:PROPERTIES:
:header-args: :tangle lisp/init-elpa.el :noweb yes
:END:
"Setup" of setup.el the emacs package manager and package setup to replace use-package

#+begin_src emacs-lisp
;;; init-elpa.el --- Initialise ELPA & Straight -*- lexical-binding: t -*-
<<disclaimer>>
;;
;; Setup Emacs for installing packages from MELPA and Git
;; repositories. Enable configuration via `use-package.
;;; Code:

(require 'config-path)

<<straight-setup>>

(provide 'init-elpa)
;;; init-elpa.el ends here
#+end_src
* Emacs Sane Setup
** Constants

Set Up Good Defaults. [[https://github.com/protesilaos][Protesilaos]] has a few utilities that he keeps re-using in various parts of my Emacs code base. To keep things modular, I place them all in a dedicated prot-common.el file, which can then be marked as a dependency by other libraries of mine. As such, all we do here is load the file.
#+begin_src emacs-lisp :noweb-ref constants
;;; Initialise Gas Constants
;;(defconst *is-nativecomp?* (if (fboundp 'native-comp-available-p) (native-comp-available-p)))

;;(defconst IS_MAC?        (eq system-type 'darwin))
;;(defconst *IS_LINUX?*      (eq system-type 'gnu/linux))
(defconst IS_TERMUX?
    (string-suffix-p "Android" (string-trim (shell-command-to-string "uname -a"))))

#+end_src
*** Emacs PATH config and constants
:PROPERTIES:
:header-args: :tangle lisp/config-path.el :noweb yes
:END:
#+begin_src emacs-lisp
;;; config-path.el --- Path constants -*- lexical-binding: t -*-

<<disclaimer>>
;;
;; This module defines path constants used across other modules.
;;
;;; Code:
<<constants>>

<<path-config>>

<<native-compile>>

(provide 'config-path)
;;; config-path.el ends here
#+end_src
** Sanity settings
:PROPERTIES:
:header-args: :noweb-ref sanity
:END:
Setup Builtins and try and get some sane defaults
#+begin_src emacs-lisp
(use-package diminish)

;; sanity setting UI
(use-package emacs
    :straight nil
    :diminish
    abbrev-mode
    elisp-slime-nav-mode
    eldoc-mode
    subword-mode
    auto-fill-function " AF"
    visual-line-mode
    org-indent-mode
    auto-revert-mode
    subword-mode
    text-scale-mode
    buffer-face-mode
    pretty-control-l-mode
    projectile-mode "Prjl"
    global-form-feed-mode ""
    :init
    (setq read-process-output-max (* 1024 1024)) ;; 1mb

    ;; always allow 'y' instead of 'yes'.
    (defalias 'yes-or-no-p 'y-or-n-p)

    ;; don't want ESC as a modifier
    (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

    ;; disable a few keybindings
    (unbind-key "C-z") ;; `suspend-frame'
    (unbind-key "C-c o") ;; was bound to open a file externally
    ;;(unbind-key "C-x C-c") ;; was `save-buffers-kill-terminal'

    (global-set-key (kbd "<M-delete>") 'kill-word)
    (global-set-key (kbd "<s-down>") 'end-of-buffer)
    (global-set-key (kbd "<s-up>") 'beginning-of-buffer)
    (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
    (global-set-key (kbd "s-w") 'kill-current-buffer)
    (global-set-key (kbd "C-x C-b") 'ibuffer)
    ;;(global-set-key (kbd "M-RET") 'newline-and-indent)
    :config
    (setq ad-redefinition-action 'accept)
    (setq bidi-inhibit-bpa t)
    (setq command-line-ns-option-alist nil)
    (setq confirm-kill-processes nil)
    (setq default-input-method "TeX")
    (setq ffap-machine-p-known 'reject)
    (setq inhibit-compacting-font-caches t)
    (setq inhibit-default-init t)
    (setq jit-lock-defer-time nil)
    (setq jka-compr-verbose nil)
    (setq native-comp-async-report-warnings-errors nil)
    (setq read-file-name-completion-ignore-case t)
    (setq redisplay-skip-fontification-on-input t))

  

  (use-package recentf
  ;; Keep track of recently opened files
    :straight nil
    :commands recent-open-files
    :custom (recentf-save-file (concat EMACS_CACHE/ "recentf"))
    :config
    (setq recentf-auto-cleanup nil     ; Don't. We'll auto-cleanup on shutdown
	  recentf-max-saved-items 200) ; default is 20

    (defun doom--recentf-file-truename-fn (file)
      (if (or (not (file-remote-p file))
	      (equal "sudo" (file-remote-p file 'method)))
	  (abbreviate-file-name (file-truename (tramp-file-name-localname tfile)))
	file))

    ;; Resolve symlinks, strip out the /sudo:X@ prefix in local tramp paths, and
    ;; abbreviate $HOME ~ in filepaths (more portable, more readable, & saves
    ;; space)
    (add-to-list 'recentf-filename-handlers #'doom--recentf-file-truename-fn)

    ;; Text properties inflate the size of recentf's files, and there is
    ;; no purpose in persisting them (Must be first in the list!)
    (add-to-list 'recentf-filename-handlers #'substring-no-properties)

    (setq recentf-exclude `(,(expand-file-name "straight/build/" user-emacs-directory)
			    ,(expand-file-name "eln-cache/" user-emacs-directory)
			    ,(expand-file-name "etc/" EMACS_CACHE/ )
			    ,(expand-file-name "var/" user-emacs-directory)))
    (add-to-list 'recentf-exclude (format "%s/early-init.el" EMACS_CONFIG/ ))
    (add-to-list 'recentf-exclude (format "%s/init.el" EMACS_CONFIG/ ))
    (recentf-mode +1))

  (use-package files
    :straight nil
    :preface
    (defun gas/find-file-sudo-root ()
      "Open a file as the root user.
	Reference: https://www.emacswiki.org/emacs/TrampMode#h5o-19"
      (interactive)
      (require 'tramp)
      (let* ((name (or buffer-file-name default-directory))
	     (tramp (and (tramp-tramp-file-p name)
			 (tramp-dissect-file-name name)))
	     path dir file)
	(when tramp ; If called from a "root" file, we need to fix up the path.
	  (setq path (tramp-file-name-localname tramp)
		dir (file-name-directory path)))
	(when (setq file (read-file-name "Find file (sudo): " dir path))
	  (find-file (concat "/sudo:root@localhost:" file)))))
    :config
    (remove-hook 'find-file-hook 'vc-refresh-state) ; makes open files faster
    (setq confirm-kill-processes nil)

    (setq revert-without-query '(".*"))
    (setq auto-mode-case-fold nil)
    (setq auto-save-default nil)
    (setq auto-save-list-file-prefix nil)

    ;; Move files to trash when deleting
    (setq delete-by-moving-to-trash t)

    (setq find-file-suppress-same-file-warnings t)
    (setq find-file-visit-truename t)
    (setq load-prefer-newer t)

    (setq create-lockfiles nil) ; don't create .# files (crashes 'npm start')
    ;; Don't make backup~ files
    ;; (setq make-backup-files nil)
    ;; (setq backup-inhibited t)

    (when (not (file-directory-p (expand-file-name "backups" EMACS_CACHE/ )))
      (make-directory (expand-file-name "backups" EMACS_CACHE/ )))

    (when (not (file-directory-p (expand-file-name "auto-save-list" EMACS_CACHE/ )))
      (make-directory (expand-file-name "auto-save-list" EMACS_CACHE/ )))

    ;; Put backups and auto-save files in subdirectories, so the
    ;; user-emacs-directory doesn't clutter
    (setq backup-directory-alist
	  `(("." . ,(expand-file-name "backups" EMACS_CACHE/ )))
	  auto-save-file-name-transforms
	  `((".*" ,(expand-file-name "auto-save-list/" EMACS_CACHE/ ) t)))

    (setq require-final-newline t)

    ;; Stop asking about following symlinks to version controlled files
    (setq vc-follow-symlinks t)

    ;; big files
    (global-so-long-mode 1)

    ;; sudo find file
    (global-set-key (kbd "C-c C-f") #'gas/find-file-sudo-root)
    (global-set-key (kbd "<f6>") #'(lambda ()
				     (interactive)
				     (revert-buffer)
				     (message "attente de rafraîchissement du buffer...fini"))))

  ;; save-place remembers the position of pt in a buffer and on re-opening restores it
  (use-package saveplace
    :straight nil
    :config (save-place-mode 1))
  ;; savehist same as saveplace but for history
  (use-package savehist
    :straight nil
    :custom (savehist-file (concat EMACS_CACHE/ "savehist"))
    :config
     (setq savehist-save-minibuffer-history t
	  savehist-autosave-interval nil     ; save on kill only
	  savehist-additional-variables
	  '(kill-ring                        ; persist clipboard
	    register-alist                   ; persist macros
	    mark-ring global-mark-ring       ; persist marks
	    search-ring regexp-search-ring)) ; persist searches
    (add-hook 'savehist-save-hook
      (defun doom-savehist-unpropertize-variables-h ()
	"Remove text properties from `kill-ring' to reduce savehist cache size."
	(setq kill-ring
	      (mapcar #'substring-no-properties
		      (cl-remove-if-not #'stringp kill-ring))
	      register-alist
	      (cl-loop for (reg . item) in register-alist
		       if (stringp item)
		       collect (cons reg (substring-no-properties item))
		       else collect (cons reg item))))
      (defun doom-savehist-remove-unprintable-registers-h ()
	"Remove unwriteable registers (e.g. containing window configurations).
  Otherwise, `savehist' would discard `register-alist' entirely if we don't omit
  the unwritable tidbits."
	;; Save new value in the temp buffer savehist is running
	;; `savehist-save-hook' in. We don't want to actually remove the
	;; unserializable registers in the current session!
	(setq-local register-alist
		    (cl-remove-if-not #'savehist-printable register-alist)))))

#+end_src
*** Tangle Sanity Defaults
:PROPERTIES:
:header-args: :tangle lisp/init-sanity.el :noweb yes
:END:

"Setup" of Emacs to some sort of sanity

#+begin_src emacs-lisp
;;; init-sanity.el --- Sanity -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<sanity>>

<<editor-sanity>>

(provide 'init-sanity)
;;; init-sanity.el ends here
#+end_src

** Emacs Startup Setup
Show startup time
#+begin_src emacs-lisp :noweb-ref startup-time
(require 'cl-lib)

(defun mf/rename-file ()
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' n'a ​​pas de fichier associé!" name)
      (let* ((dir (file-name-directory filename))
             (new-name (read-file-name "Nouveau nom de fichier: " dir)))
        (cond ((get-buffer new-name)
               (error "Un Buffer nommé '%s' existe déjà!" new-name))
              (t
               (let ((dir (file-name-directory new-name)))
                 (when (and (not (file-exists-p dir))
                            (yes-or-no-p (format "Créer le répertoire '%s'?"
                                                 dir)))
                   (make-directory dir t)))
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)
               (when (fboundp 'recentf-add-file)
                 (recentf-add-file new-name)
                 (recentf-remove-if-non-kept filename))
               (message "Fichier '%s' renommé avec succès en '%s'" name
                        (file-name-nondirectory new-name))))))))

(defun doom-unquote (exp)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

(defun doom-keyword-intern (str)
  "Converts STR (a string) into a keyword (`keywordp')."
  (declare (pure t) (side-effect-free t))
  (cl-check-type str string)
  (intern (concat ":" str)))

(defun doom-keyword-name (keyword)
  "Returns the string name of KEYWORD (`keywordp') minus the leading colon."
  (declare (pure t) (side-effect-free t))
  (cl-check-type keyword keyword)
  (substring (symbol-name keyword) 1))

(defun +ensure-after-init (function)
  "Ensure FUNCTION runs after init, or now if already initialised.
  If Emacs is already started, run FUNCTION.  Otherwise, add it to
  `after-init-hook'.  FUNCTION is called with no arguments."
  (if after-init-time
      (funcall function)
    (add-hook 'after-init-hook function)))

;;
;;; Helpers

(defun doom--resolve-hook-forms (hooks)
  "Converts a list of modes into a list of hook symbols.

If a mode is quoted, it is left as is. If the entire HOOKS list is quoted, the
list is returned as-is."
  (declare (pure t) (side-effect-free t))
  (let ((hook-list (doom-enlist (doom-unquote hooks))))
    (if (eq (car-safe hooks) 'quote)
        hook-list
      (cl-loop for hook in hook-list
               if (eq (car-safe hook) 'quote)
               collect (cadr hook)
               else collect (intern (format "%s-hook" (symbol-name hook)))))))

;;
;;; Sugars

(defun dir! ()
  "Returns the directory of the emacs lisp file this macro is called from."
  (when-let (path (file!))
    (directory-file-name (file-name-directory path))))

(defun file! ()
  "Return the emacs lisp file this macro is called from."
  (cond ((bound-and-true-p byte-compile-current-file))
        (load-file-name)
        ((stringp (car-safe current-load-list))
         (car current-load-list))
        (buffer-file-name)
        ((error "Cannot get this file-path"))))

;;; Loading
(defmacro add-load-path! (&rest dirs)
  "Add DIRS to `load-path', relative to the current file.
The current file is the file from which `add-to-load-path!' is used."
  `(let ((default-directory ,(dir!))
         file-name-handler-alist)
     (dolist (dir (list ,@dirs))
       (cl-pushnew (expand-file-name dir) load-path :test #'string=))))

;;; Hooks
(defmacro add-transient-hook! (hook-or-function &rest forms)
  "Attaches a self-removing function to HOOK-OR-FUNCTION.

FORMS are evaluated once, when that function/hook is first invoked, then never
again.

HOOK-OR-FUNCTION can be a quoted hook or a sharp-quoted function (which will be
advised)."
  (declare (indent 1))
  (let ((append (if (eq (car forms) :after) (pop forms)))
        ;; Avoid `make-symbol' and `gensym' here because an interned symbol is
        ;; easier to debug in backtraces (and is visible to `describe-function')
        (fn (intern (format "doom--transient-%d-h"
                            (put 'add-transient-hook! 'counter
                                 (1+ (or (get 'add-transient-hook! 'counter)
                                         0)))))))
    `(let ((sym ,hook-or-function))
       (defun ,fn (&rest _)
         ,(format "Transient hook for %S" (doom-unquote hook-or-function))
         ,@forms
         (let ((sym ,hook-or-function))
           (cond ((functionp sym) (advice-remove sym #',fn))
                 ((symbolp sym)   (remove-hook sym #',fn))))
         (unintern ',fn nil))
       (cond ((functionp sym)
              (advice-add ,hook-or-function ,(if append :after :before) #',fn))
             ((symbolp sym)
              (put ',fn 'permanent-local-hook t)
              (add-hook sym #',fn ,append))))))

(defmacro add-hook! (hooks &rest rest)
  "A convenience macro for adding N functions to M hooks.

This macro accepts, in order:

  1. The mode(s) or hook(s) to add to. This is either an unquoted mode, an
     unquoted list of modes, a quoted hook variable or a quoted list of hook
     variables.
  2. Optional properties :local, :append, and/or :depth [N], which will make the
     hook buffer-local or append to the list of hooks (respectively),
  3. The function(s) to be added: this can be a quoted function, a quoted list
     thereof, a list of `defun' or `cl-defun' forms, or arbitrary forms (will
     implicitly be wrapped in a lambda).

\(fn HOOKS [:append :local [:depth N]] FUNCTIONS-OR-FORMS...)"
  (declare (indent (lambda (indent-point state)
                     (goto-char indent-point)
                     (when (looking-at-p "\\s-*(")
                       (lisp-indent-defform state indent-point))))
           (debug t))
  (let* ((hook-forms (doom--resolve-hook-forms hooks))
         (func-forms ())
         (defn-forms ())
         append-p local-p remove-p depth)
    (while (keywordp (car rest))
      (pcase (pop rest)
        (:append (setq append-p t))
        (:depth  (setq depth (pop rest)))
        (:local  (setq local-p t))
        (:remove (setq remove-p t))))
    (while rest
      (let* ((next (pop rest))
             (first (car-safe next)))
        (push (cond ((memq first '(function nil))
                     next)
                    ((eq first 'quote)
                     (let ((quoted (cadr next)))
                       (if (atom quoted)
                           next
                         (when (cdr quoted)
                           (setq rest (cons (list first (cdr quoted)) rest)))
                         (list first (car quoted)))))
                    ((memq first '(defun cl-defun))
                     (push next defn-forms)
                     (list 'function (cadr next)))
                    ((prog1 `(lambda (&rest _) ,@(cons next rest))
                       (setq rest nil))))
              func-forms)))
    `(progn
       ,@defn-forms
       (dolist (hook (nreverse ',hook-forms))
         (dolist (func (list ,@func-forms))
           ,(if remove-p
                `(remove-hook hook func ,local-p)
              `(add-hook hook func ,(or depth append-p) ,local-p)))))))

(defmacro defadvice! (symbol arglist &optional docstring &rest body)
  "Define an advice called SYMBOL and add it to PLACES.

ARGLIST is as in `defun'. WHERE is a keyword as passed to `advice-add', and
PLACE is the function to which to add the advice, like in `advice-add'.
DOCSTRING and BODY are as in `defun'.

\(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
  (declare (doc-string 3) (indent defun))
  (unless (stringp docstring)
    (push docstring body)
    (setq docstring nil))
  (let (where-alist)
    (while (keywordp (car body))
      (push `(cons ,(pop body) (doom-enlist ,(pop body)))
            where-alist))
    `(progn
       (defun ,symbol ,arglist ,docstring ,@body)
       (dolist (targets (list ,@(nreverse where-alist)))
         (dolist (target (cdr targets))
           (advice-add target (car targets) #',symbol))))))

#+end_src
*** Tangle lib-fn-macros
:PROPERTIES:
:header-args: :tangle lisp/lib-fn-macros.el :noweb yes
:END:

File for my constants, macros and functions
#+begin_src emacs-lisp
;;; lib-fn-macros.el --- Util fns -*- lexical-binding: t -*-
<<disclaimer>>

;;; Code:

;;; ============================================================================
;;; Variables
;;; ============================================================================

<<variables>>

;;; ============================================================================
;;; Macros
;;; ============================================================================

<<macros>>

;;; ============================================================================
;;; Functions
;;; ============================================================================

<<functions>>

(provide 'lib-fn-macros)
;;; lib-fn-macros.el ends here
#+end_src

* Emacs UI Appearance
*** Default Appearance setting
Some Defaults for my preferred appearance
#+begin_src emacs-lisp :noweb-ref appearance
(use-package emacs
  :straight nil
  :hook (prog-mode text-mode conf-mode)
  :init
  (add-hook 'prog-mode-hook #'display-line-numbers-mode )
  (add-hook 'text-mode-hook #'visual-line-mode )
  :config
  (setq-default
   inhibit-startup-message t
   inhibit-startup-screen t
   inhibit-startup-echo-area-message user-login-name
   inhibit-default-init t
   ;;initial-major-mode 'fundamental-mode
   ;;initial-scratch-message nil
   use-file-dialog nil
   use-dialog-box nil)

  (setq display-time-default-load-average nil)
  (setq echo-keystrokes 0.1)
  (setq highlight-nonselected-windows nil)
  (setq visible-bell nil)
  (setq x-gtk-use-system-tooltips nil)
  (setq x-stretch-cursor nil)

  ;; update
  (setq idle-update-delay 1.0)

  ;; disable cursor blinking
  (blink-cursor-mode -1)
  (setq blink-matching-paren nil)
  ;; hide cursors in other windose
  (setq-default cursor-in-non-selected-windows nil)
  (setq-default cursor-type 'hbar)

  ;; play around with frame title (which I rarely see)
  (setq frame-title-format
        '("%b@"
          (:eval (or (file-remote-p default-directory 'host)
                     system-name))
          " — Emacs"))

  ;; y/n instead of yes/no
  (fset #'yes-or-no-p #'y-or-n-p)

  ;; mode line
  (column-number-mode)
  (size-indication-mode)
  ;; Wait until my *fancy* modeline is loaded -- from Furkan Karataş.
  (setq-default mode-line-format nil)

  (let ((font "Iosevka Term Curly Medium 14"))
  (add-to-list 'default-frame-alist `(font . ,font))
  (set-face-attribute 'default t :font font :height 140)
  (set-face-attribute 'default nil :font font :height 140)
  (set-frame-font font nil t))
  ;; line numbers
  (setq-default display-line-numbers-widen t)
  (setq-default display-line-numbers-width 3)

  (setq-default
   ;; no beeping and no blinking please
   ring-bell-function #'ignore
   visible-bell nil

   ;; make sure that trash is not drawn
   indicate-buffer-boundaries nil

   ;; don't resize emacs in steps, it looks weird and plays bad with
   ;; window manager.
   window-resize-pixelwise t
   frame-resize-pixelwise t

   ;; disable bidirectional text for tiny performance boost
   bidi-display-reordering 'left-to-right
   bidi-paragraph-direction 'left-to-right

   ;; truncate lines
   ;;truncate-lines t

   ;; fringes
   indicate-empty-lines nil  ;; end of buffer indicate
   indicate-buffer-boundaries 'right
   ;; continuation lines at keft fringe
   visual-line-fringe-indicators '(left-curly-arrow nil)
   )
   ;; curly arrows - continuation
   (define-fringe-bitmap 'left-curly-arrow
     [#b11000000
      #b01100000
      #b00110000
      #b00011000])

   (define-fringe-bitmap 'right-curly-arrow
     [#b00011000
      #b00110000
      #b01100000
      #b11000000])
   ;; arrows - truncation lines
   (define-fringe-bitmap 'left-arrow
     [#b00000000
      #b01010100
      #b01010100
      #b00000000])

   (define-fringe-bitmap 'right-arrow
     [#b00000000
      #b00101010
      #b00101010
      #b00000000])

  (menu-bar-mode 1)
  )


(use-package form-feed
  :config (global-form-feed-mode))



#+end_src
*** Fonts, Emojis & Icons

On Linux, I have a custom build of Iosevka that I like.

#+begin_src emacs-lisp :noweb-ref fonts
(use-package all-the-icons
  :if (display-graphic-p)
  :after (marginalia dired)
  :init
  (add-hook 'marginalia-mode #'all-the-icons-completion-marginalia-setup)
  (add-hook 'dired-mode #'all-the-icons-dired-mode)
  :config
  (use-package all-the-icons-dired)
  (use-package all-the-icons-completion)
  :config
  (all-the-icons-completion-mode 1))

(use-package emojify
  :config
  (setq emojify-emoji-styles '(unicode))
  (global-emojify-mode 1))

(use-package unicode-fonts
  :config
  (unicode-fonts-setup))

;; (use-package mixed-pitch
;;   :config
;;   :hook (text-mode org-mode))

;; Required for proportional font in posframe
;; (use-package company-posframe
;;   :diminish company-posframe-mode
;;   :config
;;   (company-posframe-mode 1))

(use-package default-text-scale
  :bind (( "M--" . default-text-scale-decrease)
         ( "M-+" . default-text-scale-increase)
         ( "M-=" . default-text-scale-reset))
  :config
  (setq default-text-scale-mode 1))

;; Dimm the colours of inactive windows
(use-package dimmer
  :config
  (setq dimmer-fraction 0.3)
  (setq dimmer-adjustment-mode :foreground)
  (setq dimmer-use-colorsapce :rgb)
  (dimmer-mode 1))

#+end_src

*** Mouse & scrolling setup

#+begin_src emacs-lisp :noweb-ref mouse

(unless IS_TERMUX?
  (use-package mouse
    :straight nil
    :config
    ;; mouse setup
    (setq focus-follows-mouse t)
    (setq make-pointer-invisible t)
    (setq mouse-1-click-follows-link t)
    (setq mouse-autoselect-window t)
    (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
    ;;(setq mouse-wheel-scroll-amount '(3 ((shift) . hscroll)))
    (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
    (setq mouse-wheel-scroll-amount-horizontal 2)
    (setq mouse-yank-at-point t)
    (setq scroll-step 1) ;; keyboard scroll one line at a time
    (setq use-dialog-box nil) ;; Disable dialog boxes since they weren't working in Mac OSX
    ;; scrolling
    (setq auto-hscroll-mode 'current-line)
    (setq auto-window-vscroll nil)
    (setq fast-but-imprecise-scrolling t)
    (setq hscroll-margin 16)
    (setq hscroll-step 1)
    (setq scroll-conservatively 101)
    (setq scroll-margin 8)
    (setq scroll-preserve-screen-position t)
    (setq scroll-step 1)))




#+end_src

*** Themes & Modeline
Load up some themes

#+begin_src emacs-lisp :noweb-ref modus
;;; Modus themes (Prositelaus highly accessible themes)
(use-package modus-themes
  ;; :straight (modus-themes :type built-in)

  :straight (:type git :host gitlab :repo "protesilaos/modus-themes" :branch "main")
  ;; Add all your customisations prior to loading the themes
  ;;
  ;;:requires highlight-parentheses
  ;; Also check my package configurations for `prot-fonts' because I use
  ;; the `modus-themes-after-load-theme-hook' for some typeface-related
  ;; tweaks (as those are made at the "face" level).
  :bind ( "<f5>" .  #'modus-themes-toggle)
  :config
  (setq
   modus-themes-vivendi-color-overrides
   ;; '((bg-region-accent-subtle . "#240f55")) ;; Default
    '((bg-region-accent-subtle . "#323da2")) ;; Good candidate
   ;;   '((bg-region-accent-subtle . "#304466"))

   modus-themes-italic-constructs t
   modus-themes-bold-constructs t
   modus-themes-mixed-fonts nil
   modus-themes-scale-headings t
   modus-themes-slanted-constructs t
   modus-themes-subtle-line-numbers t
   modus-themes-intense-mouseovers nil
   modus-themes-deuteranopia t
   modus-themes-tabs-accented t
   modus-themes-variable-pitch-ui t
   modus-themes-inhibit-reload t ; only applies to `customize-set-variable' and related

   modus-themes-fringes 'intense ; {nil,'subtle,'intense}

   ;; Options for `modus-themes-lang-checkers' are either nil (the
   ;; default), or a list of properties that may include any of those
   ;; symbols: `straight-underline', `text-also', `background',
   ;; `intense' OR `faint'.
   modus-themes-lang-checkers nil

   ;; Options for `modus-themes-mode-line' are either nil, or a list
   ;; that can combine any of `3d' OR `moody', `borderless',
   ;; `accented', a natural number for extra padding (or a cons cell
   ;; of padding and NATNUM), and a floating point for the height of
   ;; the text relative to the base font size (or a cons cell of
   ;; height and FLOAT)
   modus-themes-mode-line '(moody accented (padding . 4) (height . 0.9))

   ;; Options for `modus-themes-markup' are either nil, or a list
   ;; that can combine any of `bold', `italic', `background',
   ;; `intense'.
   modus-themes-markup nil

   ;; Options for `modus-themes-syntax' are either nil (the default),
   ;; or a list of properties that may include any of those symbols:
   ;; `faint', `yellow-comments', `green-strings', `alt-syntax'
   modus-themes-syntax '(alt-syntax yellow-comments green-strings)

   ;; Options for `modus-themes-hl-line' are either nil (the default),
   ;; or a list of properties that may include any of those symbols:
   ;; `accented', `underline', `intense'
   modus-themes-hl-line '(accented intense)

   ;; Options for `modus-themes-paren-match' are either nil (the
   ;; default), or a list of properties that may include any of those
   ;; symbols: `bold', `intense', `underline'
   modus-themes-paren-match '(bold intense)

   ;; Options for `modus-themes-links' are either nil (the default),
   ;; or a list of properties that may include any of those symbols:
   ;; `neutral-underline' OR `no-underline', `faint' OR `no-color',
   ;; `bold', `italic', `background'
   modus-themes-links '(faint background)

   ;; Options for `modus-themes-box-buttons' are either nil (the
   ;; default), or a list that can combine any of `flat',
   ;; `accented', `faint', `variable-pitch', `underline', the
   ;; symbol of any font weight as listed in
   ;; `modus-themes-weights', and a floating point number
   ;; (e.g. 0.9) for the height of the button's text.
   modus-themes-box-buttons '(variable-pitch flat faint 0.9)

   ;; Options for `modus-themes-prompts' are either nil (the
   ;; default), or a list of properties that may include any of those
   ;; symbols: `background', `bold', `gray', `intense', `italic'
   modus-themes-prompts '(intense accented)

   ;; The `modus-themes-completions' is an alist that reads three
   ;; keys: `matches', `selection', `popup'.  Each accepts a nil
   ;; value (or empty list) or a list of properties that can include
   ;; any of the following (for WEIGHT read further below):
   ;;
   ;; `matches' - `background', `intense', `underline', `italic', WEIGHT
   ;; `selection' - `accented', `intense', `underline', `italic', `text-also', WEIGHT
   ;; `popup' - same as `selected'
   ;; `t' - applies to any key not explicitly referenced (check docs)
   ;;
   ;; WEIGHT is a symbol such as `semibold', `light', or anything
   ;; covered in `modus-themes-weights'.  Bold is used in the absence
   ;; of an explicit WEIGHT.
   modus-themes-completions
   '((matches . (extrabold background))
     (selection . (semibold intense accented text-also))
     (popup . (accented intense)))

   modus-themes-mail-citations nil ; {nil,'intense,'faint,'monochrome}

   ;; Options for `modus-themes-region' are either nil (the default),
   ;; or a list of properties that may include any of those symbols:
   ;; `no-extend', `bg-only', `accented'
   modus-themes-region '(bg-only accented)

   ;; Options for `modus-themes-diffs': nil, 'desaturated, 'bg-only
   modus-themes-diffs 'desaturated

   modus-themes-org-blocks 'gray-background ; {nil,'gray-background,'tinted-background}

   modus-themes-org-agenda ; this is an alist: read the manual or its doc string
   '((header-block . (variable-pitch regular 1.5))
     (header-date . (bold-today grayscale underline-today 1.2))
     (event . (accented varied))
     (scheduled . uniform)
     (habit . nil))

   ;; modus-themes-headings ; this is an alist: read the manual or its doc string
   ;; '((1 . (variable-pitch light 1.6))
   ;;   (2 . (variable-pitch regular 1.4))
   ;;   (3 . (variable-pitch regular 1.3))
   ;;   (4 . (1.2))
   ;;   (5 . (1.1))
   ;;   (t . (monochrome 1.05))))

   modus-themes-headings
   '((1 . (variable-pitch light 1.6))
     (2 . (overline semibold 1.4))
     (3 . (monochrome overline 1.2 background))
     (4 . (overline 1.1))
     (t . (rainbow 1.05))))

  ;; Load the theme files before enabling a theme (else you get an error).
  (modus-themes-load-themes)

  (let ((time (string-to-number (format-time-string "%H"))))
    (if (and (> time 7) (< time 18))
        (modus-themes-load-operandi)
      (modus-themes-load-vivendi))))

;; doom themes
;; (use-package doom-themes
;;   :defer t
;;   :config
;;   (setq doom-themes-enable-bold t)
;;   (setq doom-themes-enable-italic t)
;;   (doom-themes-org-config))

#+end_src

Modeline stuff

#+begin_src emacs-lisp :noweb-ref modeline
;; (use-package bui
;; ;; buffer user interface - info and buffer layout
;; :defer t)

;; Mode-line
;;Basic Customisation
(setq display-time-format "%l:%M %p %b %y"
     display-time-default-load-average nil)

;; Change the colour of the modeline based on the Evil state (e.g. green when
;; in insert state)
;; (use-package corgi-stateline
;;   :config
;;   (global-corgi-stateline-mode))
(use-package mood-line
  :straight (:host github :repo "benjamin-asdf/mood-line")
  :config
  (setf mood-line-show-cursor-point t)
  (mood-line-mode))

;; Corgi or Doom Modeline
;;(use-package minions)
   ;; lists enable minor-modes)

#+end_src

*** highlights and diff
:PROPERTIES:
:ID:                     6d744ef7-add5-408d-8f5f-e7112027ce62
:END:
setup diff and highlights
#+begin_src emacs-lisp :noweb-ref highlights
  (use-package highlight-numbers
    :diminish t
    :hook prog-mode
    )

  (use-package hl-fill-column
    :requires hl-fill-column
    :hook (prog-mode text-mode conf-mode))

  (use-package hl-line
    :config
    (global-hl-line-mode 1))

  (use-package hl-todo
    :config
    (global-hl-todo-mode 1))

  (use-package diff-hl
    :after magit
    :init
    (add-hook 'dired-mode #'diff-hl-dired-mode)
    (add-hook 'magit-pre-refesh-hook #'diff-hl-magit-pre-refresh)
    (add-hook 'magit-post-refesh-hook #'diff-hl-magit-post-refresh)
    :config
    (global-diff-hl-mode 1))

#+end_src
*** Window Setup
:PROPERTIES:
:header-args: :noweb-ref windose
:END:

1st some defaults

#+begin_src emacs-lisp
  (setup windows
      (setq display-buffer-alist
        `(;; no window
          ("\\`\\*Async Shell Command\\*\\'"
           (display-buffer-no-window))
          ;; top side window
          ("\\*\\(Flymake diagnostics\\|Package-Lint\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Flymake log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2))
          ;; left side window
          ("\\*\\(.* # Help.*\\|Help\\)\\*"    ; See the hooks for `visual-line-mode'
           (display-buffer-reuse-mode-window display-buffer-in-side-window)
           (window-width . 0.25)
           (side . left)
           (slot . 0))
          ;; right side window
          ("\\*keycast\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (window-width . 0.25)
           (side . right)
           (slot . -1)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; bottom side window
          ("\\*Org Select\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((mode-line-format . none))))
          ;; bottom buffer (NOT side window)
          ("\\*Embark Actions\\*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . fit-window-to-buffer)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; below current window
          ("\\*.*\\(e?shell\\|v?term\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected))
          ("\\*\\vc-\\(incoming\\|outgoing\\|git : \\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           ;; NOTE 2021-10-06: we cannot `fit-window-to-buffer' because
           ;; the height is not known in advance.
           (window-height . 0.2))
          ("\\*\\(Calendar\\|Bookmark Annotation\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . fit-window-to-buffer))))
      ;;(setq split-height-threshold nil)
      ;;(setq split-width-threshold 160)
      (setq window-divider-default-bottom-width 2)
      (setq window-divider-default-places t)
      (setq window-divider-default-right-width 2)
      (setq window-resize-pixelwise nil)
      (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)

  (add-hook 'help-mode-hook #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)

  (let ((map global-map))
    (define-key map (kbd "C-x <down>") #'next-buffer)
    (define-key map (kbd "C-x <up>") #'previous-buffer)
    (define-key map (kbd "C-x C-n") #'next-buffer)     ; override `set-goal-column'
    (define-key map (kbd "C-x C-p") #'previous-buffer) ; override `mark-page'
    (define-key map (kbd "C-x !") #'delete-other-windows-vertically)
    (define-key map (kbd "C-x _") #'balance-windows)      ; underscore
    (define-key map (kbd "C-x -") #'fit-window-to-buffer) ; hyphen
    (define-key map (kbd "C-x +") #'balance-windows-area)
    (define-key map (kbd "C-x }") #'enlarge-window)
    (define-key map (kbd "C-x {") #'shrink-window)
    (define-key map (kbd "C-x >") #'enlarge-window-horizontally) ; override `scroll-right'
    (define-key map (kbd "C-x <") #'shrink-window-horizontally)) ; override `scroll-left'

 ;; (let ((map resize-window-repeat-map))
 ;;   (define-key map ">" #'enlarge-window-horizontally)
 ;;   (define-key map "<" #'shrink-window-horizontally))
)

 

#+end_src
#+begin_src emacs-lisp
  ;; (setup (:pkg ace-window)
  ;;   (setq aw-background t)
  ;;   (setq aw-scope 'frame)
  ;;   (ace-window-display-mode 1)
  ;;   (:hide-mode))

(setup (:pkg windmove)
    (setq windmove-create-window nil)     ; Emacs 27.1
  (let ((map global-map))
    ;; Those override some commands that are already available with
    ;; C-M-u, C-M-f, C-M-b.
    (define-key map (kbd "C-M-<up>") #'windmove-up)
    (define-key map (kbd "C-M-<right>") #'windmove-right)
    (define-key map (kbd "C-M-<down>") #'windmove-down)
    (define-key map (kbd "C-M-<left>") #'windmove-left)
    (define-key map (kbd "C-M-S-<up>") #'windmove-swap-states-up)
    (define-key map (kbd "C-M-S-<right>") #'windmove-swap-states-right) ; conflicts with `org-increase-number-at-point'
    (define-key map (kbd "C-M-S-<down>") #'windmove-swap-states-down)
    (define-key map (kbd "C-M-S-<left>") #'windmove-swap-states-left)))

(setup (:pkg winner)
  (winner-mode 1))
  (setq-default window-divider-default-places 'right-only ; only right
                window-divider-default-bottom-width 2
                window-divider-default-right-width 2)
#+end_src

*** Splitting windows sensibly
:PROPERTIES:
:ID:                     43136dd2-3231-485b-89d9-88c8fe9fd6aa
:END:

This is extremely fiddly and I'd love another option.
- [[https://www.emacswiki.org/emacs/ToggleWindowSplit][ToggleWindowSplit, EmacsWiki]]

#+begin_src emacs-lisp :noweb-ref pkg-window
  (defun window-split-vertically ()
      "Split window vertically."
      (interactive)
      (split-window-right))

    (defun window-split-vertically-and-focus ()
      "Split window vertically and focus it."
      (interactive)
      (split-window-right)
      (windmove-right))

    (defun window-split-horizontally ()
      "Split window horizontally."
      (interactive)
      (split-window-below))

    (defun window-split-horizontally-and-focus ()
      "Split window horizontally and focus it."
      (interactive)
      (split-window-below)
      (windmove-down))

    (defun window-zoom ()
      "Close other windows to focus on this one.
    Activate again to undo this. If the window changes before then,
    the undo expires."
      (interactive)
      (if (and (one-window-p)
               (assq ?_ register-alist))
          (jump-to-register ?_)
        (window-configuration-to-register ?_)
        (delete-other-windows)))

  ;;(setq-default split-width-threshold 100
  ;;                  split-height-threshold 50)
#+end_src
*** Distraction Free
:PROPERTIES:
:header-args: :noweb-ref distraction-free
:END:
setup olivetti to have a distraction free editing mode
#+begin_src emacs-lisp :noweb-ref distraction-free
;; Distraction-free screen
(use-package  olivetti
  :config
  (setq olivetti-body-width .67)
  (defun distraction-free ()
    "Distraction-free writing environment"
    (interactive)
    (if (equal olivetti-mode nil)
        (progn
          (window-configuration-to-register 1)
          (delete-other-windows)
          (text-scale-increase 2)
          (olivetti-mode t))
      (progn
        (jump-to-register 1)
        (olivetti-mode 0)
        (text-scale-decrease 2))))
  :bind ("<f9>" .  #'distraction-free))

#+end_src

*** Tangle Emacs UI Appearance
:PROPERTIES:
:header-args: :tangle lisp/init-ui.el :noweb yes
:END:

Tangle My UI

#+begin_src emacs-lisp
;;; init-ui.el --- UI Setup -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<appearance>>

<<mouse>>

<<fonts>>

<<modus>>

<<modeline>>

<<highlights>>

<<distraction-free>>

(provide 'init-ui)
;;; init-ui.el ends here
#+end_src
* Emacs as an Editor
:PROPERTIES:
:header-args: :noweb-ref pkg-editor
:END:
** Emacs Editor Sane Setting
#+begin_src emacs-lisp :noweb-ref editor-sanity
(use-package simple
  :straight nil
  :preface
  (defvar gas/indent-width 2)

  (defun gas/split-and-follow-horizontally ()
    "Split window below."
    (interactive)
    (split-window-below)
    (other-window 1))
  (defun gas/split-and-follow-vertically ()
    "Split window right."
    (interactive)
    (split-window-right)
    (other-window 1))
  :bind (("M-z" . zap-up-to-char)
         ("M-S-z" . zap-to-char)
         ("C-x k" . kill-this-buffer))
  :hook ((before-save . delete-trailing-whitespace)
         (overwrite-mode . overwrite-set-cursor-shape))
  :custom
  (yank-excluded-properties t)
  (blink-matching-delay 0)
  (blink-matching-paren t)
  (copy-region-blink-delay 0)
  :init
  (defun overwrite-set-cursor-shape ()
    (when (display-graphic-p)
      (setq cursor-type (if overwrite-mode 'hollow 'box))))
  :config
  (setq frame-title-format '("Emacs " emacs-version))
  (setq-default default-directory GAS_DEV/ )

  (setq inhibit-startup-message t)
  (setq initial-major-mode #'emacs-lisp-mode)
  (setq initial-scratch-message
        ";; ABANDONNEZ TOUT ESPOIR VOUS QUI ENTREZ ICI\n\n" )
  (defun +scratch-immortal ()
    "Bury, don't kill \"*scratch*\" buffer.
          For `kill-buffer-query-functions'."
    (if (eq (current-buffer) (get-buffer "*scratch*"))
        (progn (bury-buffer)
               nil)
      t))
  (defun +scratch-buffer-setup ()
    "Add comment to `scratch' buffer and name it accordingly."
    (let* ((mode (format "%s" major-mode))
           (string (concat "Scratch buffer for:" mode "\n\n")))
      (when scratch-buffer
        (save-excursion
          (insert string)
          (goto-char (point-min))
          (comment-region (point-at-bol) (point-at-eol)))
        (next-line 2))
      (rename-buffer (concat "*scratch<" mode ">*") t)))
  (add-hook 'kill-buffer-query-functions #'+scratch-immortal)

  ;; Allow pasting selection outside of Emacs
  (setq select-enable-clipboard t)

  ;; Auto refresh buffers
  ;; Also auto refresh dired, but be quiet about it
  (require 'autorevert)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (add-hook 'dired-mode-hook #'auto-revert-mode)
  (global-auto-revert-mode 1)

  ;; Show keystrokes in progress
  (setq echo-keystrokes 0.1)

  ;; Real emacs knights don't use shift to mark things
  (setq shift-select-mode nil)

  ;; Transparently open compressed files
  (auto-compression-mode t)

  ;; Enable syntax highlighting for older Emacsen that have it off
  (global-font-lock-mode t)

  ;; Lines should be 80 characters wide, not 72
  (setq fill-column 80)
  (set-default 'fill-column 80)
  (setq-default lexical-binding t)

  ;; Show active region
  (transient-mark-mode 1)
  (make-variable-buffer-local 'transient-mark-mode)
  (put 'transient-mark-mode 'permanent-local t)
  (setq-default transient-mark-mode t)

  ;; Always display line and column numbers
  (setq line-number-mode t)
  (setq column-number-mode t)

  ;; Never insert tabs
  (set-default 'indent-tabs-mode nil)

  ;; Show me empty lines after buffer end
  (set-default 'indicate-empty-lines t)

  ;; Easily navigate sillycased words
  (global-subword-mode 1)

  ;; Don't break lines for me, please
  ;; (setq-default truncate-lines t)

  ;; Do not allow the cursor in the minibuffer prompt
  ;; (setq minibuffer-prompt-properties
  ;;       '(read-only t cursor-intangible t face minibuffer-prompt))
  ;; (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Allow recursive minibuffers
  (setq enable-recursive-minibuffers t)
  ;; lazy no pressing shift to get the case
  (setq completion-ignore-case t
        read-file-name-completion-ignore-case t
        read-buffer-completion-ignore-case t)

  (setq redisplay-skip-fontification-on-input t)
  (setq scroll-conservatively 101) ;; gt 100
  (setq scroll-preserve-screen-position t)
  (setq fast-but-imprecise-scrolling t)
  (setq auto-window-vscroll nil)
  (setq hscroll-step 1)
  (setq scroll-step 1)
  (setq hscroll-margin 0)
  (setq load-prefer-newer t)
  (setq echo-keystrokes 0.02)
  (setq kill-buffer-query-functions nil)

  ;; ignore bell
  (setq ring-bell-function 'ignore)
  ;; default to utf-8 for all the things
  (set-charset-priority 'unicode)
  (setq locale-coding-system    'utf-8)
  (set-terminal-coding-system   'utf-8)
  (set-keyboard-coding-system   'utf-8)
  (set-selection-coding-system  'utf-8)
  (prefer-coding-system         'utf-8)

  ;; write over selected text on input... like all modern editors do
  (delete-selection-mode t)

  ;; Don't persist a custom file, this bites me more than it helps
  (setq custom-file (make-temp-file "")) ; use a temp file as a placeholder
  (setq custom-safe-themes t)            ; mark all themes as safe, since we can't persist now
  (setq enable-local-variables :all)     ; fix =defvar= warnings

  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'scroll-right 'disabled nil)
  (put 'scroll-left 'disabled nil)
  (global-set-key (kbd "C-x 2") #'gas/split-and-follow-horizontally)
  (global-set-key (kbd "C-x 3") #'gas/split-and-follow-vertically)
  (global-set-key (kbd "C-s")   #'save-buffer)
  (setq-default indent-tabs-mode nil)
  (setq split-width-threshold 150)
  (setq max-specpdl-size 10000)
  (setq max-lisp-eval-depth 10000)
  ;; (set-default 'truncate-lines t)

  ;; Configure common Emoji fonts, making it more likely that Emoji will work out of the box
  (set-fontset-font t 'symbol "Apple Color Emoji")
  (set-fontset-font t 'symbol "Noto Color Emoji" nil 'append)
  (set-fontset-font t 'symbol "Segoe UI Emoji" nil 'append)
  (set-fontset-font t 'symbol "Symbola" nil 'append)

  ;; Nic says eval-expression-print-level needs to be set to nil (turned off) so
  ;; that you can always see what's happening.
  (setq eval-expression-print-level nil)

  ;; No electric indent
  (setq electric-indent-mode nil)

  ;; Configure mac modifiers to be what you expect
  (cond ((eq system-type 'darwin)
         (setq  mac-command-modifier        'super
                mac-option-modifier         'meta
                mac-right-option-modifier   'alt
                mac-pass-control-to-system   nil)))
  )

(use-package form-feed
  :config (global-form-feed-mode))

(use-package uniquify
  :straight nil
  :ensure nil
  :config
  (setq uniquify-after-kill-buffer-p t)
  (setq uniquify-buffer-name-style 'forward)
  (setq-default
   uniquify-separator "/"
   uniquify-ignore-buffers-re "^\\*"))

#+end_src
** Keep Emacs Directory clean
Use no-littering to automatically set common paths to the new user-emacs-directory
#+begin_src emacs-lisp :noweb-ref nolittering
(use-package no-littering
  :demand
  :disabled t
  :config
   (with-eval-after-load 'recentf
     (add-to-list 'recentf-exclude no-littering-var-directory)
     (add-to-list 'recentf-exclude no-littering-etc-directory))
   )

#+end_src
** Evil
Setup vim mode bindings - I'm going back to dark side
#+begin_src emacs-lisp :noweb-ref evil
(use-package evil
  :init (setq evil-want-keybinding nil)
  :config
  (evil-mode t)
  (evil-set-undo-system 'undo-fu)
  (setq evil-move-cursor-back nil
        evil-move-beyond-eol t
        evil-want-fine-undo t
        evil-mode-line-format 'before
        evil-normal-state-cursor '(box "orange")
        evil-insert-state-cursor '(box "green")
        evil-visual-state-cursor '(box "#F86155")
        evil-emacs-state-cursor  '(box "purple"))

  ;; Prevent evil-motion-state from shadowing previous/next sexp
  (require 'evil-maps)
  (define-key evil-motion-state-map "L" nil)
  (define-key evil-motion-state-map "M" nil))

(use-package evil-collection
  :after (evil)
  :diminish evil-collection-unimpaired-mode
  :config
  (evil-collection-init))

(use-package evil-surround
  :config (global-evil-surround-mode 1))

(use-package winum
  :config (winum-mode 1))

;; silence byte compiler
(require 'evil)
(require 'evil-core)
(require 'winum)
(require 'evil-collection)

#+end_src
** File Management
*** Setup dired - directory fn of Emacs
By default dired will show, other than the files, also various other data about every file (like owner, permissions, …) in a format similar to ls -lah. This is indeed useful, but usually I don't need to see all that informations, and they steal precious space, hence dired-hide-details-mode.

In the same spite, most of the time I'm not interested in certain kinds of files (like object files or similar garbage), so hide them too by default with dired-omit-mode.

Finally, wdired is awesome, reserve a key for it!
#+begin_src emacs-lisp :noweb-ref dired
(use-package dired
  :straight nil
  :hook ((dired-mode . dired-hide-details-mode)
         (dired-mode . dired-omit-mode)
	     (dired-mode . hl-line-mode))
  :bind (:map dired-mode-map
              ("C-c w" . wdired-change-to-wdired-mode))
  :config
  (require 'dired-x)
  (setq ;; dired-listing-switches "-lahF"
        dired-dwim-target t
        dired-deletion-confirmer 'y-or-n-p
        dired-omit-files "\\`[.]?#\\|\\`[.][.]?\\'\\|*\\.o\\`\\|*\\.log\\`")
  (setq dired-listing-switches "-lat") ; sort by date (new first)
  (setq dired-kill-when-opening-new-dired-buffer t)
  (put 'dired-find-alternate-file 'disabled nil))

(use-package ranger
  :config
  (setq ranger-width-preview 0.5)
  (setq ranger-width-parents 0.167)
  (setq ranger-preview-delay 0.02)
  (setq ranger-show-hidden t)
  (define-key ranger-mode-map (kbd "i") #'dired-toggle-read-only)
  (define-key ranger-mode-map (kbd "C-h") nil))

  ;; (setup dired
  ;;           (:also-load dired-x)
  ;;           (:pkg dired-collapse
  ;;                 dired-git-info
  ;;                 dired-single
  ;;                 dired-subtree
  ;;                 diredfl
  ;;                 dired+)
  ;;           (:option dired-recursive-copies 'always
  ;;                    dired-recursive-deletes 'always
  ;;                    dired-create-destination-dirs 'always
  ;;                    dired-do-revert-buffer t
  ;;                    dired-hide-details-hide-symlink-targets nil
  ;;                    dired-isearch-filenames 'dwim
  ;;                    delete-by-moving-to-trash t
  ;;                    dired-auto-revert-buffer t
  ;;                    dired-listing-switches "-Al"
  ;;                    ls-lisp-dirs-first t
  ;;                    dired-ls-F-marks-symlinks t
  ;;                    dired-clean-confirm-killing-deleted-buffers nil
  ;;                    dired-no-confirm '(byte-compile
  ;;                                       load chgrp chmod chown
  ;;                                       copy move hardlink symlink
  ;;                                       shell touch)
  ;;                    dired-dwim-target t)
  ;;           (:local-set truncate-lines t)
  ;;           (:bind
  ;;            "<backspace>" #'dired-up-directory
  ;;            "TAB" #'dired-subtree-cycle
  ;;            "i" #'dired-subtree-toggle
  ;;            ")" #'dired-git-info-mode
  ;;            "q" #'quit-window)
  ;;           (:hook #'dired-collapse-mode
  ;;                  #'dired-hide-details-mode
  ;;                  #'hl-line-mode)
  ;;           (:global "C-x C-j" #'dired-jump)
  ;;             (setq dired-recursive-copies 'top)
  ;;             (setq dired-recursive-deletes 'top)
  ;;             (diredfl-global-mode 1)
  ;;           )

#+end_src

*** setup recent files
#+begin_src emacs-lisp :noweb-ref recent
(use-p (:require recentf)
       (setq recentf-auto-cleanup 'mode)
       (setq recentf-exclude `(,#'path-in-cache/?
                   "^/tmp/"
                   "COMMIT_EDITMSG$"
                   ".gz$"))
       (setq recentf-filename-handlers '(abbreviate-file-name))
       (setq recentf-max-menu-items 100)
       (setq recentf-max-saved-items nil)
       (recentf-mode 1)
       (run-at-time nil 120 (fn (quiet! (recentf-save-list))))
       (:with-hook kill-emacs-hook
           (:hook recentf-cleanup recentf-save-list)))

                 #+end_src
** setup backups
#+begin_src emacs-lisp
(setup (:require savehist)
          (setq history-delete-duplicates t)
          (setq history-length t)
          (setq savehist-additional-variables
                '(extended-command-history
                  global-mark-ring
                  kill-ring
                  mark-ring
                  regexp-search-ring
                  search-ring))
          (setq savehist-autosave-interval 60)
          (setq savehist-file (save-in-etc-file! "history"))
          (setq savehist-save-minibuffer-history t)
          (savehist-mode 1))

        (setup (:require saveplace)
          (setq save-place-file (save-in-etc-file! "places"))
          (setq save-place-forget-unreadable-files nil)
          (save-place-mode 1))

#+end_src

** emacs server setup
#+begin_src emacs-lisp :noweb-ref server
;; Start the emacs-server, so you can open files from the command line with
;; `emacsclient -n <file>' (we like to put `alias en="emacsclient -n"' in our
;; shell config).
(use-package edit-server
  :if window-system
  :init
  (add-hook 'after-init-hook 'server-start t)
  (add-hook 'after-init-hook 'edit-server-start t))

  #+end_src
** Electric
Emacs labels as “electric” any behaviour that involves contextual auto-insertion of characters. while the idea is neat, I generally dislike it because of its false positives. This is a summary of my settings:

- If electric-pair-mode is enabled (which I might do manually), insert quotes and brackets in pairs. Only do so if there is no alphabetic character after the cursor.
- The cryptic numbers in the pairs set, correspond to curly single and double quotes and these «». The contents of this set are always inserted in pairs, regardless of major mode. To get those numbers, evaluate (string-to-char CHAR) where CHAR is the one you are interested in. For example, get the literal tab’s character with (string-to-char "\t").
- While inputting a pair, inserting the closing character will just skip over the existing one, rather than add a new one. So typing ( will insert () and then typing ) will just be the same as moving forward one character C-f.
- Do not skip over whitespace when operating on pairs. Combined with the above point, this means that a new character will be inserted, rather than be skipped over. I find this better, because it prevents the point from jumping forward, plus it allows for more natural editing.
- The whitespace characters are space (\s), tab (\t), and newline (\n).
- The rest concern the conditions for transforming quotes into their curly equivalents. I keep this disabled, because curly quotes are distinct characters. It is difficult to search for them. Just note that on GNU/Linux you can type them directly by hitting the “compose” key and then an angled bracket (< or >) followed by a quote mark.
#+begin_src emacs-lisp :noweb-ref electric
;;; Configure 'electric' behaviour
(use-package electric
  :hook (prog-mode . #'electric-indent-local-mode)
  :config
  (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars '(9 10 32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  (electric-pair-mode -1)
  (electric-quote-mode -1)
  ;; I don't like auto indents in Org and related.  They are okay for
  ;; programming.
  (electric-indent-mode -1)
  ;; electric everything (but there must be a way to disable it)
  (when (fboundp 'electric-pair-mode)
    (add-hook 'after-init-hook 'electric-pair-mode))

  (defun editor-disable-electric-indent ()
    "Disable the command `electric-indent-mode' locally."
    (electric-indent-local-mode -1))

  (defun editor-disable-electric-pair ()
    "Disable the command `electric-pair-mode' locally."
    (electric-pair-local-mode -1))
  :init
  (add-hook 'after-init-hook 'electric-indent-mode)
  )

#+end_src
** Emacs *Help* functions
Help and which functions

#+begin_src emacs-lisp :noweb-ref emacs-help
  (use-package helpful
    :after (evil avy)
    :init
    (setq evil-lookup-func #'helpful-at-point)
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-key] . helpful-key)
    :config
    (defun avy-action-helpful (pt)
      (save-excursion
        (goto-char pt)
        (helpful-at-point))
      (select-window
       (cdr (ring-ref avy-ring 0)))
      t)
    ;; set H as avy dispatch to Help
    (setf (alist-get ?H avy-dispatch-alist) 'avy-action-helpful))

  (use-package  which-key
    :hook (after-init . which-key-mode)
    :config
    (which-key-mode 1)
    (setq which-key-add-column-padding 2)
    (setq which-key-idle-delay 0.5)
    (setq which-key-idle-secondary-delay 0.1)
    (setq which-key-max-display-columns nil)
    (setq which-key-min-display-lines 6)
    (setq which-key-replacement-alist
          '((("left") . ("🡸"))
            (("right") . ("🡺"))
            (("up") . ("🡹"))
            (("down") . ("🡻"))
            (("delete") . ("DEL"))
            (("\\`DEL\\'") . ("BKSP"))
            (("RET") . ("⏎"))
            (("next") . ("PgDn"))
            (("prior") . ("PgUp"))))
    (setq which-key-sort-order 'which-key-key-order-alpha)
    (setq which-key-sort-uppercase-first nil)
    (which-key-setup-minibuffer)
    ;;  (:with-hook which-key-init-buffer-hook
    ;;  (:hook (lambda (setq line-spacing 4))))
    )

#+end_src

#+begin_src emacs-lisp :tangle no
  (setup (:pkg helpful)
    (:when-loaded
      (:global-bind
       "C-h f" helpful-callable
       "C-h v" helpful-variable
       "C-h k" helpful-key)
      (defun avy-action-helpful (pt)
        (save-excursion
          (goto-char pt)
          (helpful-at-point))
        (select-window
         (cdr (ring-ref avy-ring 0)))
        t)
      ;; set H as avy dispatch to Help
      (setf (alist-get ?H avy-dispatch-alist) 'avy-action-helpful)

      (:load-after link-hint
        (:bind
         "o" link-hint-open-link-at-point)
        (setq helpful-switch-buffer-function
              (lambda (x)
                (if (eq major-mode 'helpful-mode)
                    (switch-to-buffer x)
                  (pop-to-buffer x)))))))

#+end_src

** Typographical stuff
I also do typos pretty often, and abbrev is handy for those occasions and accents (like "perchè" instead of "perché").

my-abbrev is a package-like file where I store the abbreviations I need.
#+begin_src emacs-lisp :noweb-ref abbrev
(use-package my-abbrev
  :straight nil)

  (use-package hippie-exp
    :straight nil
    :config (setq hippie-expand-try-functions-list
          '(try-expand-dabbrev
            try-expand-dabbrev-all-buffers
            try-expand-dabbrev-from-kill
            try-complete-file-name-partially
            try-complete-file-name
            try-expand-all-abbrevs
            try-expand-list
            try-expand-line
            try-complete-lisp-symbol-partially
            try-complete-lisp-symbol))
    :bind ("M-/" . #'hippie-expand))

#+end_src
** Indentation

use electric-indent but have a way of turning it off
#+begin_src emacs-lisp :tangle no
;; easier to search
(setq-default
search-default-mode #'char-fold-to-regexp
replace-char-fold t)




#+end_src

** Whitespaces
:PROPERTIES:
:ID:                     172e5cef-83e4-499b-a753-34beef9ad275
:END:
#+begin_src emacs-lisp :noweb-ref whitespace-old
;; Whitespaces
(use-package emacs
  :straight nil
  :hook ((prog-mode text-mode conf-mode) .  'editor-show-trailing-whitespace)
  :config
  (setq-default
   indent-tabs-mode nil
   tab-width 2
   require-final-newline t
   tab-always-indent t)

  (defun editor-show-trailing-whitespace ()
    "Enable display of trailing whitespace in this buffer."
    (setq-local show-trailing-whitespace t)))

#+end_src

use ws-butler
#+begin_src emacs-lisp :noweb-ref whitespace
  (use-package ws-butler
    :straight (:type git
                    :host github
                    :repo "hlissner/ws-butler")
    :diminish t
    :config
    ;; Formatting
    (setq-default
     ;; `ws-butler' is used for better whitespace handling
     delete-trailing-lines nil
     sentence-end-double-space nil
     word-wrap t)
    ;; :commands (ws-butler-global-mode)
    (ws-butler-global-mode)
    (setq ws-butler-global-exempt-modes
          (append ws-butler-global-exempt-modes
                  '(special-mode comint-mode term-mode eshell-mode))))

  

  #+end_src

  ACDW setup whitespace defaults
  #+begin_src emacs-lisp :tangle no
    (setup whitespace
      (setq backward-delete-char-untabify-method 'hungry)
      (setq next-line-add-newlines nil)
      (setq sentence-end-double-space nil)
      (setq-default indent-tabs-mode nil)
      (setq-default indicate-empty-lines nil)
      (setq-default tab-always-indent nil)
      (setq-default tab-width 4)
      (:with-hook before-save-hook
        (:hook delete-trailing-whitespace)))

#+end_src
** Long lines
The visual-line-mode function enables line-wrapping. You can run the function separately for each buffer, but ideally, you hook it to all text modes.

When you select (mark) a section of text and start typing, Emacs will not replace the selected text. To enable Emacs deleting selected text, you set the delete-selection-mode variable, as below.

One last sensible default is to enure that Emacs lets you use the page-up and page-down buttons to
go to the first and last line in the buffer.
#+begin_src emacs-lisp :noweb-ref longlines
  ;; Long lines

  (setup (:pkg visual-fill-column)
    (:option visual-fill-column-center-text t)
;;             (append reading-modes) '(visual-fill-column-mode . +1))
    (:hook #'visual-line-mode)
    (:hook-into org-mode)
    (advice-add #'text-scale-adjust :after #'visual-fill-column-adjust))

  (setup (:pkg adaptive-wrap)
    (:with-mode adaptive-wrap-prefix-mode
      (:hook-into visual-column-mode)))


  (setup (:pkg unfill)
    ;;:commands (unfill-toggle)
    (:global "M-q"  #'unfill-toggle))

  ;; Overwrite selected text
  ;; (setup (:require delsel)
  ;;  (delete-selection-mode t))

  ;; Scroll to the first and last line of the buffer
  ;;(setq scroll-error-top-bottom t)

#+end_src
** Move Text
:PROPERTIES:
:ID:                     e876dc83-2902-46e7-8c1c-69e371a03b56
:END:
#+begin_src emacs-lisp :tangle no
  (setup (:pkg move-text)
   ;; :commands (move-text-up
   ;;            move-text-down)
    (:global [M-S-down]  #'move-text-down
             [M-S-up]    #'move-text-up))

#+end_src
** Move where I Mean
:PROPERTIES:
:ID:                     0afacc7c-7b32-4047-842c-ade5637483c4
:END:
#+begin_src emacs-lisp :noweb-ref mwim
(use-package mwim
  :defer t
  :bind ( "C-a"  .  mwim-beginning))

#+end_src

** Jump to visible position - Avy
:PROPERTIES:
:ID:                     e2c2803d-7159-4431-9bff-1ada59aaece5
:END:
The avy package by Oleh Krehel lets you select a location on the screen to move the cursor to. It does so by producing an overlay with characters that need to be typed to specify the location. By default, the overlay covers the candidate, though I change the avy-style to have it appear as a prefix instead.

There are several commands on offer which narrow down the candidates. My favourite is avy-goto-char-timer (closely followed by avy-goto-char-2 and avy-goto-word-1). It prompts for a character and then has a time window lasting avy-timeout-seconds during which it can read more characters. Once Avy receives the input, it overlays every word that contains those characters in succession. If there is a single match, it jumps directly to it.

Avy has the ability to act on the candidate rather than simply jump to it. Karthik Chikmagalur has a comprehensive essay on the matter, which I consider essential reading for anyone wanting to make best use of this package: Avy can do anything (2021-10-21). I still am not sure whether I need all that power though, as in my workflow I jump to a point and then invoke embark-act (see Extended minibuffer actions (embark.el)).
n

Finally, we can use Avy to select a candidate from the *Completions* buffer (see Minibuffer configurations and my extras (mct.el)).Setup avy in filter, select, act mode
#+begin_src emacs-lisp :noweb-ref avy
(use-package avy
    :commands (avy-goto-char avy-goto-word-0 avy-goto-line avy-goto-char-time)
    :bind (("C-."    . #'avy-goto-char-time)
           ("C-M-s"  . #'isearch-forward-other-window)
           ("C-M-r" . #'isearch-backward-other-window )
           )
    :config
    (setq avy-keys '(?q ?e ?r ?y ?u ?o ?p
                        ?a ?s ?d ?f ?g ?h ?j
                        ?k ?l ?' ?x ?c ?v ?b
                        ?n ?, ?/))
    (setq avy-all-windows nil) ; only the current window
    (setq avy-all-windows-alt t) ; all windows with C-u
    (setq avy-single-candidate-jump t)
    (setq avy-background nil)
    (setq avy-case-fold-search nil) ; case is significant
    (setq avy-timeout-seconds 0.5)
    (setq avy-style 'pre) ; prefixes candidate; otherwise use `at-full'

    (defun avy-show-dispatch-help ()
      (let* ((len (length "avy-action-"))
             (fw (frame-width))
             (raw-strings (mapcar
                           (lambda (x)
                             (format "%2s: %-19s"
                                     (propertize
                                      (char-to-string (car x))
                                      'face 'aw-key-face)
                                     (substring (symbol-name (cdr x)) len)))
                           avy-dispatch-alist))
             (max-len (1+ (apply #'max (mapcar #'length raw-strings))))
             (strings-len (length raw-strings))
             (per-row (floor fw max-len))
             display-strings)
        (cl-loop for string in raw-strings
                 for N from 1 to strings-len do
                 (push (concat string " ") display-strings)
                 (when (= (mod N per-row) 0) (push "\n" display-strings)))
        (message "%s" (apply #'concat (nreverse display-strings)))))

    ;; Kill text
    (defun avy-action-kill-whole-line (pt)
      (save-excursion
        (goto-char pt)
        (kill-whole-line))
      (select-window
       (cdr
        (ring-ref avy-ring 0)))
      t)

    (setf (alist-get ?k avy-dispatch-alist) 'avy-action-kill-stay
          (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line)

    ;; Copy text
    (defun avy-action-copy-whole-line (pt)
      (save-excursion
        (goto-char pt)
        (cl-destructuring-bind (start . end)
            (bounds-of-thing-at-point 'line)
          (copy-region-as-kill start end)))
      (select-window
       (cdr
        (ring-ref avy-ring 0)))
      t)

    (setf (alist-get ?w avy-dispatch-alist) 'avy-action-copy
          (alist-get ?W avy-dispatch-alist) 'avy-action-copy-whole-line)

    ;; Yank text
    (defun avy-action-yank-whole-line (pt)
      (avy-action-copy-whole-line pt)
      (save-excursion (yank))
      t)

    (setf (alist-get ?y avy-dispatch-alist) 'avy-action-yank
          (alist-get ?Y avy-dispatch-alist) 'avy-action-yank-whole-line)

    ;; Transpose/Move text
    (defun avy-action-teleport-whole-line (pt)
      (avy-action-kill-whole-line pt)
      (save-excursion (yank)) t)

    (setf (alist-get ?t avy-dispatch-alist) 'avy-action-teleport
          (alist-get ?T avy-dispatch-alist) 'avy-action-teleport-whole-line)

    ;; Mark text
    (defun avy-action-mark-to-char (pt)
      (activate-mark)
      (goto-char pt))

    (setf (alist-get ?  avy-dispatch-alist) 'avy-action-mark-to-char)

    ;; Avy + Isearch
    (define-key isearch-mode-map (kbd "M-j") 'avy-isearch)

    ;; Isearch in other windows
    (defun isearch-forward-other-window (prefix)
      "Function to isearch-forward in other-window."
      (interactive "P")
      (unless (one-window-p)
        (save-excursion
          (let ((next (if prefix -1 1)))
            (other-window next)
            (isearch-forward)
            (other-window (- next))))))

    (defun isearch-backward-other-window (prefix)
      "Function to isearch-backward in other-window."
      (interactive "P")
      (unless (one-window-p)
        (save-excursion
          (let ((next (if prefix 1 -1)))
            (other-window next)
            (isearch-backward)
            (other-window (- next))))))

    (setq avy-all-windows t))

  ;; (setup (:pkg avy)
  ;;     (:disable)
  ;;      (:global  "M-j"  'avy-goto-char-timer
  ;;                "C-M-s" 'isearch-forward-other-window
  ;;                "C-M-r" 'isearch-backward-other-window)

  ;;   ;; (:option avy-dispatch-alist (append (?k avy-action-kill-stay)))
  ;;  ;;    (add-to-list 'avy-dispatch-alist '(?k . avy-action-kill-stay))
  ;;)

  ;; (setup (:pkg avy-zap)
  ;;   ;; : my-laptop-p
  ;;   (setq avy-zap-forward-only t)
  ;;   ;; (setq avy-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s))
  ;;   :global
  ;;   (("M-z" . avy-zap-up-to-char-dwim)
  ;;    ("M-Z" . avy-zap-to-char-dwim)))

#+end_src
** Search
The built-in search mechanisms, defined in the libraries isearch.el and replace.el are minimal in their presentation, yet powerful in their applications. There are the main points of entry to the commands they offer:

- isearch-forward (C-s) prompts for a string after point and offers live feedback on its progress. isearch-backward (C-r) moves in the opposite direction.
     - Two distinct keys may seem redundant at first, but you really appreciate this level of precision when recording keyboard macros (see, for example, my video about Isearch powers in keyboard macros (2020-01-21)).
     - Use C-M-s and C-M-r for running a search against a regular expression, or call isearch-toggle-regexp (M-r) after starting a regular isearch.
- query-replace (M-%) replaces all matches of a string and asks you for confirmation on each of them. If you check its help page (press ? after invoking the command), you will learn that ! stands for an affirmative answer to all, which is a standard in all such prompts.
     - query-replace-regexp (C-M-%) does the same for regular expressions.
- occur (M-s o) places all matches of a regular expression or string in a dedicated buffer. That can function as an index for moving to the relevant points in the buffer, but also as a means of refactoring all matches at once. Just make the *Occur* buffer editable with e. Running occur with a numeric argument provides N lines of context around the given match.

The beauty of the Occur and Replace commands is that they can be initiated from within an active Isearch session, using the same keys. So C-s INPUT M-s o will search for input and then run occur on it. Try C-h k C-s to get a help menu with all the extra keys you can use with isearch.
#+begin_src emacs-lisp :noweb-ref search
;;; Isearch, occur, grep, and extras (prot-search.el)
(setup (:require isearch)
  (setq search-highlight t)
  (setq search-whitespace-regexp ".*?")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)
  (setq isearch-lazy-highlight t)
  ;; All of the following variables were introduced in Emacs 27.1.
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format nil)
  (setq lazy-count-suffix-format " (%s/%s)")
  (setq isearch-yank-on-move 'shift)
  (setq isearch-allow-scroll 'unlimited)
  ;; These variables are from Emacs 28
  (setq isearch-repeat-on-direction-change t)
  (setq lazy-highlight-initial-delay 0.5)
  (setq lazy-highlight-no-delay-length 3)
  (setq isearch-wrap-pause t)

  (define-key minibuffer-local-isearch-map (kbd "M-/") #'isearch-complete-edit)
  (let ((map isearch-mode-map))
    (define-key map (kbd "C-g") #'isearch-cancel) ; instead of `isearch-abort'
    (define-key map (kbd "M-/") #'isearch-complete)))
(setup (:require replace)
  (setq list-matching-lines-jump-to-current-line t)
  (add-hook 'occur-mode-hook #'hl-line-mode)
  (add-hook 'occur-mode-hook #'prot-common-truncate-lines-silently) ; from `prot-common.el'
  (define-key occur-mode-map (kbd "t") #'toggle-truncate-lines))

(setup (:require grep))

(setup (:require prot-search)
  (setq prot-search-outline-regexp-alist
        '((emacs-lisp-mode . "^\\((\\|;;;+ \\)")
          (org-mode . "^\\(\\*+ +\\|#\\+[Tt][Ii][Tt][Ll][Ee]:\\)")))
  (setq prot-search-todo-keywords
        (concat "TODO\\|FIXME\\|NOTE\\|REVIEW\\|XXX\\|KLUDGE"
                "\\|HACK\\|WARN\\|WARNING\\|DEPRECATED\\|BUG"))

  (let ((map global-map))
    (define-key map (kbd "M-s %") #'prot-search-isearch-replace-symbol)
    (define-key map (kbd "M-s M-<") #'prot-search-isearch-beginning-of-buffer)
    (define-key map (kbd "M-s M->") #'prot-search-isearch-end-of-buffer)
    (define-key map (kbd "M-s g") #'prot-search-grep)
    (define-key map (kbd "M-s u") #'prot-search-occur-urls)
    (define-key map (kbd "M-s t") #'prot-search-occur-todo-keywords)
    (define-key map (kbd "M-s M-t") #'prot-search-grep-todo-keywords) ; With C-u it runs `prot-search-git-grep-todo-keywords'
    (define-key map (kbd "M-s M-o") #'prot-search-occur-outline)
    (define-key map (kbd "M-s M-u") #'prot-search-occur-browse-url))
  (let ((map isearch-mode-map))
    (define-key map (kbd "<up>") #'prot-search-isearch-repeat-backward)
    (define-key map (kbd "<down>") #'prot-search-isearch-repeat-forward)
    (define-key map (kbd "<backspace>") #'prot-search-isearch-abort-dwim)
    (define-key map (kbd "<C-return>") #'prot-search-isearch-other-end)))
#+end_src
** Occur
Occur is a grep-like functionality for Emacs. It populates the *occur* buffer with the lines matching a certain regexp in the current buffer. It's super-useful.

#+begin_src emacs-lisp :noweb-ref occur
(use-package replace
  :straight nil
  :bind (("C-c o" . occur)))
#+end_src
loccur is similar, but instead of using a separate buffer, it visually hides all the non-matching lines, also super useful!

#+begin_src emacs-lisp :noweb-ref occur
(use-package loccur
  :bind (("C-c O" . loccur)))
#+end_src
With wgrep we can directly edit the results of a grep and save the changes to all affected buffers. In principle, this is the same as what the built-in occur offers. We can use it to operate on a list of matches by leveraging the full power of Emacs’ editing capabilities (e.g. keyboard macros, query and replace a regexp…).
#+begin_src emacs-lisp :noweb-ref wgrep
;;; wgrep (writable grep)
(setup (:require wgrep)
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  (let ((map grep-mode-map))
    (define-key map (kbd "e") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-x C-q") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-c C-c") #'wgrep-finish-edit)))

#+end_src

** Cross-references
Xref provides helpful commands for code navigation and discovery, such as xref-find-definitions (M-.) and its counterpart xref-pop-marker-stack (M-,=). It is a library that gets used by a variety of tools, including =project.el (see Projects (project.el and prot-project.el)).
#+begin_src emacs-lisp :noweb-ref xref
;;; Cross-references (xref.el)
(setup (:require xref)
  ;; All those have been changed for Emacs 28
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read) ; for M-.
  (setq xref-show-xrefs-function #'xref-show-definitions-buffer) ; for grep and the like
  (setq xref-file-name-display 'project-relative)
  (setq xref-search-program 'grep))
#+end_src
** Spelling
:PROPERTIES:
:ID:                     646035cd-ccc8-4a21-b116-f5d2269dbad9
:END:
The configuration below enables Flyspell for all text modes and sets Hunspell as the default checking program. The M-F7 key checks the spelling for all words in the buffer and F7 checks the word that you cursor is standing on.

A more productive method is to use the C-; function. This function provides the most likely correction of the first spelling error before the cursor is. Emacs will show the list of possible corrections in the mini buffer. Repeatedly pressing C-; will cycle through the options until you get back to the original. This function prevents you from having to jump to your spelling mistakes.
#+begin_src emacs-lisp :noweb-ref spell
(setup flyspell
       (:needs (or "hunspell"
                   "aspell"))
       (:load-after avy
                    (:hook-into org-mode-hook git-commit-mode-hook markdown-mode-hook)
                    (:bind "M-<f7>"  flyspell-buffer
                           "<f7>"    flyspell-word
                           "C-;"     flyspell-auto-correct-previous-word
                           )
                    (progn
                      (cond
                       ((executable-find "aspell")
                        (setq ispell-program-name "aspell")
                        (setq ispell-extra-args   '("--sug-mode=ultra"
                                                    "--lang=en_AU")))
                       ((executable-find "hunspell")
                        (setq ispell-program-name "hunspell")
                        (setq ispell-extra-args   '("-d en_AU"))))

                      ;; Save a new word to personal dictionary without asking
                      (setq ispell-silently-savep t)
                      (setq ispell-default-dictionary "en_AU"))

                    (defun avy-action-flyspell (pt)
                      (save-excursion
                        (goto-char pt)
                        (when (require 'flyspell nil t)
                          (flyspell-auto-correct-word)))
                      (select-window
                       (cdr (ring-ref avy-ring 0)))
                      t)

                    ;; Bind to semicolon (flyspell uses C-;)
                    (setf (alist-get ?\; avy-dispatch-alist) 'avy-action-flyspell)

                    (:when-loaded
                     (:hide-mode))))
#+end_src

I use the dictionary package for Emacs, and I’m lazy about it:
#+begin_src emacs-lisp
  (setup (:pkg dictionary)
    (:load-after avy
      (defun dictionary-search-dwim (&optional arg)
        "Search for definition of word at point. If region is active,
    search for contents of region instead. If called with a prefix
    argument, query for word to search."
        (interactive "P")
        (if arg
            (dictionary-search nil)
          (if (use-region-p)
              (dictionary-search (buffer-substring-no-properties
                                  (region-beginning)
                                  (region-end)))
            (if (thing-at-point 'word)
                (dictionary-lookup-definition)
              (dictionary-search-dwim '(4))))))

      ;; dictionary
      (defun avy-action-define (pt)
        (save-excursion
          (goto-char pt)
          (dictionary-search-dwim))
        (select-window
         (cdr (ring-ref avy-ring 0)))
        t)

      (setf (alist-get ?= avy-dispatch-alist) 'dictionary-search-dwim))
    (:option dictionary-use-single-buffer t)
    (autoload 'dictionary-search "dictionary"
      "Ask for a word and search it in all dictionaries" t)
    (:hook #'reading-mode))

#+end_src
** Conveniences
*** Automatic time stamps for files (time-stamp.el)

The built-in time-stamp.el provides the means to automatically update a predefined header with the time its file was last edited/saved. This is, in my experience, particularly useful for packages that have a stable version but also need to disambiguate their latest tagged release from their current development state.

By default, this is done by checking the first eight lines of the file for the Time-stamp: <> entry. Though that is configurable. To properly utilise this library, you need to implement file-local variables. Those should control the exact format of the time stamp. For examples, this is what I have in my modus-themes.el:

;; Local Variables:
;; time-stamp-start: "Last-Modified:[ \t]+\\\\?[\"<]"
;; time-stamp-end: "\\\\?[\">]"
;; time-stamp-format: "%Y-%02m-%02d %02H:%02M:%02S %5z"
;; End:

Check M-x find-library RET time-stamp RET for all variables you may want to control.

All we do here is enable the package and add a hook to insert a time stamp upon save, where relevant. It works seamlessly.

#+begin_src emacs-lisp :noweb-ref timestamp
;;; Automatic time stamps for files (time-stamp.el)
(use-package time-stamp
  :config
  (add-hook 'before-save-hook #'time-stamp))

#+end_src
*** Auto revert mode
This mode ensures that the buffer is updated whenever the file changes. A change can happen externally or by some other tool inside of Emacs (e.g. kill a Magit diff).
#+begin_src emacs-lisp :tangle no
(setup (:require autorevert)
          (setq auto-revert-check-vc-info t)
          (setq auto-revert-remote-files t)
          (setq global-auto-revert-non-file-buffers t)
          (setq auto-revert-verbose nil)
          (add-hook 'after-init-hook #'global-auto-revert-mode)
          (:hide-mode auto-revert))

#+end_src
*** Preserve contents of system clipboard

Say you copied a link from your web browser, then switched to Emacs to paste it somewhere. Before you do that, you notice something you want to kill. Doing that will place the last kill to the clipboard, thus overriding the thing you copied earlier. We can have a kill ring solution to this with the following:
#+begin_src emacs-lisp :tangle no
;;; Preserve contents of system clipboard
(setq save-interprogram-paste-before-kill t)

#+end_src
Now the contents of the clipboard are stored in the kill ring and can be retrieved from there (e.g. with M-y).
*** Newline characters for file ending

For some major modes, such as diff-mode, a final newline is of paramount importance. Without it you cannot, for instance, apply a patch cleanly. As such, the mode-require-final-newline will add a newline character when visiting or saving a buffer of relevance.

#+begin_src emacs-lisp :tangle no
;;; Newline characters for file ending
(setq mode-require-final-newline 'visit-save)

#+end_src

*** Zap characters
There are two kinds of “zap” functionality:

- `zap-up-to-char` will delete everything from point up to the character you provide it with. Think of how you may want to remove a file name but keep its file type extension, so M-x zap-up-to-char RET . will do just that.
- zap-to-char, which is bound to M-z by default, will delete the target character as well.

I bind the former to M-z as I use it more often and leave its counterpart on M-Z (M-S-z).
#+begin_src emacs-lisp :tangle no
;;; Zap characters
(let ((map global-map))
  (define-key map (kbd "M-z") #'zap-up-to-char)
  (define-key map (kbd "M-Z") #'zap-to-char)) ; M-S-z

#+end_src
** Undo & expand region

Setup undo , whitespace, expand, indentation

Undo is a key function of an editor - bind to Ctrl-Z
#+begin_src emacs-lisp :noweb-ref undo
  ;; Setup undo-tree mode
  ;; (use-package undo-tree
  ;;   :diminish t
  ;;   :bind (( "C-z"  .  undo-tree-undo)
  ;;          ("C-S-z" . undo-tree-redo))
  ;;   :config
  ;;   (setq undo-tree-auto-save-history nil)
  ;;   (global-undo-tree-mode 1))

  (use-package undo-fu
    :config
    (global-unset-key (kbd "C-z"))
    (global-set-key (kbd "C-z")   'undo-fu-only-undo)
    (global-set-key (kbd "C-S-z") 'undo-fu-only-redo)
    (setq undo-limit 6710886400) ;; 64mb.
    (setq undo-strong-limit 100663296) ;; 96mb.
    (setq undo-outer-limit 1006632960)) ;; 960mb.


  (use-package undo-fu-session
    :config
    (setq undo-fu-session-incompatible-files
          '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'"))
    (global-undo-fu-session-mode 1))

#+end_src

#+begin_src emacs-lisp :noweb-ref undo
;; (use-package aggressive-indent
;;   :diminish aggressive-indent-mode
;;   :hook ((clojurex-mode
;;           clojurescript-mode
;;           clojurec-mode
;;           clojure-mode
;;           emacs-lisp-mode
;;           lisp-data-mode)
;;          . aggressive-indent-mode))

(use-package hungry-delete
  :after smartparens
  :diminish
  :config
  (setq hungry-delete-join-reluctantly t)
  (global-hungry-delete-mode 1)
  ;;  (:hook-into smartparens-enabled)
 )

;; (use-package dumb-jump)

;; (use-package goto-last-change)

;; (use-package expand-region)

;; (use-package string-edit)
#+end_src

** Corgi Editor buffers
#+begin_src emacs-lisp :noweb-ref corgi-ed-buffers
  (when (and (not (display-graphic-p))
             (executable-find "xclip"))
    (use-package xclip
      :config
      (when (executable-find xclip-program)
        (with-no-warnings
          (xclip-mode t)))))

  ;; Offer to create parent directories if they do not exist
  ;; http://iqbalansari.github.io/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/
  (defun magnars/create-non-existent-directory ()
    (let ((parent-directory (file-name-directory buffer-file-name)))
      (when (and (not (file-exists-p parent-directory))
                 (y-or-n-p (format "Le répertoire `%s' n'existe pas! Créez-le?" parent-directory)))
        (make-directory parent-directory t))))

  (add-to-list 'find-file-not-found-functions #'magnars/create-non-existent-directory)

  ;; (defvar corgi-editor--last-buffer
  ;;   nil
  ;;   "The last current buffer.")

  ;; ;; (
 ;; defun corgi-editor/-on-buffer-change (&optional _win)
  ;;   (unless (or (and (minibufferp) (not evil-want-minibuffer))
  ;;               (eq (current-buffer) corgi-editor--last-buffer))
  ;;     (setq corgi-editor--last-buffer (current-buffer))
  ;;     (evil-emacs-state)))

  ;; (if (boundp 'window-buffer-change-functions)
  ;;     ;; Emacs 27.1+ only
  ;;     (add-hook 'window-buffer-change-functions #'corgi-editor/-on-buffer-change)
  ;;   (add-hook 'post-command-hook #'corgi-editor/-on-buffer-change))

#+end_src
** Buffers in Emacs
:PROPERTIES:
:header-args: :noweb-ref buffers
:ID:                     e82ac276-b2db-434f-83aa-da6df0f3b90e
:END:
Setup the buffers to my liking
#+begin_src emacs-lisp
(use-package emacs
    :straight nil
    :ensure nil
    :config

    (defvar buffer-fallback-name "*scratch*"
      "The name of the buffer to fall back to.
          Used when no other buffers exist.")

    (defun buffer-fallback ()
      "Return the fallback buffer, creating it if necessary.
          By default this is the scratch buffer. See
          `buffer-fallback-name' to change this."
      (get-buffer-create buffer-fallback-name))

    

    (defun buffer-display-and-switch (buffer-or-name)
      "Display BUFFER-OR-NAME in some window and switch to it."
      (select-window (display-buffer buffer-or-name)))

    

    (defvar buffer-messages-display-fn #'buffer-display-and-switch
      "The function to use to display messages buffer.
          Must accept one argument: the buffer to display.")

    (defvar buffer-messages-name "*Messages*"
      "The name of the messages buffer.")

    (defun buffer-pop-messages ()
      "Open `buffer-messages-name' buffer."
      (interactive)
      (funcall buffer-messages-display-fn
           (get-buffer-create buffer-messages-name)))

    (defun buffer-switch-to-messages ()
      "Open `buffer-messages-name' buffer."
      (interactive)
      (let ((buffer-messages-display-fn #'switch-to-buffer))
    (buffer-pop-messages)))

    

    (defvar buffer-scratch-files-dir (concat EMACS_ETC/ "scratch/")
      "Where to store project scratch files.
          Files are created by `buffer-open-project-scratch'.")

    (defvar buffer-scratch-display-fn #'buffer-display-and-switch
      "The function to use to display the scratch buffer.
          Must accept one argument: the buffer to display.")

    (defvar buffer-scratch-major-mode nil
      "What major mode to use in scratch buffers.
          This can be one of the following:
        t          Inherits the major mode of the last buffer you had
               selected.
        nil        Uses `fundamental-mode'
        MAJOR-MODE  Any major mode symbol")

    (defvar buffer-scratch-hook ()
      "The hooks to run after a scratch buffer is made.")

    (defun buffer-scratch (&optional file mode text)
      "Return a scratch buffer in major MODE with TEXT in it.
          If FILE is a valid path, open it as if it were a persistent
          scratch."
      (if file (setq file (file-truename file)))
      (let ((buffer
         (if file
         (with-current-buffer (find-file-noselect file)
           (rename-buffer (format "*scratch (%s)*"
                      (file-name-nondirectory file)))
           (current-buffer))
           (get-buffer-create "*scratch*"))))
    (with-current-buffer buffer
      (when (and (functionp mode)
             (not (eq major-mode mode)))
        (funcall mode))
      (when text
        (insert text))
      (run-hooks 'buffer-scratch-hook)
      (current-buffer))))

    (defun buffer-pop-scratch (&optional arg)
      "Opens a scratch pad window in the same `major-mode'.
          If ARG (universal argument), then open a persistent scratch
          buffer. You'll be prompted for its name, or to open a previously
          created. These are stored in `buffer-scratch-files-dir'.
          If a region is active, copy its contents to the scratch."
      (interactive "P")
      (funcall
       buffer-scratch-display-fn
       (buffer-scratch
    (when arg
      (if-let* ((file (read-file-name
               "Ouvrir le fichier de scratch > "
               buffer-scratch-files-dir
               "scratch")))
          file
        (user-error "Abandon..")))
    (cond ((eq buffer-scratch-major-mode t)
           (unless (or buffer-read-only
               (derived-mode-p 'special-mode)
               (string-match-p "^ ?\\*" (buffer-name)))
         major-mode))
          ((null buffer-scratch-major-mode) nil)
          ((symbolp buffer-scratch-major-mode)
           buffer-scratch-major-mode))
    (and (region-active-p)
         (buffer-substring-no-properties
          (region-beginning) (region-end))))))

    (defun buffer-switch-to-scratch (&optional arg)
      "Switch to a scratch buffer in the current window.
          Otherwise, does exactly what `buffer-pop-scratch' does.
          ARG is passed to `buffer-pop-scratch'."
      (interactive "P")
      (let ((buffer-scratch-display-fn #'switch-to-buffer))
    (buffer-pop-scratch arg)))

    (defun buffer-delete-scratch-files ()
      "Deletes all scratch buffers in `buffer-scratch-files-dir'."
      (interactive)
      (dolist (file (directory-files buffer-scratch-files-dir
                     t "[^.]" t))
    (delete-file file)
    (message "Supprimé '%s'" (file-name-nondirectory file))))

    

    (defun buffer-sudo-edit (&optional arg)
      "Edit currently visited file as root.
          With a prefix ARG prompt for a file to visit. Will also prompt
          for a file to visit if current buffer is not visiting a file."
      (interactive "P")
      (if (or arg (not buffer-file-name))
      (find-file (concat "/sudo:root@localhost:"
                 (read-file-name "Rechercher le fichier (en tant que root): ")))
    (find-alternate-file
     (concat "/sudo:root@localhost:"
         buffer-file-name))))

    

    (defhydra hydra-buffer-menu (:color pink
                    :hint nil)
      "
        ^Mark^             ^Unmark^           ^Actions^          ^Search
        ^^^^^^^^-----------------------------------------------------------------
        _m_: mark          _u_: unmark        _x_: execute       _R_: re-isearch
        _s_: save          _U_: unmark up     _b_: bury          _I_: isearch
        _d_: delete        ^ ^                _g_: refresh       _O_: multi-occur
        _D_: delete up     ^ ^                _T_: files only: % -28`Buffer-menu-files-only
        _~_: modified
        "
      ("m" Buffer-menu-mark)
      ("u" Buffer-menu-unmark)
      ("U" Buffer-menu-backup-unmark)
      ("d" Buffer-menu-delete)
      ("D" Buffer-menu-delete-backwards)
      ("s" Buffer-menu-save)
      ("~" Buffer-menu-not-modified)
      ("x" Buffer-menu-execute)
      ("b" Buffer-menu-bury)
      ("g" revert-buffer)
      ("T" Buffer-menu-toggle-files-only)
      ("O" Buffer-menu-multi-occur :color blue)
      ("I" Buffer-menu-isearch-buffers :color blue)
      ("R" Buffer-menu-isearch-buffers-regexp :color blue)
      ("c" nil "cancel")
      ("v" Buffer-menu-select "select" :color blue)
      ("o" Buffer-menu-other-window "other-window" :color blue)
      ("q" quit-window "quit" :color blue))

    (define-key Buffer-menu-mode-map "." 'hydra-buffer-menu/body)
    )

#+end_src

#+begin_src emacs-lisp

  (use-package region-bindings
  :straight nil
  :bind ( :map region-bindings-mode-map
          ("q" . region-bindings-disable)
          ("r" . replace-string)
          ("R" . replace-regexp))
  :preface
  (define-minor-mode region-bindings-mode
    "Minor mode for mapping commands while region is active.
\\<region-bindings-mode-map>"
    :lighter " rbm"
    :group 'convenience
    :keymap (make-sparse-keymap))
  (defun region-bindings-disable (&optional force)
    "Turn off bindings temporarely while keeping the region active.
Bindings will be enabled next time region is highlighted."
    (interactive)
    (region-bindings-mode -1))
  (defun region-bindings-enable ()
    "Enable bindings temporarely while keeping the region active."
    (interactive)
    (when (or transient-mark-mode
              (eq #'mouse-set-region this-command))
      (region-bindings-mode 1)))
  (defun region-bindings-mode-enable ()
    "Enable region bindings for all buffers."
    (interactive)
    (add-hook 'activate-mark-hook #'region-bindings-enable)
    (add-hook 'deactivate-mark-hook #'region-bindings-disable))
  (defun region-bindings-mode-disable ()
    "Disable region bindings."
    (interactive)
    (remove-hook 'activate-mark-hook #'region-bindings-enable)
    (remove-hook 'deactivate-mark-hook #'region-bindings-disable)
    (region-bindings-mode -1))
  (provide 'region-bindings)
  :init
  (region-bindings-mode-enable))

#+end_src
*** Ibuffer and extras
ibuffer.el ships with Emacs and it provides a drop-in replacement for list-buffers. Compared to its counterpart, it allows for granular control over the buffer list and is more powerful overall. For this reason I bind it to C-x C-b.

Overview of its features:

- mark and delete buffers same way you do in dired (see the previous sections on dired (directory editor, file manager));
- mark by a predicate, such as name, major mode, etc.;
- sort buffers by name, filesystem path, major mode, size;
- run occur on the marked buffers (remember: Occur produces a buffer that you can edit once you enable the editable state with e);
- run query-replace or query-replace-regexp on marked buffers.

Run the universal help command for major mode documentation (C-h m) while inside ibuffer to get a detailed list of all available commands and their key bindings.
#+begin_src emacs-lisp
(use-package ibuffer
 :requires ibuf-ext
 :config (setq ibuffer-expert t
               ibuffer-display-summary nil
               ibuffer-use-other-window nil
               ibuffer-show-empty-filter-groups nil
               ibuffer-movement-cycle nil
               ibuffer-default-sorting-mode 'filename/process
               ibuffer-use-header-line t
               ibuffer-default-shrink-to-minimum-size nil
               ibuffer-formats
               '((mark modified read-only locked " "
                  (name 40 40 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " " filename-and-process)
                 (mark " "
                  (name 16 -1)
                  " " filename))
               ibuffer-saved-filter-groups nil
               ibuffer-old-time 48)
      :bind ( "C-x C-b" . #'ibuffer)
      :hook hl-line-mode
      ;; (let ((map ibuffer-mode-map))
      ;;   (define-key map (kbd "* f") #'ibuffer-mark-by-file-name-regexp)
      ;;   (define-key map (kbd "* g") #'ibuffer-mark-by-content-regexp) ; "g" is for "grep"
      ;;   (define-key map (kbd "* n") #'ibuffer-mark-by-name-regexp)
      ;;   (define-key map (kbd "s n") #'ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
      ;;   (define-key map (kbd "/ g") #'ibuffer-filter-by-content))
  )

#+end_src
The default way Emacs makes buffer names unique is really ugly and,
  dare I say it, stupid.  Instead, I want them to be uniquified by their
  filesystem paths.

#+begin_src emacs-lisp
(use-package uniquify
  :straight nil
  :ensure nil
  :config
  (setq uniquify-after-kill-buffer-p t)
  (setq uniquify-buffer-name-style 'forward)
  (setq-default
   uniquify-separator "/"
   uniquify-ignore-buffers-re "^\\*"))

#+end_src
** Tangle init-editor
:PROPERTIES:
:header-args: :tangle lisp/init-editor.el :noweb yes
:END:
Setup Editor functions

#+begin_src emacs-lisp
;;; init-editor.el --- Editor Setup  -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(require 'init-elpa)
;;(require 'init-kbd)
;;(require 'lib-vcs)
;;(require 'lib-string)

<<editor-sanity>>

;;<<evil>>

<<abbrev>>

<<dired>>

<<emacs-help>>

;;<<electric>>

<<whitespace>>

;;<<corgi-editor>>

<<avy>>

;;<<mwim>>

<<occur>>

<<undo>>

<<timestamp>>

<<server>>

<<corgi-ed-buffers>>

<<buffers>>

(provide 'init-editor)
;;; init-editor.el ends here
#+end_src
** Project Setup
:PROPERTIES:
:header-args: :noweb-ref projet
:END:
This is a bulit-in package to manage "projects" (that is, directory trees commonly called "projects")

It provides various commands that operate on the project, like project-find-file and project-query-replace-regexp.

By default a project is something that is managed by a VCS, such as git. However, sometimes is useful to mark something as a project without actually create a repo for it. This code, adapted from something that I found online I don't remember where, adds another implementation for the project backend that consider a project something that has a .project file.
#+begin_src emacs-lisp
(with-eval-after-load 'project
(setq project-list-file  GAS_DEV/ )

(defalias 'project-switch #'project-switch-project)

(defun project-p ()
  "Return non-nil when located in a project."
  (project-current))

;; Emacs 27
(unless (fboundp 'project-root)
  (cl-defmethod project-root ((project (head transient)))
    (cdr project)))

(defun project-shell-command ()
  "Invoke `shell-command' in the project's root."
  (interactive)
  (if-let* ((project (project-current))
            (root (project-root project)))
      (eval-with-default-dir root
        (call-interactively #'shell-command))
    (user-error "You are not in project")))

(defun op/project-try-local (dir)
  "Determine if DIR is a local project.
DIR must include a .project file to be considered a project."
  (when-let (root (locate-dominating-file dir ".project"))
    (cons 'local root)))

(add-to-list 'project-find-functions #'op/project-try-local)

(defun project-magit ()
  "Start `magit-status' in the current project's root directory."
  (interactive)
  (magit-status-setup-buffer (project-root (project-current t))))

(setq project-switch-commands
      '((?f "Find file" project-find-file)
        (?g "Find regexp" project-find-regexp)
        (?d "Dired" project-dired)
        (?v "Magit" project-magit)
        (?e "Eshell" project-eshell)))

(use-package rg
  :defer t
  :commands (rg-project)
  :init
  (defalias 'project-find-regexp #'rg-project))
)

#+end_src
** VCS
:PROPERTIES:
:header-args: :noweb-ref vcs
:END:
Setup of magit for cool git
#+begin_src emacs-lisp
;; (remove-hook 'find-file-hook #'vc-refresh-state)
;; (hook-with-delay 'find-file-hook 1 #'vc-refresh-state)

(use-package magit
  :defer t
  :defines (magit-status-mode-map
            magit-revision-show-gravatars
            magit-display-buffer-function
            magit-diff-refine-hunk)
  :commands (magit-display-buffer-same-window-except-diff-v1
             magit-stage-file
             magit-unstage-file)
  :init
  (setq-default magit-git-executable (executable-find "git"))
  :config
  (setq-default vc-follow-symlinks t)

  (defun vcs-quit (&optional _kill-buffer)
    "Clean up magit buffers after quitting `magit-status'.
    And don't forget to refresh version control in all buffers of
    current workspace."
    (interactive)
    (quit-window)
    (unless (cdr
             (delq nil
                   (mapcar (lambda (win)
                             (with-selected-window win
                               (eq major-mode 'magit-status-mode)))
                           (window-list))))
      (when (fboundp 'magit-mode-get-buffers)
        (mapc #'vcs--kill-buffer (magit-mode-get-buffers)))))

  (defun vcs--kill-buffer (buffer)
    "Gracefully kill `magit' BUFFER.
    If any alive process is related to this BUFFER, wait for 5
    seconds before nuking BUFFER and the process. If it's dead -
    don't wait at all."
    (when (and (bufferp buffer) (buffer-live-p buffer))
      (let ((process (get-buffer-process buffer)))
        (if (not (processp process))
            (kill-buffer buffer)
          (with-current-buffer buffer
            (if (process-live-p process)
                (run-with-timer 5 nil #'vcs--kill-buffer buffer)
              (kill-process process)
              (kill-buffer buffer)))))))

  ;; properly kill leftover magit buffers on quit
  (define-key magit-status-mode-map
    [remap magit-mode-bury-buffer]
    #'vcs-quit)

  (setq magit-revision-show-gravatars
        '("^Author:     " . "^Commit:     ")
        magit-display-buffer-function
        #'magit-display-buffer-same-window-except-diff-v1
        ;; show word-granularity on selected hunk
        magit-diff-refine-hunk t)
  (setq git-commit-summary-max-length 120)
  (setq magit-commit-show-diff nil)
  (setq magit-delete-by-moving-to-trash nil)
  (setq magit-display-buffer-function
        #'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-log-auto-more t)
  (setq magit-log-margin-show-committer-date t)
  (setq magit-revert-buffers 'silent)
  (setq magit-save-repository-buffers 'dontask)
  (setq magit-wip-after-apply-mode t)
  (setq magit-wip-after-save-mode t)
  (setq magit-wip-before-change-mode t)
  (setq transient-values
        '((magit-log:magit-log-mode "--graph" "--color" "--decorate"))))

;;(use-package forge
;;      :commands forge-create-pullreq forge-create-issue
;;      :init
;;      (setq-default forge-database-file
;;                    (expand-file-name "forge/forge-database.sqlite"
;;                                      EMACS_ETC/)))

;; (use-package git-timemachine
;;   :bind  (( "[" .  #'git-timemachine-show-previous-revision
;;            "]"  .  #'git-timemachine-show-next-revision
;;            "b" .   #'git-timemachine-blame)))

(use-package ediff-wind
  :straight nil
  :defer t
  :init
  (setq ediff-window-setup-function 'ediff-setup-windows-plain
        ediff-split-window-function 'split-window-horizontally))

(use-package diff-hl
  :defer t
  :hook ((prog-mode . turn-on-diff-hl-mode)
         (text-mode . turn-on-diff-hl-mode)
         (vc-dir-mode . turn-on-diff-hl-mode)
         (dired-mode . diff-hl-dired-mode)))

;; (use-package  magit-todos
;; :after magit
;; :config
;; (magit-todos-mode 1))

#+end_src
** Completion & Selection
Unlike the desktop metaphor, the optimal way to use Emacs is through searching and narrowing selection candidates. Spend less time worrying about where things are on the screen and more on how fast you can bring them into focus. This is, of course, a matter of realigning priorities, as we still wish to control every aspect of the interface, as we do elsewhere in this document.
*** Corgi navigation
#+begin_src emacs-lisp :noweb-ref corgi-nav
(use-package ivy
  :defer 0.1
  :diminish
  :init
  (setq ivy-use-virtual-buffers t)
  :config
  (ivy-mode)
  (define-key ivy-minibuffer-map (kbd "C-j") #'ivy-next-line)
  (define-key ivy-minibuffer-map (kbd "C-k") #'ivy-previous-line))

(use-package counsel
  :after (ivy)
  :diminish
  :config
  (counsel-mode)
  ;; This ensures that SPC f r (counsel-recentf, show recently opened files)
  ;; actually works
  (recentf-mode 1))

(use-package ivy-prescient
  :after (ivy)
  :config
  (ivy-prescient-mode 1)
  (prescient-persist-mode 1))

(use-package swiper
  :after (ivy)
  :bind (("C-s" . swiper)))

(use-package avy)

(use-package undo-fu)
#+end_src
*** Orderless
Controls the sorting of the minibuffer completions. I still have to tweak it a little bit.

- With the equals sign appended to a sequence of characters, we call prot-orderless-literal-dispatcher which instructs orderless to match that sequence as a literal string.
- A comma at the end of a string of characters treats that group as an initialism, per prot-orderless-initialism-dispatcher.
- While a tilde (prot-orderless-flex-dispatcher) makes it a flex match.

#+begin_src emacs-lisp :noweb-ref orderless
(use-package orderless
  :custom ((completion-styles '(orderless))
           (completion-category-defaults nil)
           (completion-category-overrides '((file (styles . (partial-completion)))))))

;;; Orderless completion style (and prot-orderless.el)
;; (setup (:pkg orderless)
;;   (:require prot-orderless)
;;   (setq orderless-component-separator " +")
;;   ;; NOTE 2022-02-06: I made some major changes and this list may need
;;   ;; to be refined further.  Remember to check my `completion-styles'
;;   ;; and the `completion-category-overrides'.
;;   (setq orderless-matching-styles
;;         '( orderless-prefixes orderless-strict-leading-initialism
;;            orderless-flex orderless-regexp))
;;   (setq orderless-style-dispatchers
;;         '(prot-orderless-literal-dispatcher
;;           prot-orderless-initialism-dispatcher
;;           prot-orderless-flex-dispatcher))

;;   ;; SPC should never complete: use it for `orderless' groups.
;;   ;; The `?' is a regexp construct.
;;   (let ((map minibuffer-local-completion-map))
;;     (define-key map (kbd "SPC") nil)
;;     (define-key map (kbd "?") nil)))

#+end_src
*** Completion annotations
Marginalia provides helpful annotations for various types of minibuffer completions. You can think of it as a replacement of ivy-rich.
#+begin_src emacs-lisp :noweb-ref annotations
;;; Completion annotations (marginalia)
(use-package marginalia
  :after vertico
  :custom (marginalia-annotators
           '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :init (marginalia-mode)
  :config
  (setq marginalia-max-relative-age 0)  ; time is absolute here!
  (define-key minibuffer-local-map (kbd "M-A") #'marginalia-cycle))

 ;; (setup (:pkg marginalia)
 ;;    (:load-after vertico
 ;;      (setq marginalia-max-relative-age 0)  ; time is absolute here!
 ;;          (marginalia-mode 1))
 ;;    (:with-map minibuffer-local-map
 ;;      (:bind "M-A" marginalia-cycle)))

#+end_src
*** Completion Actions with Embark
#+begin_src emacs-lisp :noweb-ref actions
(use-package embark
  :bind (([remap describe-bindings] .  #'embark-bindings)
         ("C-;" . embark-act)
         :map minibuffer-local-map
         ("C-;" . embark-act)
         ("C-c C-;" . embark-export)
         ("C-c C-l" . embark-collect))
  :config
  (require 'consult)
  ;; Show Embark actions via which-key
  (setq embark-action-indicator
        (lambda (map)
          (which-key--show-keymap "Embark" map nil nil 'no-paging)
          #'which-key--hide-popup-ignore-command)
        embark-become-indicator embark-action-indicator))

;; (use-package embark-consult
;;   :straight '(embark-consult :host github
;;                              :repo "oantolin/embark"
;;                              :files ("embark-consult.el"))
;;   :after (embark consult)
;;   :demand t
;;   :hook
;;   (embark-collect-mode . embark-consult-preview-minor-mode))
 ;; (setup selection
 ;;    (setq kill-do-not-save-duplicates t)
 ;;    (setq select-enable-clipboard t)
 ;;    (setq select-enable-primary t)
 ;;    (setq x-select-enable-clipboard-manager nil))

#+end_src
*** Vertico
Vertico is just like selectrum or icomplete-vertical.
#+begin_src emacs-lisp vertico
(use-package vertico
  :straight '(vertico :host github
                      :repo "minad/vertico"
                      :branch "main")
  :bind (:map vertico-map
              ("C-n" . vertico-next)
              ("C-p" . vertico-previous)
              ("RET" . vertico-exit)
              :map minibuffer-local-map
              ("M-h" . dw/minibuffer-backward-kill))
  :custom
  (vertico-cycle t)
  :custom-face
  (vertico-current ((t (:background "#3a3f5a"))))
  :init
  (vertico-mode)
  :config
  (defun dw/minibuffer-backward-kill (arg)
    "When minibuffer is completing a file name delete up to parent
folder, otherwise delete a word"
    (interactive "p")
    (if minibuffer-completing-file-name
    ;; Borrowed from https://github.com/raxod502/selectrum/issues/498#issuecomment-803283608
    (if (string-match-p "/." (minibuffer-contents))
            (zap-up-to-char (- arg) ?/)
          (delete-minibuffer-contents))
      (backward-kill-word arg))))

;; (use-package vertico
;;   :bind ( :map vertico-map
;;           ("M-RET" . vertico-exit-input))
;;   :init
;;   (vertico-mode))

;; (use-package vertico-directory
;;   :after vertico
;;   :straight nil
;;   :load-path "straight/repos/vertico/extensions/"
;;   :bind ( :map vertico-map
;;           ("RET" . vertico-directory-enter)
;;           ("DEL" . vertico-directory-delete-char)
;;           ("M-DEL" . vertico-directory-delete-word))
;; Tidy shadowed file names
;; :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
#+end_src
*** Minibuffer Configurations
The minibuffer is the epicentre of extended interactivity with all sorts of Emacs workflows: to select a buffer, open a file, provide an answer to some prompt, such as a number, regular expression, password, and so on.

Emacs has built-in capabilities to perform two distinct tasks related to such interactions:
**** Completion history
#+begin_src emacs-lisp :noweb-ref completion-hist
(use-package savehist
  :config
  (setq history-length 25)
  (savehist-mode 1))

;; Individual history elements can be configured separately
;;(put 'minibuffer-history 'history-length 25)
;;(put 'evil-ex-history 'history-length 50)
;;(put 'kill-ring 'history-length 25))
#+end_src
**** Narrowing
    Use pattern matching algorithms to limit the list of choices (known as “candidates” or “completion candidates”) to those matching the given input. There are several pattern matching styles already built-in, while we can opt to extend them further.
**** Selecting
    Visualise the list of completion candidates and pick an item out of it using regular motions or concomitant extras. By default, Emacs visualises results in a special *Completions* buffer, which does not have lots of features and is not particularly pleasing to use.
**** Completion styles
    I rely on a mixture of built-in styles as well as the external orderless package by Omar Antolín Camarena. Orderless is placed last on some lists because simpler searches work fine with the other styles. My ordering goes from least to most powerful. Orderless is better suited for complex pattern matching. The way completion styles work, when one style cannot match anything, Emacs tries the next one on the list, until one of them yields results. As such, it is easy to activate Orderless on demand, either by separating input groups with spaces or passing one of the style dispatchers that are acceptable (read the Orderless completion style).

    For file queries in particular, there exists a niche functionality in the built-in initials and partial-completion styles to navigate abbreviated paths. Here is an example with the latter: you can type ~/.l/s/fo which will match ~/.local/share/fonts. The variable completion-category-overrides can control the standard option of completion-styles on a per-category basis.
**** Recursive minibuffers
    I enable recursive minibuffers. This practically means that you can start something in the minibuffer, switch to another window, call the minibuffer again, run some commands, and then move back to what you initiated in the original minibuffer. Or simply call an M-x command while in the midst of a minibuffer session. To exit, hit C-] (abort-recursive-edit), though the regular C-g should also do the trick.

    The minibuffer-depth-indicate-mode will show a recursion indicator, represented as a number, next to the minibuffer prompt, if a recursive edit is in progress (also check Mode line recursion indicators).

#+begin_src emacs-lisp :noweb-ref minibuffer
;;; Minibuffer configurations and my extras (mct.el)
(use-package  minibuffer
    :straight nil
    :config
    (setq completion-styles '(basic orderless)) ; also see `completion-category-overrides'
    (setq completion-category-defaults nil)
    ;; For a list of known completion categories, check the MCT manual's
    ;; section on the matter:
    ;; <https://protesilaos.com/emacs/mct#h:1f42c4e6-53c1-4e8a-81ef-deab70822fa4>
    (setq completion-category-overrides
      ;; NOTE 2021-10-25: I am adding `basic' because it works better as a
      ;; default for some contexts.  Read:
      ;; <https://debbugs.gnu.org/cgi/bugreport.cgi?bug=50387>.
      ;;
      ;; `partial-completion' is a killer app for files, because it
      ;; can expand ~/.l/s/fo to ~/.local/share/fonts.
      '((file (styles . (basic partial-completion orderless)))
        (project-file (styles . (basic substring partial-completion orderless)))
        (imenu (styles . (basic substring orderless)))
        (kill-ring (styles . (basic substring orderless)))
        (consult-location (styles . (basic substring orderless)))))

    (setq completion-cycle-threshold 2)
    (setq completion-flex-nospace nil) ; though I don't use the built-in `flex' style...
    (setq completion-pcm-complete-word-inserts-delimiters nil)
    (setq completion-pcm-word-delimiters "-_./:| ")
    (setq completion-ignore-case t)
    (setq completions-detailed t)
    (setq-default case-fold-search t)   ; For general regexp

    ;; Grouping of completions for Emacs 28
    (setq completions-group t)
    (setq completions-group-sort nil)
    (setq completions-group-format
      (concat
       (propertize "    " 'face 'completions-group-separator)
       (propertize " %s " 'face 'completions-group-title)
       (propertize " " 'face 'completions-group-separator
               'display '(space :align-to right))))

    (setq read-buffer-completion-ignore-case t)
    (setq read-file-name-completion-ignore-case t)

    (setq enable-recursive-minibuffers t)
    (setq read-answer-short t) ; also check `use-short-answers' for Emacs28
    (setq resize-mini-windows t)
    (setq minibuffer-eldef-shorten-default t)

    (setq echo-keystrokes 0.25)           ; from the C source code
    (setq kill-ring-max 60)               ; Keep it small

    ;; Do not allow the cursor to move inside the minibuffer prompt.  I
    ;; got this from the documentation of Daniel Mendler's Vertico
    ;; package: <https://github.com/minad/vertico>.
    (setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))

    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Adapted from Vertico.
    (defun crm-indicator (args)
      "Add prompt indicator to `completing-read-multiple' filter ARGS."
      ;; The `error' face just makes the text red.
      (cons (concat (propertize "[CRM] " 'face 'error) (car args))
        (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    (file-name-shadow-mode 1)
    (minibuffer-depth-indicate-mode 1)
    (minibuffer-electric-default-mode 1)

    ;; I use this prefix for other searches
    (define-key minibuffer-local-must-match-map (kbd "M-s") nil))

     ;; (setup minibuffer
     ;;   (file-name-shadow-mode 1)
     ;;   (minibuffer-depth-indicate-mode 1)
     ;;  (minibuffer-electric-default-mode 1)
     ;;  (fset #'yes-or-no-p #'y-or-n-p)
     ;;  (setq enable-recursive-minibuffers t)
     ;;  (setq file-name-shadow-properties '(invisible t intangible t))
     ;;  (setq minibuffer-eldef-shorten-default t)
     ;;  (setq minibuffer-prompt-properties
     ;;        '(read-only t cursor-intangible t face minibuffer-prompt))
     ;;  (setq read-answer-short t)
     ;;  (setq read-extended-command-predicate #'command-completion-default-include-p)
     ;;  (setq use-short-answers t)
     ;;  ;; https://www.manueluberti.eu//emacs/2021/12/10/shell-command/
     ;;  (defun +minibuffer-complete-history ()
     ;;    "Complete minibuffer history."
     ;;    (interactive)
     ;;    (completion-in-region (minibuffer--completion-prompt-end) (point-max)
     ;;                          (symbol-value minibuffer-history-variable)
     ;;                          nil))
     ;;  (:with-hook minibuffer-setup-hook
     ;;    (:hook cursor-intangible-mode))
     ;;  (:with-map minibuffer-local-map
     ;;    (:bind "M-/" #'+minibuffer-complete-history))
     ;;  (:with-map minibuffer-inactive-mode-map
     ;;    (:bind "<mouse-1>" ignore)))
#+end_src

**** Consult
Consult, which provides a suite of useful commands using completing-read
#+begin_src emacs-lisp :noweb-ref consult
;; (defun dw/get-project-root ()
;;   (when (fboundp 'project-root)
;;     (project-root)))

;; (use-package consult
;;   :bind (("C-c h" . consult-history)
;;          ("C-c m" . consult-mode-command)
;;          ("C-c b" . consult-bookmark)
;;          ("C-c k" . consult-kmacro)
;;          ("C-x M-:" . consult-complex-command)
;;          ("C-x b" . consult-buffer)
;;          ("C-x 4 b" . consult-buffer-other-window)
;;          ("C-x 5 b" . consult-buffer-other-frame)
;;          ("M-#" . consult-register-load)
;;          ("M-'" . consult-register-store)
;;          ("C-M-#" . consult-register)
;;          ("M-g e" . consult-compile-error)
;;          ("M-g g" . consult-goto-line)
;;          ("M-g M-g" . consult-goto-line)
;;          ("M-g o" . consult-outline)
;;          ("M-g m" . consult-mark)
;;          ("M-g k" . consult-global-mark)
;;          ("M-g i" . consult-imenu)
;;          ("M-g I" . consult-project-imenu)
;;          ("M-s f" . op/consult-find)
;;          ("M-s g" . consult-grep)
;;          ("M-s l" . consult-line)
;;          ("M-s k" . consult-keep-lines)
;;          ("M-s u" . consult-focus-lines)
;;          ("M-s e" . consult-isearch)
;;          :map minibuffer-local-map
;;          ("C-r" . consult-history))
;;   :custom
;;   ((register-preview-delay 0)
;;    (register-preview-function #'consult-register-format)
;;    ;; use consult to select xref locations with preview
;;    ;;(xref-show-xrefs-function #'consult-xref)
;;    ;;(xref-show-definitions-function #'consult-xref)
;;    (consult-narrow-key "<")
;;    (consult-project-root #'project-roots)
;;    (consult-find-args "find .")
;;    (consult-grep-args "grep --null --line-buffered --ignore-case -RIn")
;;    (consult-project-root-function #'dw/get-project-root)
;;    (completion-in-region-function #'consult-completion-in-region))
;;   :config
;;   ;; make narrowing help available in the minibuffer.
;;   (define-key consult-narrow-map (vconcat consult-narrow-key "?")
;;               #'consult-narrow-help)

;;   ;; (setq consult-line-numbers-widen t)
;;   ;; ;; (setq completion-in-region-function #'consult-completion-in-region)
;;   ;; (setq consult-async-min-input 3)
;;   ;; (setq consult-async-input-debounce 0.5)
;;   ;; (setq consult-async-input-throttle 0.8)
;;   ;;(consult-preview-mode)
;;   )

(use-package consult
  :preface
  (defvar consult-prefix-map (make-sparse-keymap))
  (fset 'consult-prefix-map consult-prefix-map)
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (;; C-c bindings (mode-specific-map)
         ("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ("C-c k" . consult-kmacro)
         ;; C-s bindings
         ;;("C-s" . consult-find)
         ;; C-x bindings (ctl-x-map)
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ("<help> a" . consult-apropos)            ;; orig. apropos-command
         ;; M-g bindings (goto-map)
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings (search-map)
         ("M-s d" . consult-find)
         ("M-s D" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history)                 ;; orig. previous-matching-history-element
     :map ctl-x-map
     ("c" . consult-prefix-map)
     :map consult-prefix-map
     ("r" . consult-recent-file)
     ("o" . consult-outline)
     ("i" . consult-imenu)
     ("g" . consult-grep)
     ("f" . jnf/consult-ripgrep))
  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key (kbd "M-."))
  ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-theme
   :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-recent-file
   consult--source-project-recent-file
   :preview-key (kbd "M-."))

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;; There are multiple reasonable alternatives to chose from.
  ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
  ;;;; 2. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
  ;;;; 3. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
  ;;;; 4. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))

  ;; (setq consult-line-numbers-widen t)
  ;; (setq completion-in-region-function #'consult-completion-in-region)
  ;; (setq consult-async-min-input 3)
  ;; (setq consult-async-input-debounce 0.5)
  ;; (setq consult-async-input-throttle 0.8)
  ;; (setq consult-narrow-key ">")
  (setq consult-imenu-config
    '((emacs-lisp-mode :toplevel "Functions"
               :types ((?f "Functions" font-lock-function-name-face)
                   (?m "Macros"    font-lock-keyword-face)
                   (?p "Packages"  font-lock-constant-face)
                   (?t "Types"     font-lock-type-face)
                   (?v "Variables" font-lock-variable-name-face)))))
  ;; Updating the default to include "--ignore-case"
  (setq consult-ripgrep-command "rg --null --line-buffered --color=ansi --max-columns=1000 --ignore-case --no-heading --line-number . -e ARG OPTS")

  ;; From https://github.com/minad/consult/wiki#find-files-using-fd
  ;; Note: this requires lexical binding
  (defun jnf/consult-find-using-fd (&optional dir initial)
    "Find project files.
A replacement for `projectile-find-file'."
    (interactive "P")
    (let ((consult-find-command "fd --color=never --hidden --exclude .git/ --full-path ARG OPTS"))
      (consult-find dir initial)))

  (defun jnf/consult-line (consult-line-function &rest rest)
    "Advising function around `CONSULT-LINE-FUNCTION'.
When there's an active region, use that as the first parameter
for `CONSULT-LINE-FUNCTION'.  Otherwise, use the current word as
the first parameter.  This function handles the `REST' of the
parameters."
    (interactive)
    (apply consult-line-function
       (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
       rest))

  (defun jnf/consult-ripgrep (consult-ripgrep-function &optional dir &rest rest)
    "Use region or thing at point to populate initial parameter for `CONSULT-RIPGREP-FUNCTION'.
When there's an active region, use that as the initial parameter
for the `CONSULT-RIPGREP-FUNCTION'.  Otherwise, use the thing at
point.
`DIR' use the universal argument (e.g. C-u prefix) to first set
the directory.  `REST' is passed to the `CONSULT-RIPGREP-FUNCTION'."
    (interactive "P")
    (apply consult-ripgrep-function
       dir
       (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
       rest))

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)
  (advice-add #'consult-line :around #'jnf/consult-line '((name . "wrapper")))
  (advice-add #'consult-ripgrep :around #'jnf/consult-ripgrep '((name . "wrapper")))
  (setq consult-after-jump-hook nil) ; reset it to avoid conflicts with my function
  ;;(add-hook 'consult-after-jump-hook #'prot-pulse-recentre-top) ; see `prot-pulse.el'

  (add-hook 'completion-list-mode-hook #'consult-preview-at-point-mode)

  (require 'consult-imenu) ; the `imenu' extension is in its own file

  ;; (let ((map global-map))
  ;;   (define-key map (kbd "C-x r b") #'consult-bookmark) ; override `bookmark-jump'
  ;;   (define-key map (kbd "C-x M-:") #'consult-complex-command)
  ;;   (define-key map (kbd "C-x M-m") #'consult-minor-mode-menu)
  ;;   (define-key map (kbd "C-x M-k") #'consult-kmacro)
  ;;   (define-key map [remap goto-line] #'consult-goto-line)
  ;;   (define-key map (kbd "M-K") #'consult-keep-lines) ; M-S-k is similar to M-S-5 (M-%)
  ;;   (define-key map (kbd "M-F") #'consult-focus-lines) ; same principle
  ;;   (define-key map (kbd "M-s M-b") #'consult-buffer)
  ;;   (define-key map (kbd "M-s M-f") #'consult-find)
  ;;   (define-key map (kbd "M-s M-g") #'consult-grep)
  ;;   (define-key map (kbd "M-s M-h") #'consult-history)
  ;;   (define-key map (kbd "M-s M-i") #'consult-imenu)
  ;;   (define-key map (kbd "M-s M-l") #'consult-line)
  ;;   (define-key map (kbd "M-s M-m") #'consult-mark)
  ;;   (define-key map (kbd "M-s M-s") #'consult-outline)
  ;;   (define-key map (kbd "M-s M-y") #'consult-yank-pop)
  ;;   (define-key map (kbd "C-x r r") #'consult-register)) ; Use the register's prefix
  ;; (define-key consult-narrow-map (kbd "?") #'consult-narrow-help)
  )


#+end_src
*** Completion in Regions with corfu
#+begin_src emacs-lisp :noweb-ref corfu
(use-package corfu
  :straight '(corfu :host github
                    :repo "minad/corfu")
  :bind (:map corfu-map
         ("C-j" . corfu-next)
         ("C-k" . corfu-previous)
         ("C-f" . corfu-insert))
  :custom
  (corfu-cycle t)
  :config
  (corfu-global-mode +1))
;; Enable Corfu more generally for every minibuffer, as long as no other
;; completion UI is active. If you use Mct or Vertico as your main minibuffer
;; completion UI. From
;; https://github.com/minad/corfu#completing-with-corfu-in-the-minibuffer
;; (defun corfu-enable-always-in-minibuffer ()
;;   "Enable Corfu in the minibuffer if Vertico/Mct are not active."
;;   (unless (or (bound-and-true-p mct--active) ; Useful if I ever use MCT
;;  (bound-and-true-p vertico--input))
;;     (setq-local corfu-auto nil)       ; Ensure auto completion is disabled
;;     (corfu-mode 1)))

;; (use-package corfu
;;   :bind ( :map corfu-map
;;          ("TAB" . corfu-next)
;;          ([tab] . corfu-next)
;;          ("S-TAB" . corfu-previous)
;;          ([backtab] . corfu-previous)
;;          ([remap completion-at-point] . corfu-complete)
;;          ("RET" . corfu-complete-and-quit)
;;          ("<return>" . corfu-complete-and-quit))
;;   :custom
;;   (corfu-auto nil)        ; Only use `corfu' when calling `completion-at-point' or
;;                           ; `indent-for-tab-command'
;;   ;; (corfu-auto-prefix 2)
;;   ;; (corfu-auto-delay 0.25)

;;   (corfu-min-width 80)
;;   (corfu-max-width corfu-min-width)       ; Always have the same width
;;   (corfu-count 14)
;;   (corfu-scroll-margin 4)
;;   (corfu-cycle nil)

;;   ;; `nil' means to ignore `corfu-separator' behavior, that is, use the older
;;   ;; `corfu-quit-at-boundary' = nil behavior. Set this to separator if using
;;   ;; `corfu-auto' = `t' workflow (in that case, make sure you also set up
;;   ;; `corfu-separator' and a keybind for `corfu-insert-separator', which my
;;   ;; configuration already has pre-prepared). Necessary for manual corfu usage with
;;   ;; orderless, otherwise first component is ignored, unless `corfu-separator'
;;   ;; is inserted.
;;   (corfu-quit-at-boundary nil)
;;   (corfu-preselect-first t)        ; Preselect first candidate?
;;   (corfu-echo-documentation nil)

;;   ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
;;   ;; want to perform completion
;;   (tab-always-indent 'complete)
;;   (completion-cycle-threshold nil)      ; Always show all candidates in popup menu
;;   :config
;;   ;; evil setup for corfu
;;   (evil-make-overriding-map corfu-map)
;;   (advice-add 'corfu--setup :after 'evil-normalize-keymaps)
;;   (advice-add 'corfu--teardown :after 'evil-normalize-keymaps)
;;   :init
;;   ;;(add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)
;;   )

;; (use-package kind-icon
;;   :disable t
;;   :after corfu
;;   :custom
;;   (kind-icon-use-icons t)
;;   (kind-icon-default-face 'corfu-default) ; Have background color be the same as `corfu' face background
;;   (kind-icon-blend-background nil)  ; Use midpoint color between foreground and background colors ("blended")?
;;   (kind-icon-blend-frac 0.08)

;;   ;; NOTE 2022-02-05: `kind-icon' depends `svg-lib' which creates a cache
;;   ;; directory that defaults to the `user-emacs-directory'. Here, I change that
;;   ;; directory to a location appropriate to `no-littering' conventions, a
;;   ;; package which moves directories of other packages to sane locations.
;;   (svg-lib-icons-dir (no-littering-expand-var-file-name "svg-lib/cache/")) ; Change cache dir
;;   :config
;;   (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter) ; Enable `kind-icon'

;;   ;; Add hook to reset cache so the icon colors match my theme
;;   ;; NOTE 2022-02-05: This is a hook which resets the cache whenever I switch
;;   ;; the theme using my custom defined command for switching themes. If I don't
;;   ;; do this, then the backgound color will remain the same, meaning it will not
;;   ;; match the background color corresponding to the current theme. Important
;;   ;; since I have a light theme and dark theme I switch between. This has no
;;   ;; function unless you use something similar
;;   (add-hook 'kb/themes-hooks #'(lambda () (interactive) (kind-icon-reset-cache))))

;; (use-package corfu-doc
;;   ;; NOTE 2022-02-05: At the time of writing, `corfu-doc' is not yet on melpa
;;   :straight (corfu-doc :type git :host github :repo "galeo/corfu-doc")
;;   :disable t
;;   :after corfu
;;   :hook (corfu-mode . corfu-doc-mode)
;;   :bind ( :map corfu-map
;;          ("M-p" . corfu-doc-scroll-down)
;;          ("M-n" . corfu-doc-scroll-up))
;;   :custom
;;   (corfu-doc-delay 0.5)
;;   (corfu-doc-max-width 70)
;;   (corfu-doc-max-height 20)

;;   ;; NOTE 2022-02-05: I've also set this in the `corfu' use-package to be
;;   ;; extra-safe that this is set when corfu-doc is loaded. I do not want
;;   ;; documentation shown in both the echo area and in the `corfu-doc' popup.
;;   (corfu-echo-documentation nil))

#+end_src

#+begin_src emacs-lisp :noweb-ref cape
(use-package cape
  :config
  (setq completion-at-point-functions '(cape-file cape-dabbrev)))
#+end_src


*** Tangle Completion Frameworks
:PROPERTIES:
:header-args: :tangle lisp/init-selection.el :noweb yes
:END:

Tangle embark, vertico and consult

#+begin_src emacs-lisp
;;; init-selection.el --- Completion -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<orderless>>

<<completion-hist>>

<<annotations>>

<<vertico>>

<<minibuffer>>

<<consult>>

<<actions>>

<<corfu>>

<<cape>>

;;<<corgi-nav>>

(provide 'init-selection)
;;; init-selection.el ends here
#+end_src
** Emacs keyboard Setting
*** Emacs default bindings

#+begin_src emacs-lisp :noweb-ref emacs-bindings
(use-package bind-key)
(require 'bind-key)
(require 'diminish)

;; BETTER-DEFAULTS

(global-set-key (kbd "C-x C-b") 'ibuffer)
(global-set-key (kbd "M-/") 'hippie-expand)

;; MATCHING BRACKET LIKE VIM's "%"

(defun forward-or-backward-sexp (&optional arg)
  "Go to the matching parenthesis character if one is adjacent to point."
  (interactive "^p")
  (cond ((looking-at "\\s(") (forward-sexp arg))
        ((looking-back "\\s)" 1) (backward-sexp arg))
        ;; Now, try to succeed from inside of a bracket
        ((looking-at "\\s)") (forward-char) (backward-sexp arg))
        ((looking-back "\\s(" 1) (backward-char) (forward-sexp arg))))

(global-set-key (kbd "C-%") 'forward-or-backward-sexp)

(use-package bindings
    :straight nil
    :ensure nil
    :bind ( :map ctl-x-map
            ("C-d" . dired-jump)
            :map narrow-map
            ("i d" . indirect-narrow-to-defun)
            ("i n" . indirect-narrow-to-region)
            ("]" . narrow-next-page)
            ("[" . narrow-prev-page))
    :init
    (setq mode-line-end-spaces nil)
    ;; (define-advice keyboard-quit (:around (quit))
    ;;   "Quit the current context.
    ;;   When there is an active minibuffer and we are not inside it close
    ;;   it.  When we are inside the minibuffer use the regular
    ;;   `minibuffer-keyboard-quit' which quits any active region before
    ;;   exiting.  When there is no minibuffer `keyboard-quit' unless we
    ;;   are defining or executing a macro."
    ;;   (if (active-minibuffer-window)
    ;;       (if (minibufferp)
    ;;           (minibuffer-keyboard-quit)
    ;;         (abort-recursive-edit))
    ;;     (unless (or defining-kbd-macro
    ;;                 executing-kbd-macro)
    ;;       (funcall-interactively quit))))
)

(use-package crux
:config
  (global-set-key (kbd "C-a") 'crux-move-beginning-of-line)
  (global-set-key (kbd "C-o") 'crux-smart-open-line)
  (global-set-key (kbd "C-c C-l") 'crux-duplicate-current-line-or-region)
  (global-set-key (kbd "C-c C--") 'crux-kill-whole-line)
  (global-set-key (kbd "C-c ;") 'crux-duplicate-and-comment-current-line-or-region))

;; REGEXP SEARCH

(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "C-M-s") 'isearch-forward)
(global-set-key (kbd "C-r") 'isearch-backward-regexp)
(global-set-key (kbd "C-M-r") 'isearch-backward)

#+end_src
*** Prot simple
prot-simple.el contains a wide range of commands that are broadly in line with the built-in simple.el and lisp.el libraries. While I could offer an overview of each item in my library, I feel the code and accompanying documentation strings are clear enough for you to peruse the source directly (reproduced further below).

Still, here are some highlights for those who don’t like studying the source code:

- prot-simple-insert-pair will surround either the symbol-at-point or the active region with a pair of delimiters. It prompts for completion on which pair to use, while the most recently used entry becomes the default, so next time the user can just add it with RET at the minibuffer prompt. With an optional prefix argument (C-u) it asks for how many times to insert the selected delimiters (e.g. you want to wrap two angled brackets around the region).
- prot-simple-scratch-buffer produces a buffer with the major-mode of the current one. With a prefix argument (C-u) it instead applies the major-mode which is stored in the user customisation option prot-simple-scratch-buffer-default-mode. With a double prefix argument (C-u C-u) it prompts for completion on which major-mode to use. If the region is active, its contents are copied to the newly created scratch buffer. The idea is based on the scratch.el package by Ian Eure.
- prot-simple-copy-line-or-region copies the current line or the region, if that is active. With a prefix argument (C-u) it creates a duplicate of it right below.

All of the other commands are optimisations for common motions or little quality-of-life improvements for oft-required operations (such as transposition of objects or marking of balanced expressions).

Given that this is a foundational piece of my Emacs setup, it is the appropriate place to re-bind or free up some common key combinations for use elsewhere.
#+begin_src emacs-lisp :noweb-ref prot-keyboard
(setup (:require prot-simple)
       (setq prot-simple-date-specifier "%F")
       (setq prot-simple-time-specifier "%R %z")
       (setq delete-pair-blink-delay 0.15) ; Emacs28 -- see `prot-simple-delete-pair-dwim'
       (setq prot-simple-scratch-buffer-default-mode 'markdown-mode)
       (setq help-window-select t)

       ;; General commands
       (let ((map global-map))
     (define-key map (kbd "<insert>") nil)
     (define-key map (kbd "C-z") nil)
     (define-key map (kbd "C-x C-z") nil)
     (define-key map (kbd "C-h h") nil)
     (define-key map (kbd "M-`") nil)
     (define-key map (kbd "C-h .") #'prot-simple-describe-symbol) ; overrides `display-local-help'
     (define-key map (kbd "C-h K") #'describe-keymap) ; overrides `Info-goto-emacs-key-command-node'
     (define-key map (kbd "C-h c") #'describe-char) ; overrides `describe-key-briefly'
     (define-key map (kbd "C-c s") #'prot-simple-scratch-buffer)
     ;; Commands for lines
     (define-key map (kbd "C-S-w") #'prot-simple-copy-line-or-region)
     (define-key map (kbd "C-S-y") #'prot-simple-yank-replace-line-or-region)
     (define-key map (kbd "M-SPC") #'cycle-spacing)
     (define-key map (kbd "M-o") #'delete-blank-lines)   ; alias for C-x C-o
     (define-key map (kbd "M-k") #'prot-simple-kill-line-backward)
     (define-key map (kbd "C-S-n") #'prot-simple-multi-line-next)
     (define-key map (kbd "C-S-p") #'prot-simple-multi-line-prev)
     (define-key map (kbd "<C-return>") #'prot-simple-new-line-below)
     (define-key map (kbd "<C-S-return>") #'prot-simple-new-line-above)
     ;; Commands for text insertion or manipulation
     (define-key map (kbd "C-=") #'prot-simple-insert-date)
     (define-key map (kbd "C-<") #'prot-simple-escape-url)
     (define-key map (kbd "C-'") #'prot-simple-insert-pair)
     (define-key map (kbd "M-'") #'prot-simple-insert-pair)
     (define-key map (kbd "M-\\") #'prot-simple-delete-pair-dwim)
     (define-key map (kbd "C-M-;") #'prot-simple-cite-region)
     (define-key map (kbd "C-M-^") #'prot-simple-insert-undercaret)
     (define-key map (kbd "<C-M-backspace>") #'backward-kill-sexp)
     (define-key map (kbd "M-c") #'capitalize-dwim)
     (define-key map (kbd "M-l") #'downcase-dwim)        ; "lower" case
     (define-key map (kbd "M-u") #'upcase-dwim)
     ;; Commands for object transposition
     (define-key map (kbd "C-t") #'prot-simple-transpose-chars)
     (define-key map (kbd "C-x C-t") #'prot-simple-transpose-lines)
     (define-key map (kbd "C-S-t") #'prot-simple-transpose-paragraphs)
     (define-key map (kbd "C-x M-t") #'prot-simple-transpose-sentences)
     (define-key map (kbd "C-M-t") #'prot-simple-transpose-sexps)
     (define-key map (kbd "M-t") #'prot-simple-transpose-words)
     ;; Commands for marking objects
     (define-key map (kbd "M-@") #'prot-simple-mark-word)       ; replaces `mark-word'
     (define-key map (kbd "C-M-SPC") #'prot-simple-mark-construct-dwim)
     (define-key map (kbd "C-M-d") #'prot-simple-downward-list)
     ;; Commands for paragraphs
     (define-key map (kbd "M-Q") #'prot-simple-unfill-region-or-paragraph)
     ;; Commands for windows and pages
     (define-key map (kbd "C-x n k") #'prot-simple-delete-page-delimiters)
     (define-key map (kbd "C-x M") #'prot-simple-monocle)
     ;; NOTE 2022-03-02: Elsewhere I provide my `logos.el' package which
     ;; has the functionality of these three commands.
     ;;
     ;; (define-key map [remap narrow-to-region] #'prot-simple-narrow-dwim)
     ;; (define-key map [remap forward-page] #'prot-simple-forward-page-dwim)
     ;; (define-key map [remap backward-page] #'prot-simple-backward-page-dwim)
     ;;
     ;; Commands for buffers
     (define-key map (kbd "M-=") #'count-words)
     (define-key map (kbd "<C-f2>") #'prot-simple-rename-file-and-buffer)
     (define-key map (kbd "C-x K") #'prot-simple-kill-buffer-current)
     (define-key map (kbd "M-s b") #'prot-simple-buffers-major-mode)
     (define-key map (kbd "M-s v") #'prot-simple-buffers-vc-root)))
)



#+end_src
*** Hydra
keychords with hydra
#+begin_src emacs-lisp :noweb-ref hydra
(use-package hydra
  :config
  (progn
    ;; (setq hydra-lv nil)
    (set-face-attribute 'hydra-face-red      nil :foreground "Red"        :bold t)
    (set-face-attribute 'hydra-face-blue     nil :foreground "RoyalBlue3" :bold t)
    (set-face-attribute 'hydra-face-amaranth nil :foreground "#e52b50"    :bold t)
    (set-face-attribute 'hydra-face-pink     nil :foreground "HotPink1"   :bold t)
    (set-face-attribute 'hydra-face-teal     nil :foreground "#367588"    :bold t)
    (hydra-add-font-lock)))

;; https://github.com/abo-abo/hydra/wiki/Hydra-Colors#colorful-hydras
;; https://github.com/abo-abo/hydra/wiki/internals#exit
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | Body     | Non-color                   | Head      | Executing             | After     |
;; | Color    | Alternative                 | Inherited | NON-HEADS             | executing |
;; |          |                             | Color     |                       | HEADS     |
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | red      | :foreign-keys nil (default) | red       | Allow and Quit        |           |
;; |          | :exit nil (default)         |           |                       | Continue  |
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | blue     | :foreign-keys nil (default) | blue      | Allow and Quit        |           |
;; |          | :exit t                     |           |                       | Quit      |
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | amaranth | :foreign-keys warn          | red       | Disallow and Continue |           |
;; |          | :exit nil (default)         |           |                       | Continue  |
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | teal     | :foreign-keys warn          | blue      | Disallow and Continue |           |
;; |          | :exit t                     |           |                       | Quit      |
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | pink     | :foreign-keys run           | red       | Allow and Continue    |           |
;; |          | :exit nil (default)         |           |                       | Continue  |

#+end_src
*** Mac command bindings /mac-keys/
Change the Mac modifiers to my liking. I also disable passing Control characters to the system, to avoid that C-M-space launches the Character viewer instead of running mark-sexp.

#+begin_src emacs-lisp :noweb-ref mac-keys
(cond ((eq system-type 'darwin)
       (setq  mac-command-modifier        'super
              mac-option-modifier         'meta
              mac-right-option-modifier   'alt
              mac-pass-control-to-system   nil)))

#+end_src
***  tangle Keyboard
:properties:
:header-args: :tangle lisp/init-kbd.el :noweb yes
:end:
Setup keyboard


#+begin_src emacs-lisp
;;; init-kbd.el --- Setup Keyboard -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(require 'init-elpa)
(require 'init-env)

<<mac-keys>>

<<emacs-bindings>>

<<hydra>>

(provide 'init-kbd)
;;; init-kbd.el ends here
#+end_src
* Note Taking
In its purest form, Org is a markup language that is similar to Markdown: symbols are used to denote the meaning of a construct in its context, such as what may represent a headline element or a phrase that calls for emphasis.
What lends Org its super powers though is everything else built around it: a rich corpus of Elisp functions that automate, link, combine, enhance, structure, or otherwise enrich the process of using this rather straightforward system of plain text notation.
Couched in those terms, Org is at once a distribution of well integrated libraries and a vibrant ecosystem that keeps producing new ideas and workflows on how to organise one’s life with plain text.c

** Org mode Use-package Defaults
Org mode defaults for consistency
#+begin_src emacs-lisp :noweb-ref org-defaults
(use-package ob-restclient)

(use-package ob-plantuml
  :straight nil
  :defer t
  :defines (org-plantuml-jar-path)
  :config
  (setq org-plantuml-jar-path
        (expand-file-name "~/.local/bin/plantuml.jar")))


 

  (use-package org
    :straight (:type built-in)
    :diminish t
    :preface
    ;; Set my default org-export backends. This variable needs to be set before
    ;; org.el is loaded.
    (setq org-export-backends '(ascii html latex md))
    ;; Do not open links of mouse left clicks.
    ;; Default behavior caused inline images in Org buffers to pop up in their
    ;; own buffers when left clicked on by mistake. I can still intentionally
    ;; open links and such images in new buffers by doing C-c C-o.
    (setq org-mouse-1-follows-link nil)
    :bind (("C-c c" . org-capture)
           ("C-c a" . org-agenda)
           ("<f7> s" . org-store-link)
           :map org-src-mode-map
           ("C-x w" . org-edit-src-exit)
           ("C-x C-s" . org-edit-src-exit))
    :mode ("\\.org\\'" . org-mode)
    :hook ((org-mode . gas/org-setup))
    :hook  ((org-capture-mode org-src-mode) . discard-history)
    :commands (org-check-agenda-file
               org-link-set-parameters)
    :custom-face
    (org-block ((t (:extend t))))
    (org-block-begin-line ((t ( :slant unspecified
                                :weight normal
                                :background unspecified
                                :inherit org-block
                                :extend t))))
    (org-block-end-line ((t ( :slant unspecified
                              :weight normal
                              :background unspecified
                              :inherit org-block-begin-line
                              :extend t))))
    ;;(org-drawer ((t (:foreground nil :inherit shadow))))
    :custom
    (org-ellipsis "…")
    :init
    ;; This is where my ~heart~ org files are.
    (setq org-directory
          (if IS_TERMUX?
              "~/storage/shared/org"
            "~/org"))
    :config
    (require 'org-protocol)
      ;;;; general settings
    (setq org-adapt-indentation nil)      ; No, non, nein, όχι!
    ;; Prevent auto insertion of blank lines before headings and list items
    (setq org-blank-before-new-entry '((heading)
                                       (plain-list-item)))
    ;; http://emacs.stackexchange.com/a/17513/115, values: nil, t, 'reverse
    (setq org-special-ctrl-a/e nil)
    (setq org-special-ctrl-k nil)
    (setq org-M-RET-may-split-line '((default . nil)))
    ;; Single key command execution when at beginning of a headline
    (setq org-use-speed-commands t)     ;? speed-key opens Speed Keys help
    (setq org-speed-commands-user '(("m" . org-mark-subtree)))
    (setq org-hide-emphasis-markers nil)  ;; so dont see text markers aka bold italic
    (setq org-hide-macro-markers nil)
    (setq org-hide-leading-stars nil)
    (setq org-cycle-separator-lines 0)
    (setq org-structure-template-alist    ; CHANGED in Org 9.3, Emacs 27.1
          '(("s" . "src")
            ("b" . "src bash")
            ("E" . "src emacs-lisp")
            ("e" . "example")
            ("q" . "quote")
            ("v" . "verse")
            ("V" . "verbatim")
            ("c" . "src clojure")
            ("C" . "comment")))
    (setq org-catch-invisible-edits 'smart) ;; try not to accidently do wierd stuff in invisible regions : show smart, error
    (setq org-return-follows-link t)
    (setq org-loop-over-headlines-in-active-region 'start-level)
    ;; Setup list of Org modules that should always be loaded together
    ;; with Org.
    (setq org-modules '(org-id org-attach ol-info))
    ;; Allow _ and ^ characters to sub/super-script strings but only when
    ;; string is wrapped in braces
    (setq org-use-sub-superscripts '{}) ; In-buffer rendering
    (setq org-pretty-entities t)        ; special symbols, latex
    ;; Render subscripts and superscripts in Org buffers
    (setq org-pretty-entities-include-sub-superscripts t)
    (setq org-insert-heading-respect-content t)

    ;; code blocks
    (setq org-hide-block-startup nil)
    (setq org-fontify-quote-and-verse-blocks t
          org-fontify-whole-heading-line t)
    (setq org-confirm-babel-evaluate nil)
    (setq org-src-window-setup 'current-window)
    (setq org-edit-src-persistent-message nil)
    (setq org-src-fontify-natively t) ;; Display entities like \tilde, \alpha, etc in UTF-8 characters
    (setq org-src-preserve-indentation t)
    (setq org-src-tab-acts-natively t) ;; TAB as if code tab settings
    (setq org-edit-src-content-indentation 0) ;; remove 2 space indent in src code blocks
    (setq org-use-property-inheritance t) ;; for tangling

    ;; images
    (setq org-startup-with-inline-images t)
    (setq org-image-actual-width '(300))

    ;; export
    (setq org-export-with-toc t)
    (setq org-export-headline-levels 8)
    (setq org-export-in-background t)     ; run export processes in external emacs process
    (setq org-export-with-section-numbers nil)
    (setq org-export-with-smart-quotes t)
    (setq org-export-with-sub-superscripts '{}) ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
    (setq org-export-dispatch-use-expert-ui nil)
    (setq org-html-coding-system 'utf-8-unix)
    (setq org-html-todo-kwd-class-prefix "keyword ")
    (setq org-html-htmlize-output-type nil)
    (setq org-html-head-include-default-style nil)
    (setq org-html-head-include-scripts nil)
    (require 'ox-texinfo)
    (require 'ox-md)

    ;; fold / overview  - collapse everything, show only level 1 headlines
    ;; content          - show only headlines
    ;; nofold / showall - expand all headlines except the ones with :archive:
    ;;                    tag and property drawers
    ;; showeverything   - same as above but without exceptions
    (setq org-startup-folded 'content)

    ;; https://orgmode.org/manual/Clean-view.html
    (setq org-startup-indented t)       ;;; removed leading * for nicer view
    (with-eval-after-load 'org-indent
      (setq org-indent-indentation-per-level 1)) ;Default = 2

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (clojure . t)
       (shell . t)
       (R . t)
       (lisp . t)
       (sqlite . t)
       (python . t)
       (plantuml . t)
       (latex . t)
       (restclient . t)
       ))
    ;; change CAPITAL Keywords to lowercase
    (defun org-syntax-convert-keyword-case-to-lower ()
      "Convert all #+KEYWORDS to #+keywords."
      (interactive)
      (save-excursion t
                      (goto-char (point-min))
                      (let ((count 0)
                            (case-fold-search nil))
                        (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
                          (unless (s-matches-p "RESULTS" (match-string 0))
                            (replace-match (downcase (match-string 0)) t)
                            (setq count (1+ count))))
                        (message "Remplacement de %d occurrences" count))))
    (defun discard-history ()
      "Discard undo history of org src and capture blocks."
      (setq buffer-undo-list nil)
      (set-buffer-modified-p nil))
    (define-advice org-return (:around (f &rest args))
      (let ((org-src-preserve-indentation t))
        (apply f args)))
    (define-advice org-cycle (:around (f &rest args))
      (let ((org-src-preserve-indentation t))
        (apply f args)))
    (defun org-babel-edit-prep:emacs-lisp (_)
      "Setup Emacs Lisp buffer for Org Babel."
      (setq lexical-binding t)
      (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
    ;; open directory links in `dired'
    ;;(add-to-list 'org-file-apps '(directory . emacs))

    ;; open files in the same window
    (add-to-list 'org-link-frame-setup '(file . find-file))
    (setq org-indirect-buffer-display 'current-window)

    (defun gas/org-setup ()
      ;;  (org-indent-mode)       ;; turn on org indent
      (variable-pitch-mode 1) ;; turn on variable-pitch
      (auto-fill-mode +1)      ;; turn on auto-fill
      (visual-line-mode 1)    ;; turn on visual-line-mode
      ;; (show-paren-mode 1)     ;; show parentheses
      (hl-line-mode +1)
      (auto-fill-mode +1)
      (whitespace-mode -1)
      (electric-indent-local-mode -1)
      (setq-local cursor-type 'bar)
      (setq-local delete-trailing-lines t)
      (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)
      ))

#+end_src

** Org agenda
#+begin_src elisp :noweb-ref org-agenda
(use-package org-agenda
  :straight nil
  :defer t
  :config      ;; formatting for properties
  (setq org-property-format "%-24s %s")
  ;; setup todo keywords
  (setq
   org-todo-keywords
   '((sequence "TODO(t)" "EN_COURS(n)" "|" "FINI(d!)")
     (sequence "ATTENDRE(w@/!)"
           "ENATTENTE(h@/!)"
           "|"
           "ANNULÉ(c@/!)"
           "RÉUNION(m)")))
  (setq org-todo-keyword-faces
    '(("TODO"     . org-todo)
      ("ENATTENTE"  . (:foreground "black" :background "#FFEF9F"))
      ("ANNULÉ" . (:foreground "#94BFF3" :weight bold :strike-through t))
      ("FINI"     . (:foreground "black" :background "#91ba31"))
      ("RÉUNION" . '(bold org-todo))
      ("ATTENDRE" . '(bold shadow))))
  (setq org-use-fast-todo-selection 'expert)
  (setq org-priority-faces
    '((?A . '(bold org-priority))
      (?B . org-priority)
      (?C . '(shadow org-priority))))
  (setq org-fontify-done-headline nil)
  (setq org-fontify-todo-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-heading-line nil)
  (setq org-fontify-whole-block-delimiter-line nil)
  (setq org-highlight-latex-and-related nil) ; other options affect elisp regexp in src blocks
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-track-ordered-property-with-tag t)
  (setq org-highest-priority ?A)
  (setq org-lowest-priority ?C)
  (setq org-default-priority ?A)

  (setq org-todo-keywords
    '((sequence
       "TODO(t)"  ; A task that needs doing & is ready to do
       ;;  "PROJ(p)"  ; A project, which usually contains other tasks
       "EN_COURS(s)"  ; A task that is in progress
       "ATTE(w)"  ; Something external is holding up this task
       "SUSP(h)"  ; This task is paused/on hold because of me
       "|"
       "FINI(d)"  ; Task successfully completed
       "KILL(k)") ; Task was cancelled, aborted or is no longer applicable
      (sequence
       "[ ](T)"   ; A task that needs doing
       "[-](S)"   ; Task is in progress
       "[?](W)"   ; Task is being held up or paused
       "|"
       "[X](D)")  ; Task was completed
      (sequence
       "|"
       "OKAY(o)"
       "YES(y)"
       "NO(n)"))
    org-todo-keyword-faces
    '(("[ ]"   . org-todo-keyword-todo)
      ("SUIV" .  org-todo-keyword-next)
      ("[-]"  .  org-todo-keyword-next)
      ("[?]"  .  org-todo-keyword-wait)
      ("ATTE" .  org-todo-keyword-wait)
      ("SUSP" .  org-todo-keyword-wait)
      ("PROJ" .  org-todo-keyword-proj)
      ("KILL" .  org-todo-keyword-kill)
      ("FINI" .  org-todo-keyword-done)
      ("[X]"  .  org-todo-keyword-done)
      ))

  (setq org-agenda-custom-commands
    (quote
     (("n" "Prochaines Tâches"
       ((agenda "" ((org-deadline-warning-days 7)))
        (todo "SUIV"
          ((org-agenda-overriding-header "Prochaines Tâches")))))

      ;; Low-effort next actions
      ("l" tags-todo "+TODO=\"EN_COURS\"+Effort<15&+Effort>0"
       ((org-agenda-overriding-header "Tâches à faible Effort")
        (org-agenda-max-todos 20)
        (org-agenda-files org-agenda-files)))
      ("h" "Habitudes" tags-todo "STYLE=\"habit\""
       ((org-agenda-overriding-header "Habitudes")
        (org-agenda-sorting-strategy
         '(todo-state-down priority-down category-keep))))
      ("e" "Eisenhower Matrix"
       ((agenda
         ""
         ((org-agenda-overriding-header "Calendrier Eisenhower:")
          (org-agenda-show-log t)
          (org-agenda-log-mode-items '(clock state))
          (org-agenda-category-filter-preset '("-Habitudes"))
          (org-agenda-span 5)
          (org-agenda-start-on-weekday t)
          ;;            (org-agenda-ndays 5)
          ;;            (org-agenda-start-day "-2d")
          (org-deadline-warning-days 30)))
        (tags-todo
         "+important+urgent/!FINI"
         ((org-agenda-overriding-header "Tâches importantes et urgentes")
          (org-tags-match-list-sublevels nil)))
        (tags-todo  "+important-urgent"
            ((org-agenda-overriding-header "Tâches importantes mais non urgentes")
             (org-tags-match-list-sublevels nil)))
        (tags-todo "-important+urgent"
               ((org-agenda-overriding-header "Tâches urgentes mais sans importance")
            (org-tags-match-list-sublevels nil)))
        (tags-todo "-important-urgent/!TODO"
               ((org-agenda-overriding-header "Tâches non importantes ni urgentes")
            (org-agenda-category-filter-preset '("-Habitudes"))
            (org-tags-match-list-sublevels nil)))
        (tags-todo "values"
               ((org-agenda-overriding-header "Valeurs")
            (org-tags-match-list-sublevels nil)))
        ))
      (" " "Agenda"
       ((agenda ""
            ((org-agenda-overriding-header "Calendrier d'aujourd'hui:")
             (org-agenda-show-log t)
             (org-agenda-log-mode-items '(clock state))
             ;; (org-agenda-files '(,(add-path-to-org/ "inbox.org")))
             (org-agenda-text-search-extra-files nil)
             ;;   (org-agenda-span 'day)
             ;;   (org-agenda-ndays 3)
             (org-agenda-start-on-weekday nil)
             (org-agenda-start-day "-d")
             (org-agenda-todo-ignore-deadlines nil)))
        (tags-todo "+important"
               ((org-agenda-overriding-header "Tâches Importantes à Venir")
            (org-tags-match-list-sublevels nil)))
        (tags-todo "-important/TODO"
               ((org-agenda-overriding-header "Tâches de Travail")
            (org-agenda-category-filter-preset '("-Habitudes"))
            (org-agenda-sorting-strategy
             '(todo-state-down priority-down))))
        (tags-todo "-important-urgent/TODO"
               ((org-agenda-overriding-header "Habitudes")
            (org-agenda-sorting-strategy
             '(todo-state-down priority-down))))
        (tags "FINI"
          ((org-agenda-overriding-header "Tâches à la Représenter")
           (org-tags-match-list-sublevels nil)))))
      ))))

#+end_src
*** Org clock
#+begin_src emacs-lisp
(use-package org-clock
  :straight nil
  :defer t
  :commands (org-clock-save)
  :init
  (setq
   org-clock-persist-file (expand-file-name "org-clock-save.el" EMACS_ETC/ )
   ;; remove clocked tasks with 0:00 duration
   org-clock-out-remove-zero-time-clocks t
   org-clock-persist 'history
   ;; Resume when clocking into task with open clock
   org-clock-in-resume t)
  :config
  (add-hook 'kill-emacs-hook #'org-clock-save))


#+end_src
*** Org refile
#+begin_src emacs-lisp
(use-package org-refile
  :straight nil
  :defer t
  :init
       ;;;; refile, todo
  (setq org-refile-targets
    '((org-agenda-files . (:maxlevel . 2))
      (nil . (:maxlevel . 2))))
  (setq org-refile-use-outline-path t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache t)
  (setq org-reverse-note-order nil)
  (setq org-outline-path-complete-in-steps nil)
  ;;	(setq org-refile-target-verify-function #'vulpea-refile-verify-target)
  )


#+end_src
*** Org Archive
#+begin_src emacs-lisp
(use-package org-archive
  :straight nil
  :defer t
  :init
  (setq-default
   org-archive-location
   (concat org-directory ".archive/%s_archive" "::" "datetree/*")
   org-archive-save-context-info
   '(time file ltags itags todo category olpath)))


#+end_src
*** Org ID
#+begin_src emacs-lisp
(use-package org-id
  :straight nil
  :defer t
  :hook ( ;;(before-save . vulpea-id-auto-assign)
         (org-capture-prepare-finalize . org-id-get-create))
  :init
  (setq org-id-uuid-program
        "uuidgen | tr \"[:upper:]\" \"[:lower:]\"")
  :config
  ;;(org-link-set-parameters
  ;; "id" :activate-func #'vulpea-activate-link)
  (setq
   org-id-track-globally t
   org-id-extra-files
   (list (expand-file-name ".archive/archive" org-directory)
         (expand-file-name ".archive/archive.org" org-directory))
   org-id-link-to-org-use-id t
   org-id-locations-file (expand-file-name "org-id-locations" XDG_CACHE/ )))


#+end_src
*** Org attach
#+begin_src emacs-lisp
(use-package org-attach
  :straight nil
  :defer t
  :config
  (setq-default
   org-attach-id-dir (expand-file-name ".data/" org-directory)
   org-attach-auto-tag nil
   org-attach-file-list-property nil
   org-attach-store-link-p 'attached))
#+end_src

** Org Setup /org-setup/
use Setup to setup Org Mode

#+begin_src emacs-lisp :noweb-ref org-setup
;;; org-setup.el --- Orgmode Setup  -*- lexical-binding: t -*-
;; setup of org-mode keybindings
(setup (:pkg org)
       (:also-load org-tempo)
       (:hook gas/org-mode-setup)
       (:global "C-c a"  org-agenda
                "C-c c"  org-capture
                "C-c l"  org-store-link)
       (:bind   "C-'"  nil
                "C-,"  nil
                "<C-return>"    nil
                "<C-S-return>"  nil
                "C-M-S-<right>" nil
                "C-M-S-<left>"  nil
                "C-c S-l"       org-toggle-link-display
                "C-c C-S-l"     org-insert-last-stored-link)

       (push '("conf-unix" . conf-unix) org-src-lang-modes)
       (:load-after hl-fill-column
                    (:hook gas/org-mode-setup)))

(setup (:require org-indent)
       (:load-after org
                    (setq evil-auto-indent nil)
                    (org-indent-mode 1)
                    (:hide-mode)))

(setup (:pkg org-appear)
       (:load-after org
                    (:option org-appear-autoemphasis t
                             org-appear-autoentities t
                             org-appear-autokeywords t
                             org-appear-autolinks nil
                             org-appear-autosubmarkers t
                             org-appear-delay 0)
                    (:hook-into org-mode)))

(setup org-faces
       (:load-after org-indent
                    (dolist (face-cons '((org-document-title . 1.75)
                                         (org-level-1 . 1.5)
                                         (org-level-2 . 1.25)
                                         (org-level-3 . 1.12)
                                         (org-level-4 . 1.05)
                                         (org-level-5 . 1.0)
                                         (org-level-6 . 1.0)
                                         (org-level-7 . 1.0)
                                         (org-level-8 . 1.0)))
                      (cl-destructuring-bind (face . height) face-cons
                        (set-face-attribute face
                                            nil
                                            :weight 'bold
                                            :font "Iosevka Aile"
                                            :height height))))

       ;; Ensure that anything that should be fixed-pitch in Org files appears that way
       (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
       (set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
       (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
       (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
       (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
       (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
       (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
       (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
       (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

       ;; Get rid of the background on column views
       (set-face-attribute 'org-column nil :background nil)
       (set-face-attribute 'org-column-title nil :background nil))

#+end_src

** Org Vulpea Agenda /agenda-vulpea/
org-capture provides a generic and extensible interface to capturing things into org-mode in
different formats
#+begin_src emacs-lisp :noweb-ref agenda-vulpea
(use-package org-agenda
  :straight nil
  :defer t
  :general
  (leader-def
   "oA" '(org-agenda :which-key "agenda dispatch")
   "oa" '(vulpea-agenda-main :which-key "agenda")
   "op" '(vulpea-agenda-person :which-key "person"))
  :config
  (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
  (setq org-log-done 'time) ;Insert only timestamp when closing an Org TODO item
  ;; (setq org-log-done 'note) ;Insert timestamp and note when closing an Org TODO item
  ;; https://orgmode.org/manual/Closing-items.html

  ;; use drawer for state changes
  (setq org-log-into-drawer t)

  ;; Block entries from changing state to DONE while they have children
  ;; that are not DONE - https://orgmode.org/manual/TODO-dependencies.html
  (setq org-enforce-todo-dependencies t)

  ;; use fast todo selection
  (setq org-use-fast-todo-selection t)

  ;; allow to fast fix todo state without triggering anything
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)

  ;; setup state triggers
  (setq org-todo-state-tags-triggers
        '(("ANNULÉ" ("ANNULÉ" . t))
          ("ATTENDRE" ("ATTENDRE" . t))
          ("ENATTENTE" ("ATTENDRE") ("ENATTENTE" . t))
          (done ("ATTENDRE") ("ENATTENTE") ("FOCUS"))
          ("TODO" ("ATTENDRE") ("ANNULÉ") ("ENATTENTE"))
          ("FINI" ("ATTENDRE") ("ANNULÉ") ("ENATTENTE"))))

  ;; tags
  (setq
   org-tag-persistent-alist '(("FOCUS" . ?f)
                              ("PROJET" . ?p))
   org-use-tag-inheritance t
   org-tags-exclude-from-inheritance '("projet"
                                       "litnotes"
                                       "people"))
  (setq
   org-agenda-dim-blocked-tasks nil
   ;; setting it to t speeds up agenda, but... initial visibility is
   ;; not honored, which for me is a bigger issue
   org-agenda-inhibit-startup nil

   ;; also show state change in log mode
   org-agenda-log-mode-items '(closed clock state)

   ;; tags
   org-agenda-show-inherited-tags nil

   ;; priorities
   org-fancy-priorities-list '("⚡" "⬆" "⬇" "☕")

   org-priority-faces
   `((?A . ,(face-foreground 'error))
     (?B . ,(face-foreground 'warning))
     (?C . ,(face-foreground 'success)))

   ;; more structured view
   org-agenda-prefix-format
   '((agenda . " %(vulpea-agenda-category 24) %?-12t %12s")
     (todo . " %(vulpea-agenda-category 24) ")
     (tags . " %(vulpea-agenda-category 24) ")
     (search . " %(vulpea-agenda-category 24) "))
   org-agenda-todo-keyword-format "%-1s"
   org-agenda-tags-column 0

   ;; show agenda in current window
   org-agenda-window-setup 'current-window

   org-agenda-custom-commands
   `((" " "Agenda"
      (,vulpea-agenda-cmd-refile
       ,vulpea-agenda-cmd-today
       ,vulpea-agenda-cmd-focus
       ,vulpea-agenda-eisen-imp-y-urg
       ,vulpea-agenda-cmd-projects
       ,vulpea-agenda-cmd-waiting)
      ((org-agenda-buffer-name vulpea-agenda-main-buffer-name)))
     ("e" "Matrice d'Eisenhower:"
      (,vulpea-agenda-cmd-eisen
       ,vulpea-agenda-eisen-imp-y-urg
       ,vulpea-agenda-eisen-imp
       ,vulpea-agenda-eisen-urg
       ,vulpea-agenda-eisen-alltodos)
      ((org-agenda-buffer-name vulpea-agenda-main-buffer-name)))))
  ;;tag-alist
  (setq-default
   org-tag-alist
   (quote (("@errand"     . ?e)
           ("@bureau"    . ?o)
           ("@maison"    . ?h)
           ("important"  . ?i)
           ("urgent"     . ?u)

           (:newline)
           ("ATTENDRE"  . ?w)
           ("SUSPENDUÉ" . ?h)
           ("ANNULÉ"    . ?c)
           ("RÉUNION"   . ?m)
           ("TÉLÉPHONE" . ?p)
           ("french"    . ?f)
           ("spanish"   . ?s))))
  ;;(with-no-warnings
  (setq org-ts-regexp-both-braket "\\([[<]\\)\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} ?[^]\n>]*?\\)\\([]>]\\)")
  ;; (defface org-deadline-custom-braket '((t (:inherit 'default))) "org-deadline" :group 'org)
  ;; (defface org-scheduled-custom-braket '((t (:inherit 'default))) "org-schedule" :group 'org)
  ;; (defface org-priority-hide '((t ())) "org-priority-hide" :group 'org)
  ;; (defface org-scheduled-custom '((t (:inherit 'default))) "org-schedule" :group 'org)
  ;; (defface org-closed-custom '((t (:inherit 'default))) "org-close" :group 'org)
  ;; (defface org-todo-keyword-done '((t ())) "org-done" :group 'org)
  ;; (defface org-todo-keyword-next '((t ())) "org-next" :group 'org)
  ;; (defface org-todo-keyword-proj '((t ())) "org-proj" :group 'org)
  ;; (defface org-todo-keyword-wait '((t ())) "org-wait" :group 'org)
  ;; (defface org-todo-keyword-todo '((t ())) "org-todo" :group 'org)
  ;; (defface org-todo-keyword-kill '((t ())) "org-kill" :group 'org)
  ;; ;;)
  ;; (with-no-warnings
  ;;   (custom-declare-face 'org-todo-keyword-next  '((t (:inherit (bold font-lock-constant-face org-todo)))) "")
  ;;   (custom-declare-face 'org-todo-keyword-proj '((t (:inherit (bold font-lock-doc-face org-todo)))) "")
  ;;   (custom-declare-face 'org-todo-keyword-wait  '((t (:inherit (bold warning org-todo)))) "")
  ;;   (custom-declare-face 'org-todo-keyword-kill  '((t (:inherit (bold error org-todo)))) ""))
  )


#+end_src

** Latex OX (Presentation) /org-latex/
Setup of latex
#+begin_src emacs-lisp :noweb-ref org-latex
(use-package ox-latex
  :straight nil
  :after org
  :config
  (setq org-latex-compiler "xelatex") ;introduced in Org 9.0

  (setq org-latex-prefer-user-labels t) ;org-mode version 8.3+

  ;; Previewing latex fragments in Org mode
  ;; https://orgmode.org/worg/org-tutorials/org-latex-preview.html
  ;; (setq org-latex-create-formula-image-program 'dvipng) ;NOT Recommended
  (setq org-latex-create-formula-image-program 'imagemagick) ;Recommended

  (setq org-highlight-latex-and-related '(latex script))

  (add-to-list 'org-latex-packages-alist '("newfloat" "minted"))
  ;;(add-to-list 'org-latex-packages-alist '("" "color"))
  (setq org-preview-latex-image-directory
        (expand-file-name "ltximg/" XDG_CACHE/))
  (setq org-format-latex-options
        (list :foreground 'auto
              :background 'auto
              :scale 1.5
              :html-foreground "Black"
              :html-background "Transparent"
              :html-scale 1.0
              :matchers '("begin" "$1" "$" "$$" "\\(" "\\[")))
  (setq org-latex-listings 'minted)
  (setq org-preview-latex-default-process 'dvisvgm)
  (setq org-latex-pdf-process
        (seq-map
         (lambda (_)
           (string-join '("pdflatex"
                          "-shell-escape"
                          "-interaction nonstopmode"
                          "-output-directory %o %f")
                        " "))
         '(1 2 3))))


(use-package ox-beamer
  :straight nil
  :defer t
  :config
  (add-to-list
   'org-beamer-environments-extra
   '("onlyenv" "O" "\\begin{onlyenv}%a" "\\end{onlyenv}")))


#+end_src

** Org TOC /org-toc/
#+begin_src emacs-lisp :noweb-ref org-toc
(use-package toc-org
  :hook (org-mode . toc-org-mode))


#+end_src
* Templates & YAS
These templates enable you to type things like =<el= and then hit =Tab= to expand
the template.  More documentation can be found at the Org Mode [[https://orgmode.org/manual/Easy-templates.html][Easy Templates]]
documentation page.

#+begin_src emacs-lisp :noweb-ref templates
;; This is needed as of Org 9.2
;; (with-eval-after-load 'org
;;   (use-package org-tempo
;;     :straight nil
;;     :unless (version<= org-version "9.1.9")
;;     :after org
;;     :config
;;     (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
;;     (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
;;     (add-to-list 'org-structure-template-alist '("li" . "src lisp"))
;;     (add-to-list 'org-structure-template-alist '("cli" . "src common-lisp"))
;;     (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
;;     (add-to-list 'org-structure-template-alist '("cl" . "src clojure"))
;;     (add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
;;     (add-to-list 'org-structure-template-alist '("py" . "src python"))
;;     (add-to-list 'org-structure-template-alist '("go" . "src go"))
;;     (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
;;     (add-to-list 'org-structure-template-alist '("json" . "src json"))))

(defvar file-templates-dir
  (expand-file-name "templates/" EMACS_CONFIG/ )
  "The path to yasnippet folders.")

(defvar file-templates-default-trigger "__"
  "The default yasnippet trigger key (a string).
Used for file template rules that don't have a :trigger property
in `file-templates-alist'.")

(defvar file-templates-alist
  `(
    ;; elisp
    ("dir-locals.el$"
     :ignore t)
    ("settings.el$"
     :ignore t)
    (emacs-lisp-mode
     :trigger "__package")
    (snippet-mode))
  "An alist of file template rules.
The CAR of each rule is either a major mode symbol or regexp
string.
The CDR is a plist. See `file-templates-set' for more
information.")

(use-package yasnippet
  :diminish yas-minor-mode
  :commands (yas-minor-mode-on
             yas-expand
             yas-expand-snippet
             yas-lookup-snippet
             yas-insert-snippet
             yas-new-snippet
             yas-visit-snippet-file
             yas-reload-all
             yas-dropdown-prompt
             yas--all-templates
             yas--get-snippet-tables
             yas--template-key)
  :hook ((text-mode . yas-minor-mode-on)
         (prog-mode . yas-minor-mode-on)
         (conf-mode . yas-minor-mode-on)
         (snippet-mode . yas-minor-mode-on))
  :init
  (add-hook 'find-file-hook #'file-templates-check)
  :config
  (setq yas-prompt-functions (delq #'yas-dropdown-prompt
                                   yas-prompt-functions)
        yas-snippet-dirs '(file-templates-dir))
  ;; Ensure file templates in `file-templates-dir' are visible
  (yas-reload-all))

(defun file-templates-check ()
  "Check the current buffer for file template expansion.
Returns non-nil when current buffer is a candidate for file
template expansion.
The buffer must be non-read-only, empty, and there must be a rule
in `file-templates-alist' that applies to it."
  (when (and (not buffer-read-only)
             (bobp) (eobp)
             (not (string-match-p "^ *\\*" (buffer-name))))
    (let ((rule (cl-find-if #'file-templates-p
                            file-templates-alist)))
      (when rule (apply #'file-templates--expand rule)))))

(defun file-templates--set (pred plist)
  "Register a file template.
Refer to `file-templates-set' documentation on the meaning of
PRED and PLIST."
  (if (null (car-safe plist))
      (setq file-templates-alist
            (delq (assoc pred file-templates-alist)
                  file-templates-alist))
    (push `(,pred ,@plist) file-templates-alist)))

(defun file-templates-set (pred &rest plist)
  "Register a file template.
PRED can either be a regexp string or a major mode symbol.
PLIST may contain these properties:
  :when FUNCTION
    Provides a secondary predicate. This function takes no
    arguments and is executed from within the target buffer. If
    it returns nil, this rule will be skipped over.
  :trigger STRING|FUNCTION
    If a string, this is the yasnippet trigger keyword used to
    trigger the target snippet.
    If a function, this function will be run in the context of
    the buffer to insert a file template into. It is given no
    arguments and must insert text into the current buffer
    manually.
    If omitted, `file-templates-default-trigger' is used.
  :mode SYMBOL
    What mode to get the yasnippet snippet from. If omitted,
    either PRED (if it's a major-mode symbol) or the mode of the
    buffer is used.
  :project BOOL
    If non-nil, ignore this template if this buffer isn't in a
    project.
  :ignore BOOL
    If non-nil, don't expand any template for this file and don't
    test any other file template rule against this buffer.
\(fn PRED &key WHEN TRIGGER MODE PROJECT IGNORE)"
  (declare (indent defun))
  (file-templates--set pred plist))

(cl-defun file-templates--expand
    (pred &key project mode trigger ignore _when)
  "Auto insert a yasnippet snippet into current file.
See `file-templates-set' for information about PRED,
PROJECT, MODE, TRIGGER, IGNORE and _WHEN arguments."
  (when (and pred (not ignore))
    (when (if project (project-p) t)
      (unless mode
        (setq mode (if (symbolp pred) pred major-mode)))
      (unless mode
        (user-error "Couldn't determine mode for %s file template"
                    pred))
      (unless trigger
        (setq trigger file-templates-default-trigger))
      (if (functionp trigger)
          (funcall trigger)
        (require 'yasnippet)
        (unless yas-minor-mode
          (yas-minor-mode-on))
        (when yas-minor-mode
          (yas-expand-snippet
           (yas-lookup-snippet trigger mode)))))))

(defun file-templates-p (rule)
  "Return non-nil if the RULE apply to the current buffer."
  (let ((pred (car rule))
        (plist (cdr rule)))
    (and (cond
          ((and (stringp pred)
                buffer-file-name)
           (string-match-p pred buffer-file-name))
          ((symbolp pred)
           (eq major-mode pred)))
         (or (not (plist-member plist :when))
             (funcall (plist-get plist :when)
                      buffer-file-name))
         rule)))

(defun file-templates-debug ()
  "Output the file template rule for current buffer.
Test the current buffer and outputs the file template rule most
appropriate for it. This is used for testing."
  (interactive)
  (message
   "Found %s"
   (cl-find-if
    #'file-templates-p
    file-templates-alist)))

;;(use-package yasnippet-snippets)

#+end_src

* Coding Settings

I mostly use Clojure and Clojurescript, so they're setup inheriting from LISP setup
** Code IDE Setup
:PROPERTIES:
:header-args: :noweb-ref code-ide
:ID:       b33e2c0c-2928-4951-982d-f58ebac42a71
:END:
*** setup comint, C and indentation
#+begin_src emacs-lisp :noweb-ref code-c
(use-package cc-vars
  :straight nil
  :config
  (setq c-default-style '((java-mode . "java")
                          (awk-mode  . "awk")
                          (c++-mode  . "bsd")
                          (c-mode    . "bsd")
                          (other     . "k&r")))
  (setq-default c-basic-offset gas/indent-width)
  (add-to-list 'auto-mode-alist '("\\.inl\\'" . c++-mode)))

(use-package comint
  :straight nil
  :config
  (setq ansi-color-for-comint-mode t)
  (setq comint-buffer-maximum-size 4096)
  (setq comint-prompt-read-only t))

(unless IS_TERMUX?
  (use-package compile
    :straight nil
    :hook ('compilation-filter .  #'ansi-color-compilation-filter)
    :config
    (setq compilation-always-kill t
          compilation-ask-about-save nil
          compilation-scroll-output 'first-error)
    (defmacro compile-add-error-syntax (name regexp file line &optional col level)
      "Register new compilation error syntax.

          Add NAME symbol to `compilation-error-regexp-alist', and then add
          REGEXP FILE LINE and optional COL LEVEL info to
          `compilation-error-regexp-alist-alist'."
      (declare (indent 1))
      `(progn (add-to-list 'compilation-error-regexp-alist ',name)
              (add-to-list 'compilation-error-regexp-alist-alist
                           '(,name ,regexp ,file ,line ,col ,level))))
    (compile-add-error-syntax kaocha-tap
                              "^not ok.*(\\([^:]*\\):\\([0-9]*\\))$"
                              (1 "src/%s" "test/%s") 2)
    (compile-add-error-syntax kaocha-fail
                              ".*FAIL in.*(\\([^:]*\\):\\([0-9]*\\))$"
                              (1 "src/%s" "test/%s") 2)
    (compile-add-error-syntax clojure-reflection-warning
                              "^Reflection warning,[[:space:]]*\\([^:]+\\):\\([0-9]+\\):\\([0-9]+\\).*$"
                              (1 "src/%s" "test/%s") 2 3)
    (compile-add-error-syntax clojure-syntax-error
                              "^Syntax error macroexpanding at (\\([^:]+\\):\\([0-9]+\\):\\([0-9]+\\)).$"
                              (1 "src/%s" "test/%s") 2 3)
    (compile-add-error-syntax lua-stacktrace
                              "\\(?:^[[:space:]]+\\([^
          :]+\\):\\([[:digit:]]+\\):[[:space:]]+in.+$\\)"
                              1 2)
    (compile-add-error-syntax fennel-compile-error
                              "\\(?:^Compile error in[[:space:]]+\\([^:]+\\):\\([[:digit:]]+\\)$\\)"
                              1 2)))

#+end_src
*** setup subword, eldoc
Set basic subword mode and eldoc setting for prog-mode
#+begin_src emacs-lisp :noweb-ref code-ide
(use-package subword
  :diminish t
  :config
  (global-subword-mode 1))

(use-package eldoc
  :straight nil
  :hook prog-mode ;;(elisp-mode clojure-mode cider-repl-mode lisp-interactive-mode)
  :config
  (setq eldoc-echo-area-use-multiline-p nil)
  (setq eldoc-idle-delay 0.1)
  ;; :init
  ;; (add-hook 'prog-mode-hook #'turn-on-eldoc-mode)
  )

(use-package display-line-numbers
  :straight nil
  :hook (prog-mode . display-line-numbers-mode)
  :config
   ;; (setf display-line-numbers-type 'relative)
  (global-display-line-numbers-mode t)
  (setq-default display-line-numbers-width 3)
  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  shell-mode-hook
                  treemacs-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0)))))
#+end_src
** Parentheses
Configure the mode that highlights matching delimiters or parentheses. I consider this of utmost importance when working with languages such as elisp.

Summary of what these do:

- Activate the mode upon startup.
- Show the matching delimiter/parenthesis if on screen, else show nothing. It is possible to highlight the expression enclosed by the delimiters, by using either mixed or expression. The latter always highlights the entire balanced expression, while the former will only do so if the matching delimiter is off screen.
- show-paren-when-point-in-periphery lets you highlight parentheses even if the point is in their vicinity. This means the beginning or end of the line, with space in between. I used that for a long while and it server me well. Now that I have a better understanding of Elisp, I disable it.
- Do not highlight a match when the point is on the inside of the parenthesis.
#+begin_src emacs-lisp :noweb-ref code-paren
;;; Parentheses (show-paren-mode)
(use-package paren
  :straight nil
  :custom
  (set-face-attribute 'show-paren-match-expression nil :background "#363e4a")
  :config
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  ;;; Electric Pairs to auto-complete () [] {} "" etc. It works on regions.
  (electric-pair-mode)

  ;;(setq show-paren-context-when-offscreen 'child-frame) ; Emacs 29
  :init
  ;;; By default, there’s a small delay before showing a matching parenthesis. Set
  ;;; it to 0 to deactivate.
  (setq show-paren-delay 0)
  (add-hook 'after-init-hook #'show-paren-mode))

#+end_src
*** setup smartparens
Setup smartparens and rainbow delimiters
#+begin_src emacs-lisp :noweb-ref code-paren
(use-package elec-pair
  :straight nil
  :hook (prog-mode . electric-pair-local-mode))

;; dimm parenthesis
;; (setup (:pkg paren-face)
;;   (:hook-into emacs-lisp-mode
;;       ielm-mode sly-repl-mode
;;       lisp-mode
;;       lisp-interaction-mode
;;       clojure-mode))

;; C-c @ C-d or C-s hide or show blocks
;; (use-package hideshow
;;    :straight nil
;;  :config
;;    (defun +hs-cycle (&optional level)
;;    (interactive "p")
;;    (let (message-log-max
;;      (inhibit-message t))
;;  (if (= level 1)
;;      (pcase last-command
;;        ('+hs-cycle
;;         (hs-hide-level 1)
;;         (setq this-command 'hs-cycle-children))
;;        ('hs-cycle-children
;;         ;; TODO: Fix this case. `hs-show-block' needs to be
;;         ;; called twice to open all folds of the parent
;;         ;; block.
;;         (save-excursion (hs-show-block))
;;         (hs-show-block)
;;         (setq this-command 'hs-cycle-subtree))
;;        ('hs-cycle-subtree
;;         (hs-hide-block))
;;        (_
;;         (if (not (hs-already-hidden-p))
;;         (hs-hide-block)
;;       (hs-hide-level 1)
;;       (setq this-command 'hs-cycle-children))))
;;    (hs-hide-level level)
;;    (setq this-command 'hs-hide-level))))

;;  (defun +hs-global-cycle ()
;;    (interactive)
;;    (pcase last-command
;;  ('+hs-global-cycle
;;   (save-excursion (hs-show-all))
;;   (setq this-command 'hs-global-show))
;;  (_ (hs-hide-all))))
;;  (:with-mode hs-minor-mode
;;    (:hook-into prog-mode)
;;    (:bind "C-<tab>"   #'+hs-cycle
;;       "C-S-<tab>" #'+hs-global-cycle)))

(use-package rainbow-delimiters
  :diminish t
  :hook ((cider-repl-mode
          clojurex-mode
          clojurescript-mode
          clojurec-mode
          clojure-mode
          emacs-lisp-mode
          lisp-data-mode
          sly-mprepl-mode
          lisp-interaction-mode
          inferior-emacs-lisp-mode)
         . rainbow-delimiters-mode))

(use-package smartparens
  :diminish t
  :hook ((prog-mode . turn-on-smartparens-strict-mode)
         (web-mode . op/sp-web-mode)
         (LaTeX-mode . turn-on-smartparens-strict-mode)
         ;;(common-lisp-modes-mode . smartparens-strict-mode)
         (eval-expression-minibuffer-setup . minibuffer-enable-sp))
  :bind (:map smartparens-mode-map
              ("C-M-f" . sp-forward-sexp)
              ("C-M-b" . sp-backward-sexp)

              ("C-M-a" . sp-beginning-of-sexp)
              ("C-M-e" . sp-end-of-sexp)
              ("C-M-n" . sp-next-sexp)
              ("C-M-p" . sp-previous-sexp)

              ("C-(" . sp-forward-barf-sexp)
              ("C-)" . sp-forward-slurp-sexp)
              ("C-{" . sp-backward-barf-sexp)
              ("C-}" . sp-backward-slurp-sexp)

              ("C-k" . sp-kill-hybrid-sexp)

              ("C-," . sp-rewrap-sexp)

              :map emacs-lisp-mode-map
              (";" . sp-comment)

              :map lisp-mode-map
              (";" . sp-comment)

              :map clojure-mode-map
              (";" . sp-comment)

              ;; :map common-lisp-modes-mode-map
              ;; (";" . sp-comment)
              )
  :custom
  (sp-highlight-pair-overlay nil)
  (sp-highlight-wrap-overlay nil)
  (sp-highlight-wrap-tag-overlay nil)
  (sp-echo-match-when-invisible nil)
  :config
  (add-to-list 'sp-lisp-modes 'lisp-data-mode t)
  (require 'smartparens-config)
  (sp-use-paredit-bindings)
  ;; needs to be set manually, because :bind section runs before :config
  (define-key smartparens-mode-map (kbd "M-r") 'sp-rewrap-sexp)

  (sp-with-modes 'org-mode
    (sp-local-pair "=" "=" :wrap "C-="))

  (defun op/sp-web-mode ()
    (setq web-mode-enable-auto-pairing nil))

  (defun minibuffer-enable-sp ()
    "Enable `smartparens-strict-mode' during `eval-expression'."
    (setq-local comment-start ";")
    (sp-local-pair 'minibuffer-pairs "'" nil :actions nil)
    (sp-local-pair 'minibuffer-pairs "`" nil :actions nil)
    (sp-update-local-pairs 'minibuffer-pairs)
    (smartparens-strict-mode 1)))

;; We don't actually enable cleverparens, because most of their bindings we
;; don't want, we install our own bindings for specific sexp movements
(use-package evil-cleverparens
  :after (evil smartparens))

#+end_src
*** setup flycheck & flymake
#+begin_src emacs-lisp :noweb-ref code-fly
(use-package flymake
  :straight nil
  :custom
  (flymake-fringe-indicator-position 'right-fringe))

(use-package flycheck
  :defer 1
  :disabled t
  :custom
  (flycheck-indication-mode 'right-fringe)
  (flycheck-display-errors-delay 86400 "86400 seconds is 1 day")
  (flycheck-emacs-lisp-load-path 'inherit)
  :config
  (flycheck-define-error-level 'error
                               :severity 100
                               :compilation-level 2
                               :overlay-category 'flycheck-error-overlay
                               :fringe-bitmap flymake-error-bitmap
                               :fringe-face 'flycheck-fringe-error
                               :error-list-face 'flycheck-error-list-error)
  (flycheck-define-error-level 'warning
                               :severity 10
                               :compilation-level 1
                               :overlay-category 'flycheck-warning-overlay
                               :fringe-bitmap flymake-warning-bitmap
                               :fringe-face 'flycheck-fringe-warning
                               :error-list-face 'flycheck-error-list-warning)
  (flycheck-define-error-level 'info
                               :severity -10
                               :compilation-level 0
                               :overlay-category 'flycheck-info-overlay
                               :fringe-bitmap flymake-note-bitmap
                               :fringe-face 'flycheck-fringe-info
                               :error-list-face 'flycheck-error-list-info)
  (define-advice flycheck-mode-line-status-text (:override (&optional status))
    "Get a text describing STATUS for use in the mode line.
STATUS defaults to `flycheck-last-status-change' if omitted or
nil."
    (concat " " flycheck-mode-line-prefix ":"
            (pcase (or status flycheck-last-status-change)
              (`not-checked "-/-")
              (`no-checker "-")
              (`running "*/*")
              (`errored "!")
              (`finished
               (let-alist (flycheck-count-errors flycheck-current-errors)
                 (format "%s/%s" (or .error 0) (or .warning 0))))
              (`interrupted ".")
              (`suspicious "?"))))
  (define-advice flycheck-may-use-echo-area-p (:override ())
    nil)
  :commands (global-flycheck-mode)
  :init
  (setq-default
   flycheck-emacs-lisp-load-path 'inherit
   flycheck-check-syntax-automatically
   '(save idle-change mode-enabled)
   flycheck-global-modes '(not org-mode))
  :config
  (global-flycheck-mode +1))

;; See lisp/dash-functional.el for more information. Here we simply
;; make sure that our mock is loaded instead of upstream.
(eval-when-compile
  (let ((dir (expand-file-name "lisp" EMACS_CONFIG/ )))
    (delete dir load-path)
    (add-to-list 'load-path dir)))

#+end_src
*** Tangle Coding IDE Setup
:properties:
:header-args: :tangle lisp/init-ide.el :noweb yes
:end:
Setup of parens and basic coding setup - aka prog mode, also C setup
#+begin_src emacs-lisp
;;; init-ide.el --- Code IDE -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<code-ide>>

<<code-paren>>

<<code-fly>>

;;<<code-c>>

(provide 'init-ide)
;;; init-ide.el ends here
#+end_src

** LISP IDE
#+begin_src emacs-lisp :noweb-ref lisp-ide
(use-package common-lisp-modes
  :diminish
;;  :disabled t
  :straight nil
  :bind ( :map common-lisp-modes-mode-map
          ("M-q" . common-lisp-modes-indent-or-fill-sexp))
  :preface
  (define-minor-mode common-lisp-modes-mode
    "Mode for enabling all modes that are common for lisps.
For reference, this is not a common-lisp modes mode, but a common
lisp-modes mode.
\\<common-lisp-modes-mode-map>"
    :lighter " clmm"
    :keymap (make-sparse-keymap))
  (defun common-lisp-modes-indent-or-fill-sexp ()
    "Indent s-expression or fill string/comment."
    (interactive)
    (let ((ppss (syntax-ppss)))
      (if (or (nth 3 ppss)
              (nth 4 ppss))
          (fill-paragraph)
        (save-excursion
          (mark-sexp)
          (indent-region (point) (mark))))))
  (provide 'common-lisp-modes))

#+end_src
** Emacs Lisp

ielm setup
#+begin_src emacs-lisp :noweb-ref code-elisp
(setup (:require pulse)
       (defgroup +pulse nil
         "Extra customisations for `pulse'."
         :group 'pulse
         :prefix "+pulse-")

       (defcustom +pulse-location-commands '(scroll-up-command
                                             scroll-down-command
                                             recenter-top-bottom
                                             other-window
                                             switch-to-buffer
                                             redraw-frame)
         "Commands to pulse the current line after.
  Good for finding location."
         :type '(repeat function))

       (defcustom +pulse-location-function '+pulse-line-current-window
         "What function to call after `+pulse-location-commands'."
         :type 'function)

       ;; XXX: this doesn't work yet.  I only want to pulse the line in the
       ;; active window, so when I have the same buffer viewed in multiple
       ;; windows I can still see where my cursor is.  To see the issue, C-x
       ;; 2 then C-x o a few times.
       (defun +pulse-line-current-window (&rest _)
         "Pulse the current line, but only if this window is active."
         (pulse-momentary-highlight-one-line
          (window-point (selected-window))))

       (defun +pulse--advice-remove (symbol where function &optional props)
         "Remove advice SYMBOL from FUNCTION.
  This uses the same args as `advice-add' for easy toggling.
  WHERE and PROPS are discarded."
         (ignore where props)
         (advice-remove symbol function))

       (define-minor-mode +pulse-location-mode
         "After moving locations, pulse where we are."
         :global t
         :keymap nil
         (dolist (command +pulse-location-commands)
           (funcall
            (if +pulse-location-mode 'advice-add '+pulse--advice-remove)
            command :after +pulse-location-function)))
       (:option pulse-flag nil
                pulse-delay 0.5
                pulse-iterations 1)
       (dolist (command '(+ace-window-or-switch-buffer
                          pop-mark pop-globl-mark))
         (add-to-list '+pulse-location-commands command))
       (+ensure-after-init #'+pulse-location-mode))

(setup elisp-mode
       (defun +elisp-eval-region-or-buffer ()
         (interactive)
         (if (region-active-p)
             (eval-region (region-beginning) (region-end))
           (+eval-region@pulse (lambda (_ _) (eval-buffer)) (point-min) (point-max))))

       (defun +eval-region@pulse (advised beg end &rest args)
         "ADVICE to pulse an eval'd region."
         (apply advised beg end args)
         (pulse-momentary-highlight-region beg end))

       (:option eval-expression-print-length nil
                eval-expression-print-level nil)
       (:with-map (emacs-lisp-mode-map lisp-interaction-mode-map)
                  (:bind "C-c C-c" #'eval-defun
                         "C-c C-k" #'+elisp-eval-region-or-buffer
                         "C-c C-z" #'ielm )
                  (advice-add #'eval-region :around #'+eval-region@pulse)))

(setup (:pkg elisp-slime-nav)
       (:load-after ielm
                    (:hook-into emacs-lisp-mode ielm-mode)
                    (:hide-mode)))

(setup (:pkg ielm)
       (:load-after comint
                    (:with-map ielm-map
                               (:bind
                                [up] comint-previous-input
                                [down] comint-next-input))))

(setup (:pkg macrostep)
       (:with-map macrostep-keymap
                  (:bind
                   [tab] macrostep-next-macro
                   [backtab] macrostep-prev-macro
                   "c" macrostep-collapse
                   "e" macrostep-expand
                   "q" macrostep-collapse-all))
       (:hide-mode))

;; Evaluation Result Overlay
;; (setup (:pkg eros)
;;   (:hook-into emacs-lisp-mode eros-mode))
#+end_src

#+begin_src emacs-lisp :noweb-ref corgi-elisp
;; Emacs Lisp config, mainly to have a development experience that feels
;; similar to using CIDER and Clojure. (show results in overlay, threading
;; refactorings)
(use-package corgi-emacs-lisp)
#+end_src
*** Emacs-lisp setup
:PROPERTIES:
:header-args: :tangle lisp/init-elisp.el :noweb yes
:ID:       c07e92e9-c358-4938-977c-b6aa393c7277
:END:
#+begin_src emacs-lisp
;;; init-elisp.el --- Emacs LISP -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<corgi-elisp>>

(provide 'init-elisp)
;;; init-elisp.el ends here
#+end_src
** Common LISP

SLY setup
#+begin_src emacs-lisp :noweb-ref code-common-lisp
(use-package lisp-mode
  :straight nil
  :hook ((lisp-mode lisp-data-mode) . common-lisp-modes-mode))

(use-package inf-lisp
  :straight nil
  :hook (infe
(defun mf/sly-ask ()
  (interactive)
  (let ((current-prefix-arg '-))
    (sly nil nil t)))

(setup (:pkg sly)
       (:when-loaded
        (sly-setup '(sly-fancy))
        (:require 'sly-autoloads))
       (setq sly-command-switch-to-existing-lisp 'always)
       (setq sly-complete-symbol-function 'sly-flex-completions)
       (setq sly-enable-evaluate-in-emacs t)
       (setq sly-kill-without-query-p t)
       (setq sly-lisp-implementations mf/cl-implementations)
       (setq sly-mrepl-history-file-name (save-in-etc-file! "sly-repl-history"))
       (setq sly-mrepl-pop-sylvester nil)
       (setq sly-mrepl-prevent-duplicate-history 'move)
       (setq sly-net-coding-system 'utf-8-unix)
       (:with-map sly-mrepl-mode-map
                  (:bind
                   [S-return] newline-and-indent
                   [up] sly-mrepl-previous-input-or-button
                   [down] sly-mrepl-next-input-or-button))
       (:with-map sly-inspector-mode-map
                  (:bind
                   [return] push-button
                   [M-return] sly-mrepl-copy-part-to-repl
                   "gb" sly-inspector-pop
                   "h" sly-inspector-history
                   "i" sly-inspector-describe-inspectee
                   "p" sly-button-pretty-print))
       (:hide-mode))

(use-package sly
  :after inf-lisp
  :hook (sly-mrepl-mode . common-lisp-modes-mode)
  :config
  (sly-symbol-completion-mode -1))

(setup lisp-mode
       (:load-after sly
                    (define-local-keys lisp-mode-map
                      "'" '(sly :wk "sly")
                      ";" `(mf/sly-ask :wk "sly (ask)"))
                    (define-local-keys lisp-mode-map
                      :infix "c"
                      "" '(:ignore t :wk "compile")
                      "c" '(sly-compile-file :wk "compile file")
                      "C" '(sly-compile-and-load-file :wk "compile/load file")
                      "f" '(sly-compile-defun :wk "compile top-level form")
                      "l" '(sly-load-file :wk "load file")
                      "n" '(sly-remove-notes :wk "remove notes")
                      "r" '(sly-compile-region :wk "compile region"))
                    (define-local-keys lisp-mode-map
                      :infix "e"
                      "" '(:ignore t :wk "evaluate")
                      "b" '(sly-eval-buffer :wk "buffer")
                      "e" '(sly-eval-last-expression :wk "last expression")
                      "f" '(sly-eval-defun :wk "function")
                      "F" '(sly-undefine-function :wk "undefine function")
                      "r" '(sly-eval-region :wk "region"))
                    (define-local-keys lisp-mode-map
                      :infix "g"
                      "" '(:ignore t :wk "go")
                      "b" '(sly-pop-find-definition-stack :wk "back")
                      "d" '(sly-edit-definition :wk "definition")
                      "D" '(sly-edit-definition-other-window :wk "definition (other window)")
                      "n" '(sly-next-note :wk "next note")
                      "N" '(sly-previous-note :wk "previous note")
                      "s" '(sly-stickers-next-sticker :wk "next sticker")
                      "S" '(sly-stickers-prev-sticker :wk "previous sticker"))
                    (define-local-keys lisp-mode-map
                      :infix "h"
                      "" '(:ignore t :wk "help")
                      "<" '(sly-who-calls :wk "who calls")
                      ">" '(sly-calls-who :wk "calls who")
                      "~" '(hyperspec-lookup-format :wk "lookup format directive")
                      "#" '(hyperspec-lookup-reader-macro :wk "lookup reader macro")
                      "a" '(sly-apropos :wk "apropos")
                      "b" '(sly-who-binds :wk "who binds")
                      "d" '(sly-disassemble-symbol :wk "disassemble symbol")
                      "h" '(sly-describe-symbol :wk "describe symbol")
                      "H" '(sly-hyperspec-lookup :wk "hyperspec lookup")
                      "m" '(sly-who-macroexpands :wk "who macro-expands")
                      "p" '(sly-apropos-package :wk "apropos package")
                      "r" '(sly-who-references :wk "who references")
                      "s" '(sly-who-specializes :wk "who specializes")
                      "S" '(sly-who-sets :wk "who sets"))
                    (define-local-keys lisp-mode-map
                      :infix "r"
                      "" '(:ignore t :wk "repl")
                      "c" '(sly-mrepl-clear-repl :wk "clear")
                      "q" '(sly-quit-lisp :wk "quit")
                      "r" '(sly-restart-inferior-lisp :wk "restart")
                      "s" '(sly-mrepl-sync :wk "sync"))
                    (define-local-keys lisp-mode-map
                      :infix "s"
                      "" '(:ignore t :wk "stickers")
                      "b" '(sly-stickers-toggle-break-on-stickers :wk "toggle break")
                      "c" '(sly-stickers-clear-defun-stickers :wk "clear function")
                      "C" '(sly-stickers-clear-buffer-stickers :wk "clear buffer")
                      "f" '(sly-stickers-fetch :wk "fetch")
                      "r" '(sly-stickers-replay :wk "replay")
                      "s" '(sly-stickers-dwim :wk "add/remove"))
                    (define-local-keys lisp-mode-map
                      :infix "t"
                      "" '(:ignore t :wk "trace")
                      "t" '(sly-toggle-trace-fdefinition :wk "toggle")
                      "T" '(sly-toggle-fancy-trace :wk "toggle (fancy)")
                      "u" '(sly-untrace-all :wk "untrace all"))))

(use-package racket-mode
  :hook ((racket-mode racket-repl-mode) . common-lisp-modes-mode))

#+end_src
** Clojure

Editing Clojure / Clojurescript code is best done using a REPL, which is provided with the cider package.
Cider has a lot of options to customise, and here are the ones I think are most critical.
Source comes from: [[https://stackoverflow.com/a/31080940]]
#+begin_src emacs-lisp :noweb-ref corgi-clj-setup
;; Extensive setup for a good Clojure experience, including clojure-mode,
;; CIDER, and a modeline indicator that shows which REPLs your evaluations go
;; to.
;; Also contains `corgi/cider-pprint-eval-register', bound to `,,', see
;; `set-register' calls below.
(use-package corgi-clojure)
#+end_src
#+begin_src elisp :noweb-ref code-clojure
(use-package clojure-mode
  :magic ("^#![^\n]*/\\(clj\\|clojure\\|bb\\|nbb\\)" . clojure-mode)
  :init
  (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
  :hook ((clojure-mode
          clojurec-mode
          clojurescript-mode)
         . clojure-mode-setup)
  :mode (rx "/.edn" eos)
  :bind ("<M-return>" . 'clerk-show)
  :config
  (setq clojure-toplevel-inside-comment-form t
        ;; Because of CIDER's insistence to send forms to all linked REPLs, we
        ;; *have* to be able to switch cljc buffer to clj/cljs mode without
        ;; cider complaining.
        clojure-verify-major-mode nil)
  (defvar org-babel-default-header-args:clojure '((:results . "silent")))'
  (defun org-babel-execute:clojure (body params)
    "Evaluate a block of Clojure code with Babel."
    (lisp-eval-string body))
  (defun clojure-set-compile-command ()
    (let ((project-dir (clojure-project-dir)))
      (cond ((and (file-exists-p (expand-file-name "project.clj" project-dir))
                  (executable-find "lein"))
             (setq-local compile-command "lein "))
            ((and (file-exists-p (expand-file-name "deps.edn" project-dir))
                  (executable-find "clojure"))
             (setq-local compile-command "clojure ")))))
  (defun clojure-mode-setup ()
    "Setup Clojure buffer."
    (common-lisp-modes-mode)
    (clojure-set-compile-command)
    (flycheck-mode))
(defun clerk-show ()
  (interactive)
  (when-let
      ((filename
        (buffer-file-name)))
    (save-buffer)
    (cider-interactive-eval
     (concat "(nextjournal.clerk/show! \"" filename "\")")))))

(use-package cider
  :diminish t
  ;; :hook (((cider-repl-mode cider-mode) . eldoc-mode)
  ;;        (cider-repl-mode . common-lisp-modes-mode))
  :bind ( :map cider-repl-mode-map
          ("C-c C-S-o" . cider-repl-clear-buffer))
  :custom-face
  (cider-result-overlay-face ((t (:box (:line-width -1 :color "grey50")))))
  (cider-error-highlight-face ((t (:inherit flymake-error))))
  (cider-warning-highlight-face ((t (:inherit flymake-warning))))
  :custom
  (nrepl-log-messages nil)
  (cider-repl-display-help-banner nil)
  (cider-repl-tab-command #'indent-for-tab-command)
  (nrepl-hide-special-buffers t)
  (cider-test-show-report-on-success t)
  (cider-allow-jack-in-without-project t)
  (cider-use-fringe-indicators nil)
  (cider-font-lock-dynamically '(macro var deprecated))
  (cider-save-file-on-load nil)
  (cider-inspector-fill-frame nil)
  (cider-auto-select-error-buffer t)
  (cider-eval-spinner t)
  (nrepl-use-ssh-fallback-for-remote-hosts t)
  (cider-enrich-classpath t)
  :config
  (setq cider-preferred-build-tool 'clojure-cli
        ;; ~make sure we can always debug nrepl issues~
        ;; Turning this off again, seems it may really blow up memory usage
        ;; nrepl-log-messages nil

        )

  ;; TODO: clean this up, submit to upstream where possible
  ;; More CIDER/clojure-mode stuff
  ;; - logical-sexp doesn't treat #_ correctly

  ;; New function, should go upstream. Kill all associated REPLs
  (defun corgi/cider-quit-all ()
    "Quit all current CIDER REPLs."
    (interactive)
    (let ((repls (seq-remove (lambda (r)
                               (equal r (get-buffer "*babashka-repl*")))
                             (seq-mapcat #'cdr (sesman-current-sessions 'CIDER)))))
      (seq-do #'cider--close-connection repls))
    ;; if there are no more sessions we can kill all ancillary buffers
    (cider-close-ancillary-buffers)
    ;; need this to refresh sesman browser
    (run-hooks 'sesman-post-command-hook))

  ;; When asking for a "matching" REPL (clj/cljs), and no matching REPL is found,
  ;; return any REPL that is there. This is so that cider-quit can be called
  ;; repeatedly to close all REPLs in a process. It also means that , s s will go
  ;; to any REPL if there is one open.
  (defun corgi/around-cider-current-repl (command &optional type ensure)
    (let ((repl (or
                 (if (not type)
                     (or (funcall command nil)
                         (funcall command 'any))
                   (funcall command type))
                 (get-buffer "*babashka-repl*"))))
      (if (and ensure (null repl))
          (cider--no-repls-user-error type)
        repl)))

  (advice-add #'cider-current-repl :around #'corgi/around-cider-current-repl)

  ;; This essentially redefines cider-repls. The main thing it does is return all
  ;; REPLs by using sesman-current-sessions (plural) instead of
  ;; sesman-current-session. It also falls back to the babashka repl if no repls
  ;; are connected/linked, so we can always eval.
  (defun corgi/around-cider-repls (_command &optional type ensure)
    (let ((type (cond
                 ((listp type)
                  (mapcar #'cider-maybe-intern type))
                 ((cider-maybe-intern type))))
          (repls (delete-dups (seq-mapcat #'cdr (or (sesman-current-sessions 'CIDER)
                                                    (when ensure
                                                      (user-error "CIDER sessions non liées"))))))
          (bb-repl (get-buffer "*babashka-repl*")))
      (or (seq-filter (lambda (b)
                        (and (cider--match-repl-type type b)
                             (not (equal b bb-repl))))
                      repls)
          (when bb-repl
            (list bb-repl)))))

  (advice-add #'cider-repls :around #'corgi/around-cider-repls)

  (defun corgi/cider-eval-last-sexp-and-replace ()
    "Alternative to cider-eval-last-sexp-and-replace, but kills
clojure logical sexp instead of ELisp sexp, and pprints the
result."
    (interactive)
    (let ((last-sexp (cider-last-sexp)))
      ;; we have to be sure the evaluation won't result in an error
      (cider-nrepl-sync-request:eval last-sexp)
      ;; seems like the sexp is valid, so we can safely kill it
      (let ((opoint (point)))
        (clojure-backward-logical-sexp)
        (kill-region (point) opoint))
      (cider-interactive-eval last-sexp
                              (cider-eval-pprint-with-multiline-comment-handler
                               (current-buffer)
                               (set-marker (make-marker) (point))
                               ""
                               " "
                               "")
                              nil
                              (cider--nrepl-print-request-map fill-column))))

  (defun corgi/cider-pprint-eval-last-sexp-insert ()
    (interactive)
    (let ((cider-comment-prefix "")
          (cider-comment-continued-prefix " ")
          (cider-comment-postfix ""))
      (cider-pprint-eval-last-sexp-to-comment)))

  (defadvice cider-find-var (before add-evil-jump activate)
    (evil-set-jump))

  (defun corgi/around-cider--choose-reusable-repl-buffer (_command _params)
    "Redefine cider--choose-reusable-repl-buffer to something more
sensible. If any dead REPL buffers exist when creating a new one
then simply delete them first. Return nil so `cider-create-repl'
creates a new one. Don't unnecessarily bother the user."
    (seq-do #'kill-buffer
            (seq-filter (lambda (b)
                          (with-current-buffer b
                            (and (derived-mode-p 'cider-repl-mode)
                                 (not (process-live-p (get-buffer-process b))))))
                        (buffer-list)))
    nil)

  (advice-add #'cider--choose-reusable-repl-buffer :around #'corgi/around-cider--choose-reusable-repl-buffer)
  )

;; silence byte compiler
(require 'clojure-mode)
(require 'cider)

;; Most annoying JVM "feature" of all time
;; https://docs.cider.mx/cider/troubleshooting.html#empty-java-stacktraces
(defun corgi/around-cider-jack-in-global-options (command project-type)
  (if (eq 'clojure-cli project-type)
      (concat cider-clojure-cli-global-options
              " -J-XX:-OmitStackTraceInFastThrow")
    (funcall command project-type)))

(advice-add #'cider-jack-in-global-options :around #'corgi/around-cider-jack-in-global-options)

(use-package clj-refactor
  :disabled t
  :diminish clj-refactor-mode
  :hook ((clj-refactor-mode . yas-minor-mode)
         (cider-mode . clj-refactor-mode))
  :custom
  (cljr-suppress-no-project-warning t)
  (cljr-suppress-middleware-warnings t)
  (cljr-warn-on-eval nil))

(use-package clj-ns-name
:straight '(clj-ns-name
                  :type git
                 :repo "corgi-emacs/clj-ns-name" )
:config
  (clj-ns-name-install))

(use-package walkclj
:straight '(walkclj
                  :type git
                 :repo "corgi-emacs/walkclj" ))

(use-package flycheck-clj-kondo
  :after cider
  :when (executable-find "clj-kondo"))

(defun corgi/cider-pprint-eval-register (register)
  "Evaluate a Clojure snippet stored in a register.
Will ask for the register when used interactively. Put `#_clj' or
`#_cljs' at the start of the snippet to force evaluation to go to
a specific REPL type, no matter the mode (clojure-mode or
clojurescript-mode) of the current buffer.
You can use {{...}} to insert emacs-lisp code that willg get
evaluated, like `(println \"{{buffer-file-name}}\")'.
"
  (interactive (list (register-read-with-preview "Eval register: ")))
  (let ((reg (replace-regexp-in-string
              "{{\\([^}]+\\)}}"
              (lambda (s)
                (eval
                 (read
                  (match-string 1 s))))
              (get-register register))))
    (cond
     ((string-match-p "^#_cljs" reg)
      (with-current-buffer (car (cider-repls 'cljs))
        (cider--pprint-eval-form reg)))
     ((string-match-p "^#_clj" reg)
      (with-current-buffer (car (cider-repls 'clj))
        (cider--pprint-eval-form reg)))
     (t
      (cider--pprint-eval-form reg)))))

;; Backwards compatibility
(defalias 'corgi/cider-pprint-register #'corgi/cider-pprint-eval-register)

(defun corgi/cider-jack-in-babashka (&optional project-dir)
  "Start a utility CIDER REPL backed by Babashka, not related to a
specific project."
  (interactive)
  (let ((project-dir (or project-dir user-emacs-directory)))
    (nrepl-start-server-process
     project-dir
     "bb --nrepl-server 0"
     (lambda (server-buf)
       (set-process-query-on-exit-flag
        (get-buffer-process server-buf) nil)
       (cider-nrepl-connect
        (list :repl-buffer server-buf
              :repl-type 'clj
              :host (plist-get nrepl-endpoint :host)
              :port (plist-get nrepl-endpoint :port)
              :project-dir project-dir
              :session-name "babashka"
              :repl-init-function (lambda ()
                                    (setq-local cljr-suppress-no-project-warning t
                                                cljr-suppress-middleware-warnings t
                                                process-query-on-exit-flag nil)
                                    (set-process-query-on-exit-flag
                                     (get-buffer-process (current-buffer)) nil)
                                    (rename-buffer "*babashka-repl*"))))))))

(defun corgi/cider-modeline-info ()
  (when (derived-mode-p 'clojure-mode)
    (let ((source-project-name (projectile-project-name)))
      (if-let* ((repls (ignore-errors (cider-repls (cider-repl-type-for-buffer)))))
          (thread-last
            repls
            (seq-map
             (lambda (repl)
               (with-current-buffer repl
                 (if (equal (buffer-name repl) "*babashka-repl*")
                     (propertize "bb" 'face '( :background "green"
                                               :foreground "black"))
                   (let ((info (concat
                                (when-let ((repl-project-name (cider--project-name nrepl-project-dir)))
                                  (when (not (equal repl-project-name source-project-name))
                                    (concat ":" repl-project-name)))
                                (pcase (plist-get nrepl-endpoint :host)
                                  ("localhost" "")
                                  ("127.0.0.1" "")
                                  (x (concat ":" x)))
                                ;;(format ":%d" (plist-get nrepl-endpoint :port))
                                )))
                     (cl-case cider-repl-type
                       (clj (propertize (concat "clj" info) 'face '( :background "#5881D8"
                                                                     :foreground "white")))
                       (cljs (propertize (concat "cljs" info) 'face '( :background "#f7df1e"
                                                                       :foreground "black")))
                       (pending-cljs (propertize (concat "pending-cljs" info) 'face '( :background "#f7df1e"
                                                                                       :foreground "black")))))))))
            (s-join " "))
        (propertize "<pas connecté>" 'face '( :background "red"
                                               :foreground "white"))))))


(defun corgi/enable-cider-connection-indicator-in-current-buffer ()
  (when (not (seq-find (lambda (e) (eq e '(:eval (corgi/cider-modeline-info)))) mode-line-format))
    (setq mode-line-format
          (seq-mapcat
           (lambda (e)
             (if (eq 'mode-line-modes e)
                 '(" " (:eval (corgi/cider-modeline-info)) " " mode-line-modes)
               (list e)))
           mode-line-format))))

(defun corgi/enable-cider-connection-indicator ()
  "In Clojure buffers show an indicator in the modeline for which
 CIDER REPLs the current buffer is linked to, with color coding
for clj/cljs/bb, and extra info if the link goes to a different
project or host."
  (interactive)
  (add-hook 'clojure-mode-hook #'corgi/enable-cider-connection-indicator-in-current-buffer)
  (dolist (buf (buffer-list))
    (with-current-buffer buf
      (when (eq 'clojure-mode major-mode)
        (corgi/enable-cider-connection-indicator-in-current-buffer)))))

#+end_src
*** Corgi clojure
#+begin_src emacs-lisp :noweb-ref corgi-clojure
;; Emacs has "registers", places to keep small snippets of text. We make it easy
;; to run a snippet of Clojure code in such a register, just press comma twice
;; followed by the letter that designates the register (while in a Clojure
;; buffer with a connected REPL). The code will be evaluated, and the result
;; pretty-printed to a separate buffer.

;; By starting a snippet with `#_clj' or `#_cljs' you can control which type of
;; REPL it will go to, in case you have both a CLJ and a CLJS REPL connected.
(set-register ?k "#_clj (do (require 'kaocha.repl) (kaocha.repl/run))")
(set-register ?K "#_clj (do (require 'kaocha.repl) (kaocha.repl/run-all))")
(set-register ?r "#_clj (do (require 'user :reload) (user/reset))")
(set-register ?g "#_clj (user/go)")
(set-register ?b "#_clj (user/browse)")

;; Enable our "connection indicator" for CIDER. This will add a colored marker
;; to the modeline for every REPL the current buffer is connected to, color
;; coded by type.
(corgi/enable-cider-connection-indicator)

;; Create a *scratch-clj* buffer for evaluating ad-hoc Clojure expressions. If
;; you make sure there's always a babashka REPL connection then this is a cheap
;; way to always have a place to type in some quick Clojure expression evals.
;;(with-current-buffer (get-buffer-create "*scratch-clj*")
;; (clojure-mode))

;; Connect to Babashka if we can find it. This is a nice way to always have a
;; valid REPL to fall back to. You'll notice that with this all Clojure buffers
;; get a green "bb" indicator, unless there's a more specific clj/cljs REPL
;; available.
(when (executable-find "bb")
  (corgi/cider-jack-in-babashka "~/Dev/clj/clerk"))

;; add nbb repl experience
(cider-register-cljs-repl-type 'nbb-or-scittle "(+ 40 2)") ;;"(do (require '[promesa.core :as p]))")

(defun mm/cider-connected-hook ()
  (when (eq 'nbb-or-scittle cider-cljs-repl-type)
    (setq-local cider-show-error-buffer nil)
    (cider-set-repl-type 'cljs)))

(add-hook 'cider-connected-hook #'mm/cider-connected-hook)

(defun mm/cider-jack-in-nbb ()
  "Start a nbb nrepl process and connect."
  (interactive)
  (let* ((cider-allow-jack-in-without-project t)
         (orig-buffer (current-buffer))
         (params '(:jack-in-cmd "nbb nrepl-server :port 0"
                                :cljs-repl-type nbb-or-scittle))
         (params (cider--update-project-dir
                  params)))
    (nrepl-start-server-process
     (plist-get params :project-dir)
     (plist-get params :jack-in-cmd)
     (lambda (server-buffer)
       (with-current-buffer
           orig-buffer
         (cider-connect-sibling-cljs
          params
          server-buffer))))))

;;; FIXME: https://github.com/clojure-emacs/cider/issues/3255
(defun cider-verify-clojurescript-is-present ()
  "Check whether ClojureScript is present."
  (unless (nrepl-dict-get (cider-sync-tooling-eval "cljs.core/inc") "value")
    (user-error "ClojureScript n'est pas disponible.  See https://docs.cider.mx/cider/basics/clojurescript for details")))

#+end_src

*** clj templates
:PROPERTIES:
:ID:       330e9ad1-9bd0-4386-ac8d-0a678ebb1626
:END:
Insertion templates can be used to speed up project setups. This is code of my own creation, so use at your own risk. The template files are in ~.emacs.d/templates/lib.org~.

**** slurp
:PROPERTIES:
:ID:       0828d7f4-cd5d-4c67-96ca-3d258df3de6c
:END:
#+begin_src elisp
(defun slurp (file)
  (with-temp-buffer
    (insert-file-contents file)
    (buffer-substring-no-properties
     (point-min)
     (point-max))))

#+end_src

**** template-reader
:PROPERTIES:
:ID:       b3a54fa3-459b-4042-98e0-cdb2a87ed925
:END:
#+begin_src elisp
(defun template-reader (file replace)
  (let ((lines (split-string (slurp file) "\n")))
    (->> lines
         (mapcar (lambda (x) (replace-regexp-in-string "_str_" replace x)))
         (mapcar (lambda (x) (concat x "\n")))
         (-concat)
         (apply 'concat))))

#+end_src

**** clj-org-templates
:PROPERTIES:
:ID:       7d6c4f18-4510-4ebc-951d-94c4233407a5
:END:
I use org mode and literate programming ideas to build my clj/cljs projects. So, it is helpful to have skeletons that take .org template files that tangle into a nice clojure project setup. Currently I only have one template, but the idea is to be able to have a few which you just bind to different keys as needed. The idea is demonstrated with 'Project' and 'Library'.

#+begin_src elisp :tangle no
(define-skeleton cljc-lib-skeleton
  "Inserts a .org template with user's project name input.
   Use in empty file and save to desired project directory.
   Tangle will create project structure on save."
  ""
  (template-reader "~/.config/emacs/templates/lib.org" (skeleton-read "Library name: ")))

(define-skeleton cljc-project-skeleton
  "Inserts a .org template with user's project name input.
   Use in empty file and save to desired project directory.
   Tangle will create project structure on save."
  ""
  (template-reader "~/.emacs.d/templates/lib.org" (skeleton-read "Project name: ")))

;;(global-set-key (kbd "C-S-L") 'cljc-lib-skeleton)
;;(global-set-key (kbd "C-S-P") 'cljc-project-skeleton)

#+end_src
*** Tangle Clojure setup
:PROPERTIES:
:header-args: :tangle lisp/init-clojure.el :noweb yes
:END:
#+begin_src emacs-lisp
;;; init-clojure.el --- Clojure -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:
<<lisp-ide>>

<<code-clojure>>

<<corgi-clojure>>

(provide 'init-clojure)
;;; init-clojure.el ends here
#+end_src
** Javascript
Setup JS

The add-node-modules-path package is great for automatically detecting and using npm package binaries which are locally installed in the project you're actively editing, such as eslint, prettier, etc. This allowed me to no longer maintain similar functionality I had written myself as Emacs Lisp functions.

#+begin_src emacs-lisp :noweb-ref code-js
(use-package js
  :straight nil
  ;; :mode ("\\.jsx?\\'" . js-jsx-mode)
  :config
  (setq js-indent-level gas/indent-width)
  (add-hook 'flycheck-mode-hook
            #'(lambda ()
                (let* ((root (locate-dominating-file
                              (or (buffer-file-name) default-directory)
                              "node_modules"))
                       (eslint (and root (expand-file-name "node_modules/.bin/eslint" root))))
                  (when (and eslint (file-executable-p eslint))
                    (setq-local flycheck-javascript-eslint-executable eslint))))))

(use-package json-mode)

(use-package rjsx-mode
  :mode ("\\.js\\'"
         "\\.jsx\\'")
  :config
  (setq js2-mode-show-parse-errors nil
        js2-mode-show-strict-warnings nil
        js2-basic-offset 2
        js-indent-level 2)
  (setq-local flycheck-disabled-checkers (cl-union flycheck-disabled-checkers
                                                   '(javascript-jshint))) ; jshint doesn't work for JSX
  (electric-pair-mode 1)
  ;;(evil-leader/set-key-for-mode 'rjsx-mode
  ;;  "fu"  #'lsp-find-references          ; (f)ind (u)sages
  ;;  "fp" 'prettier-js-mode)
  )             ; (f)ormat (p)rettier

(use-package add-node-modules-path
  :defer t
  :hook (((js2-mode rjsx-mode) . add-node-modules-path)))

(use-package prettier-js
  :defer t
  :diminish prettier-js-mode
  :hook (((js2-mode rjsx-mode typescript-mode) . prettier-js-mode))
  ;; :init
  ;; (evil-leader/set-key-for-mode 'rjsx-mode
  ;;   "fp" 'prettier-js-mode) ; (f)ormat (p)rettier
  )

(use-package js-comint)

 (defun setup-tide-mode ()
    (interactive)
    ;;  (setq tide-tsserver-process-environment '("TSS_LOG=-level verbose -file /tmp/tss.log"))
    (tide-setup)
    (if (file-exists-p (concat tide-project-root "node_modules/typescript/bin/tsserver"))
        (setq tide-tsserver-executable "node_modules/typescript/bin/tsserver"))
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1)
    (setq tide-format-options '(:indentSize 2 :tabSize 2 :insertSpaceAfterFunctionKeywordForAnonymousFunctions t :placeOpenBraceOnNewLineForFunctions nil))
    (local-set-key (kbd "C-c d") 'tide-documentation-at-point))

(use-package tide
  :after (typescript-mode company flycheck)
  :hook ((typescript-mode . tide-setup)
         (typescript-mode . tide-hl-identifier-mode)
         (before-save . tide-format-before-save))
  :config
  (add-hook 'typescript-mode-hook #'setup-tide-mode)
      (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-mode)))

#+end_src
*** Tangle JS setup
:PROPERTIES:
:header-args: :tangle lisp/init-javascript.el :noweb yes
:END:
#+begin_src emacs-lisp
;;; init-javascript.el --- JavaScript -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<code-js>>

(provide 'init-javascript)
;;; init-javascript.el ends here
#+end_src

** Fennel
:properties:
:header-args: :noweb-ref code-fennel
:ID:       a8e738f4-2a6a-4fe4-8efe-9cedd4aaedd3
:end:
Setup of Fennel and Lua

#+begin_src emacs-lisp

(use-package lua-mode
  :hook (lua-mode . flycheck-mode)
  :custom
  (lua-indent-level 2)
  :config
  (defvar org-babel-default-header-args:lua '((:results . "silent")))
  (defun org-babel-execute:lua (body _)
    "Evaluate a block of Lua code with Babel."
    (lua-get-create-process)
    (lua-send-string body)))


(use-package fennel-mode
  :straight (:host nil :repo "https://git.sr.ht/~technomancy/fennel-mode")
  :hook ((fennel-mode fennel-repl-mode) . common-lisp-modes-mode)
  :bind ( :map fennel-mode-map
          ("C-c C-k" . eval-each-sexp)
          ("M-." . xref-find-definitions)
          ("M-," . xref-pop-marker-stack))
  :config
  (dolist (sym '(global local var))
    (put sym 'fennel-indent-function 1))
  (defvar org-babel-default-header-args:fennel '((:results . "silent")))
  (defun org-babel-execute:fennel (body _params)
    "Evaluate a block of Fennel code with Babel."
    (save-window-excursion
      (unless (bufferp fennel-repl--buffer)
        (fennel-repl nil))
      (let ((inferior-lisp-buffer fennel-repl--buffer))
        (lisp-eval-string body))))
  :init
  (defun eval-each-sexp ()
    "Evaluate each s-expression in the buffer consequentially.
If prefix ARG specified, call `fennel-reload' function.  If
double prefix ARG specified call `fennel-reload' function and ask
for the module name."
    (interactive)
    (save-excursion
      (save-restriction
        (goto-char (point-min))
        (while (save-excursion
                 (search-forward-regexp "[^[:space:]]." nil t))
          (forward-sexp)
          (when (and (not (nth 4 (syntax-ppss)))
                     (looking-back "." 1))
            (lisp-eval-last-sexp)))))
    (when fennel-mode-switch-to-repl-after-reload
      (switch-to-lisp t))))

#+end_src
*** Tangle Fennel/LUA setup
:PROPERTIES:
:header-args: :tangle lisp/init-fennel.el :noweb yes
:ID:       afda404b-1889-4438-9efd-40a0aff2218d
:END:
#+begin_src emacs-lisp
;;; init-fennel.el --- Fennel LUA  -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<code-fennel>>

(provide 'init-fennel)
;;; init-fennel.el ends here
#+end_src
** SSH
#+begin_src emacs-lisp
(setup (:pkg ssh-config-mode)
       (:file-match (rx "/.ssh/config" eos)
                    (rx "/ssh" (? "d") "_config" eos))
       (:with-mode ssh-known-hosts-mode
                   (:file-match (rx "/knownhosts" eos)))
       (:with-mode ssh-authorized-keys-mode
                   (:file-match (rx "/authorized_keys" (? "2") eos))))
#+end_src
** Statistics
Emacs Speaks Statistics
#+begin_src emacs-lisp :noweb-ref ess
(use-package  ess
  :after ess-r-mode
  :diminish r-mode ""
  :init
  (add-to-list 'auto-mode-alist '("\\.R$" . r-mode))
  :config
  (setq ess-ask-for-ess-directory nil)
  (setq ess-local-process-name "R")
  (setq-default inferior-R-program-name (expand-file-name "bin/R" (or (getenv "HOMEBREW_PREFIX") "/usr/local")))
  (setq ess-eval-visibly 'nowait)
  (setq comint-input-ring-size 1000)
  (setq ess-indent-level 4)
  (setq ess-arg-function-offset 4)
  (setq ess-else-offset 4)
  (setq ess-use-company t))
;; Autocomplete
;;    (:require auto-complete-config)
;;    (ac-config-default)
;;    (setq ess-use-auto-complete t)

;;    ;; Read pdfs outside emacs
;;    (:require openwith)
;;    (openwith-mode t)
;;    (setq openwith-associations '(("\\.pdf\\'" "open" (file))))
;;      ;;;; create a new frame for each help instance
;;    (setq ess-help-own-frame t)
;;    (setq ess-offset-continued 'straight
;;          ess-use-flymake 1
;;          ess-nuke-trailing-whitespace-p t
;;          ess-style 'DEFAULT
;;          ess-history-directory (expand-file-name "ess-history/" XDG_CACHE/ ))
;;    ;; Make the arrow keys refer to previous commands
;;    (defun my-ess-mode-hook ()
;;      (local-set-key '[up] 'comint-previous-input)
;;      (local-set-key '[down] 'comint-next-input)
;;      (local-set-key '[C-x \t] 'comint-dynamic-complete-filename))

;;    (add-hook 'inferior-ess-mode-hook 'my-ess-mode-hook))

;;  (defhydra hydra-polymode ()
;;    "Polymode Hydra"
;;    ("j" polymode-next-chunk-same-type "Next chunk, same type" :column "Movement")
;;    ("k" polymode-previous-chunk-same-type "Previous chunk, same type" :column "Movement")
;;    ("i" polymode-insert-new-chunk "Insert new chunk" :column "Insert")
;;    ("I" jth/insert-image "Insert image from file" :column "Insert")
;;    ("c" polymode-mark-or-extend-chunk "Mark chunk" :column "Chunk")
;;    ("u" polymode-insert-new-chunk-code-only "Insert chunk (code only)" :column "Insert")
;;    ("U" polymode-insert-new-chunk-output-only "Insert chunk (output only)" :column "Insert")
;;    ("p" polymode-insert-new-plot "Insert plot" :column "Insert")
;;    ("o" polymode-insert-yaml "Insert YAML" :column "Insert")
;;    ("d" polymode-kill-chunk "Kill chunk" :column "Chunk")
;;    ("m" my/add-pipe "Add pipe" :column "Insert")
;;    ("e" polymode-export "Export" :column "Export")
;;    ("E" polymode-set-exporter "Set exporter" :column "Export")
;;    ("w" polymode-weave "Weave" :column "Export")
;;    ("W" polymode-set-weaver "Set weaver" :column "Export")
;;    ("$" polymode-show-process-buffer "Show process buffer" :column "Evaluation")
;;    ("," polymode-eval-region-or-chunk "Eval chunk" :column "Evaluation")
;;    ("N" polymode-eval-buffer "Eval buffer" :column "Evaluation")
;;    ("1" polymode-eval-buffer-from-beg-to-point "Eval to here" :column "Evaluation")
;;    ("0" polymode-eval-buffer-from-point-to-end "Eval to end" :column "Evaluation"))

#+end_src
*** ESS setup
:Properties:
:header-args: :tangle lisp/init-ess.el :noweb yes
:ID:       a04b95ad-e2ca-4aa3-8f4a-301f6986cda8
:END:
Emacs Speaks Statisitcs setup here
#+begin_src emacs-lisp
;;; init-ess.el --- Code ESS -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<ess>>

(provide 'init-ess)
;;; init-ess.el ends here
#+end_src

** Eval lib
:PROPERTIES:
:header-args: :tangle lisp/lib-eval.el :noweb yes
:ID:       5b4b0991-3552-42c0-b352-64de8428927a
:END:
Smartparens setup here
#+begin_src emacs-lisp
;;; lib-eval.el --- Eval utilities -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:
(defmacro eval-with-default-dir (dir &rest body)
  "Invoke in DIR the BODY."
  (declare (debug t) (indent 1))
  `(let ((default-directory ,dir))
     ,@body))

(cl-flet ((always-yes (&rest _) t))
  (defun eval-no-confirm (fun &rest args)
    "Apply FUN to ARGS, skipping user confirmations."
    (cl-letf (((symbol-function 'y-or-n-p) #'always-yes)
              ((symbol-function 'yes-or-no-p) #'always-yes))
      (apply fun args))))

(provide 'lib-eval)
;;; lib-eval.el ends here
#+end_src

** Default coding setups - Markdown , YAML, Terrafom, Bash etc
Setup for bb and bash-completion
#+begin_src emacs-lisp :noweb-ref bash-compl
(use-package bash-completion
  :init
  (autoload 'bash-completion-dynamic-complete
    "bash-completion"
    "BASH completion hook")
  (add-hook 'shell-dynamic-complete-functions
            #'bash-completion-dynamic-complete)

  :config
  (defun bash-completion-capf-1 (bol)
    (bash-completion-dynamic-complete-nocomint (funcall bol) (point) t))
  (defun bash-completion-eshell-capf ()
    (bash-completion-capf-1 (lambda () (save-excursion (eshell-bol) (point)))))
  (defun bash-completion-capf ()
    (bash-completion-capf-1 #'point-at-bol))
  (add-hook
   'sh-mode-hook
   (defun mm/add-bash-completion ()
     (add-hook 'completion-at-point-functions #'bash-completion-capf nil t))))

(use-package shell
  :ensure nil
  :config
  (defun mm/with-current-window-buffer (f &rest args)
    (with-current-buffer
	(window-buffer (car (window-list)))
      (apply f args)))

  (defun mm/shell-via-async-shell-command ()
    (switch-to-buffer
     (window-buffer
      (async-shell-command
       shell-file-name))))

  (advice-add #'mm/shell-via-async-shell-command :around #'mm/with-current-window-buffer)

  (setf shell-kill-buffer-on-exit t)

  (add-hook
   'shell-mode-hook
   (defun mm/shell-dont-mess-with-scroll-conservatively ()
     (setq-local scroll-conservatively 0))))

(use-package emacs
  :config
  (setq async-shell-command-buffer 'new-buffer)

  (defun path-slug (dir)
    "Returns the initials of `dir`s path,
with the last part appended fully
Example:
(path-slug \"/foo/bar/hello\")
=> \"f/b/hello\" "
    (require 'dash)
    (let* ((path (replace-regexp-in-string "\\." "" dir))
	   (path (split-string path "/" t))
	   (path-s (mapconcat
		    (lambda (it)
		      (cl-subseq it 0 1))
		    (-drop-last 1 path)
		    "/"))
	   (path-s (concat
		    path-s
		    "/"
		    (-last-item path))))
      path-s))

  (defun mm/put-command-in-async-buff-name (f &rest args)
    (let* ((path-s (path-slug default-directory))
	   (command (car args))
	   (buffname (concat path-s " " command))
	   (shell-command-buffer-name-async
	    (format
	     "*async-shell-command %s*"
	     (string-trim
	      (substring buffname 0 (min (length buffname) 50))))))
      (apply f args)))

  (advice-add 'shell-command :around #'mm/put-command-in-async-buff-name)

  (add-hook
   'comint-mode-hook
   (defun mm/do-hack-dir-locals (&rest _)
     (hack-dir-local-variables-non-file-buffer)))

  (advice-add
   'compile
   :filter-args
   (defun mm/always-use-comint-for-compile (args)
     `(,(car args) t))))



#+end_src
YAFUML - Yet Another Fucked UP Markup/down Language
#+begin_src emacs-lisp :noweb-ref yaml
(use-package yaml-mode
  :mode ("\\.yml\\'" . yaml-mode)
  :config
  (add-hook 'yaml-mode-hook
            '(lambda ()
               (define-key yaml-mode-map "\C-m" 'newline-and-indent))))

(use-package toml-mode
  :mode "\\.toml\\'")



#+end_src
Why do I uee this if I use Org?
#+begin_src emacs-lisp :noweb-ref md
(use-package markdown-mode
  :mode ("README\\.md\\'" . gfm-mode)
  :mode "\\.md\\'"
  :hook ((markdown-mode . auto-fill-mode))
  :init (setq markdown-command "multimarkdown"))

#+end_src
*** Tangle Utility Coding packages - MD, yaml
:PROPERTIES:
:header-args: :tangle lisp/init-utils-coding.el :noweb yes
:END:

Setup utility packages
#+begin_src emacs-lisp
;;; init-utils-coding.el --- Coding Utilities -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:sh>>i<<bash>>

<<bash-compl>>

<<yaml>>

<<md>>

(provide 'init-utils-coding)
;;; init-utils-coding.el ends here
#+end_src

* Tangling config noweb
** Header & disclaimer <disclaimer>
:PROPERTIES:
:header-args: :noweb-ref disclaimer
:END:
#+begin_src emacs-lisp
;; Copyright (C) 2001-2023 Gas
;; Timestamp: <>
;; Author: Gas <gas@tuatara.red>
;; Version: 1.0
;; Package-Version: 0.8
;; Created: Sometime during the Covid-19 lockdown
;; Keywords: configuration, emacs
;; URL: https://github.com/frap/emacs
;; Package-Requires: ((emacs "27.2"))

;; This file is not part of GNU Emacs.

;;; Commentary:
;; This file maybe automatically tangled from config.org.
;; Hand edits will be overwritten!
;; Je t'ai prévenu putain!

#+end_src
** Emacs Builtins

Setup Emacs builtins

#+begin_src emacs-lisp :tangle no
;;; init-builtin.el --- Builtins -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:
(setup auto-fill
       (:with-feature simple
                      (:with-mode (text-mode org-mode)
                                  (:hook turn-on-auto-fill))
                      (:with-mode prog-mode
                                  (:hook (fn (setq-local comment-auto-fill-only-comments t)
                                             (auto-fill-mode 1))))
                      (:hide-mode auto-fill-function)))


(setup (:require goto-addr)
       (:with-mode prog-mode
                   (:hook goto-address-prog-mode))
       (:with-mode text-mode
                   (:hook goto-address-mode)))

(setup (:require help-mode)
       (setq help-window-select t))

(setup (:require url)
       (setq url-cookie-file (save-in-etc-file! "url-cookies")))

(provide 'init-builtin)
;;; init-builtin.el ends here
#+end_src
** Buffers
:PROPERTIES:
:header-args: :tangle lisp/init-buffer.el :noweb yes
:END:

Setup the Emacs buffer

#+begin_src emacs-lisp
;;; init-buffer.el --- Buffer Setup -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(require 'config-path)
(require 'init-kbd)

<<buffers>>

(provide 'init-buffer)
;;; init-buffer.el ends here
#+end_src

*** lib-buffer
:PROPERTIES:
:header-args: :tangle lisp/lib-buffer.el :noweb yes
:END:

Autoloads for buffers
#+begin_src emacs-lisp
;;; lib-buffer.el --- Utilities for working with Buffers -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

;;;###autoload
(defun buffer-content (buffer-or-name)
  "Return content of BUFFER-OR-NAME.
  Resulting string is full of properties. Consider using
  `substring-no-properties':
    (substring-no-properties (buffer-content BUFFER-OR-NAME))"
  (with-current-buffer buffer-or-name
    (buffer-substring (point-min)
                      (point-max))))

;;;###autoload
(defun buffer-lines (buffer-or-name)
  "Return lines of BUFFER-OR-NAME.
  Each line is a string with properties. Trailing newline character
  is not present."
  (buffer-lines-map buffer-or-name #'identity))

;;;###autoload
(defun buffer-lines-map (buffer-or-name fn)
  "Call FN on each line of BUFFER-OR-NAME and return resulting list.
  As opposed to `buffer-lines-each', this function accumulates
  result.
  Each line is a string with properties. Trailing newline character
  is not present."
  (declare (indent 1))
  (with-current-buffer buffer-or-name
    (goto-char (point-min))
    (let ((result))
      (while (not (eobp))
        (setq
         result
         (cons
          (funcall fn (buffer-substring
                       (line-beginning-position)
                       (line-end-position)))
          result))
        (forward-line))
      (reverse result))))

;;;###autoload
(defun buffer-lines-each (buffer-or-name fn)
  "Call FN on each line of BUFFER-OR-NAME.
  As opposed to `buffer-lines-map', this function does not
  accumulate any result and should used for side-effects.
  Each line is a string with properties. Trailing newline character
  is not present."
  (declare (indent 1))
  (with-current-buffer buffer-or-name
    (goto-char (point-min))
    (while (not (eobp))
      (funcall fn (buffer-substring
                   (line-beginning-position)
                   (line-end-position)))
      (forward-line))))

;;;###autoload
(defun buffer-lines-each-t (buffer-or-name fn)
  "Call FN on each line of BUFFER-OR-NAME and replace it by result.
  Each line is a string with properties. Trailing newline character
  is not present."
  (declare (indent 1))
  (with-current-buffer buffer-or-name
    (goto-char (point-min))
    (let (l0 l1 s)
      (while (not (eobp))
        (setq l0 (line-beginning-position))
        (setq l1 (line-end-position))
        (setq s (buffer-substring l0 l1))
        (replace-region-contents l0 l1 (lambda () (funcall fn s)))
        (forward-line)))))

;;;###autoload
(defun buffer-generate (name &optional unique inhibit-buffer-hooks)
  "Create and return a buffer with a name based on NAME.
  Unless UNIQUE, choose the buffer’s name using
  ‘generate-new-buffer-name’. Otherwise if buffer with NAME already
  exists, recreate it.
  See ‘get-buffer-create’ for the meaning of INHIBIT-BUFFER-HOOKS."
  (when unique
    (when-let ((buffer (get-buffer name)))
      (kill-buffer buffer)))
  (generate-new-buffer name inhibit-buffer-hooks))

(provide 'lib-buffer)
;;; lib-buffer.el ends here

#+end_src
** Emacs Windows
:PROPERTIES:
:header-args: :tangle lisp/init-window.el :noweb yes
:ID:       dff15b7b-84eb-4992-b32f-716a3b47c36a
:END:

windose

#+begin_src emacs-lisp
;;; init-window.el --- Windose -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<windose>>

(provide 'init-window)
;;; init-window.el ends here
#+end_src
** Projects
:PROPERTIES:
:header-args: :tangle lisp/init-project.el :noweb yes
:END:
Setup projects

#+begin_src emacs-lisp
;;; init-project.el --- Projects -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(require 'lib-eval)
(require 'config-path)
(require 'init-vcs)
(require 'init-kbd)
(require 'project)

<<projet>>

(provide 'init-project)
;;; init-project.el ends here
#+end_src
** VCS
:PROPERTIES:
:header-args: :tangle lisp/init-vcs.el :noweb yes
:END:

Setup Magit & Git

#+begin_src emacs-lisp
;;; init-vcs.el --- Magit  -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

;;(require 'lib-hook)
(require 'config-path)
(require 'init-elpa)

<<vcs>>

(provide 'init-vcs)
;;; init-vcs.el ends here
#+end_src
** Notes tangle
:PROPERTIES:
:header-args: :tangle lisp/init-notes.el :noweb yes
:END:
Setup org-mode for Note taking

#+begin_src emacs-lisp
;;; init-notes.el --- Org Notetaking Workflow -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:
(require 'config-path)
(require 'init-elpa)
(require 'init-env)

(require 'config-orgmode)

(defconst *notes/*
  (file-name-as-directory (expand-file-name "~/org")))

<<org-defaults>>

<<org-agenda>>

(provide 'init-notes)
;;; init-notes.el ends here
#+end_src

** Coding
Setup Coding languages

*** LISP setup
:properties:
:header-args: :tangle lisp/init-lisp.el :noweb yes
:ID:       e285fd8e-e55c-4b82-bc3a-e42634c4b6b2
:end:
LISP Common setup here
#+begin_src emacs-lisp
  ;;; init-lisp.el --- Code LISP -*- lexical-binding: t -*-
<<disclaimer>>
  ;;; Code:

<<lisp-ide>>

(provide 'init-lisp)
   ;;; init-lisp.el ends here
#+end_src

*** Eval lib
:PROPERTIES:
:header-args: :tangle lisp/lib-eval.el :noweb yes
:ID:       2aad25fa-9a36-4484-b2a6-4397d836773c
:END:
Smartparens setup here
#+begin_src emacs-lisp
;;; lib-eval.el --- Eval utilities -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:
(defmacro eval-with-default-dir (dir &rest body)
  "Invoke in DIR the BODY."
  (declare (debug t) (indent 1))
  `(let ((default-directory ,dir))
     ,@body))

(cl-flet ((always-yes (&rest _) t))
  (defun eval-no-confirm (fun &rest args)
    "Apply FUN to ARGS, skipping user confirmations."
    (cl-letf (((symbol-function 'y-or-n-p) #'always-yes)
              ((symbol-function 'yes-or-no-p) #'always-yes))
      (apply fun args))))

(provide 'lib-eval)
;;; lib-eval.el ends here
#+end_src
*** Common LISP setup
:PROPERTIES:
:header-args: :tangle lisp/init-clisp.el :noweb yes
:ID:       7c6c8865-ce5d-4b09-ac24-81cff979efb1
:END:
#+begin_src emacs-lisp
;;; init-clisp.el --- Common-LISP -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<code-common-lisp>>

(provide 'init-clisp)
;;; init-clisp.el ends here
#+end_src
** Communications
:PROPERTIES:
:header-args: :tangle lisp/init-telega.el :noweb yes
:ID:       2b35cb3e-c354-4899-96f6-d16d8097f7ac
:END:

*** Telega setup

#+begin_src emacs-lisp
  ;;; init-telega.el --- personal configuration -*- lexical-binding: t -*-
(require 'init-elpa)
(require 'init-kbd)

(use-package telega
  :straight (telega
             :type git
             :host github
             :repo "zevlg/telega.el"
             :branch "releases"
             :files (:defaults "contrib" "etc" "server" "Makefile"))
  :defer t
  :hook ((telega-chat-mode . ui-reset-line-spacing)
         (telega-chat-mode . editor-disable-electric-pair))
  :general
  (leader-def
   "t" '(:keymap telega-prefix-map))
  :init
  (when elpa-bootstrap-p
    (require 'telega-server)
    (require 'lib-nix)
    (let ((exec-path (cons telega-directory exec-path))
          (default-directory telega--lib-directory))
      (unless (executable-find "telega-server")
        (nix-shell-command
         :message-intro "building telega-server..."
         :message-error "Failed to build telega-server"
         :deps '("pkg-config" "tdlib")
         :command (concat
                   (or (executable-find "gmake")
                       "make")
                   " "
                   "LIBS_PREFIX="
                   (expand-file-name telega-server-libs-prefix) " "
                   "INSTALL_PREFIX="
                   (expand-file-name telega-directory) " "
                   "server-reinstall"))))))
#+end_src


*** Compatibility Utilities
:PROPERTIES:
:header-args: :tangle lisp/lib-compat.el :noweb yes
:ID:       3cae4486-262c-4e62-bb92-645abbe5ddc6
:END:

#+begin_src emacs-lisp
  ;;; lib-compat.el --- Compatibility utilities  -*- lexical-binding: t -*-
<<disclaimer>>
    ;;; Code:

  ;;;###autoload
(defun cl--plist-remove (plist member)
  "Remove MEMBER from PLIST.
  `telega' needs this function."
  (cond
   ((null plist) nil)
   ((null member) plist)
   ((eq plist member) (cddr plist))
   (t `(,(car plist) ,(cadr plist)
        ,@(cl--plist-remove (cddr plist) member)))))

    ;;; SYSTEM-DEPENDENT SETTINGS
;; at home
(eval-and-compile
  (when (memq system-type '(gnu gnu/linux darwin))
    <<linux-specific>>
    ))

;; at work
(eval-and-compile
  (when (memq system-type '(ms-dos windows-nt))
    <<windows-specific>>
    ))

(provide 'lib-compat)
  ;;; lib-compat.el ends here
#+end_src
*** Ease of editing
:PROPERTIES:
:header-args: :tangle no
:ID:       de45708b-cfcc-4add-a59b-8cbc64b4f85e
:END:

#+begin_src emacs-lisp :noweb-ref functions
(defun enfer/find-config ()
  "Find `config.org'."
  (interactive)
  (find-file (locate-user-emacs-file "config.org")))
#+end_src

Bind it to =C-z i= because =C-z C-c= is taken for capture.

#+begin_src emacs-lisp :noweb-ref bindings
;;(define-key acdw/leader (kbd "i") #'acdw/find-config)
#+end_src

*** Ease of reloading
:PROPERTIES:
:header-args: :tangle no
:END:

#+begin_src emacs-lisp :noweb-ref functions
(defun acdw/reload ()
  "Tangle and reload Emacs configuration."
  (interactive)
  (let ((config (locate-user-emacs-file "config.org")))
    ;; tangle
    (with-current-buffer (find-file-noselect config)
      (message "Tangling config.org...")
      (let ((prog-mode-hook nil)
            (inhibit-redisplay t)
            (inhibit-message t))
        (add-to-list 'load-path (locate-user-emacs-file
                                 "straight/build/org/"))
        (require 'org)
        (org-babel-tangle)))
    (message "Tangling config.org... Done.")
    ;; load init files
    (load (locate-user-emacs-file "early-init.el"))
    (load (locate-user-emacs-file "init.el"))
    ;;(load (locate-user-emacs-file "config.el"))
    ))
#+end_src

#+begin_src emacs-lisp :noweb-ref bindings
(define-key acdw/leader (kbd "C-M-r") #'acdw/reload)
#+end_src

** Libraries & Config
*** String
:PROPERTIES:
:header-args: :tangle lisp/lib-string.el :noweb yes
:ID:       c636d0e2-9f57-4e6b-bb90-12cf537f603f
:END:
#+begin_src emacs-lisp
;;; lib-string.el --- String Utilities -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(require 'init-elpa)
(require 's)

;;;###autoload
(defun string-match-1 (regexp val)
  "Get the first group from REGEXP match of the VAL.
  VAL can be either a string or a region (beg . end) of the
  buffer."
  (string-match-n 1 regexp val))

;;;###autoload
(defun string-match-n (n regexp val)
  "Get the Nth group from REGEXP match of the VAL.
  VAL can be either a string or a region (beg . end) of the
  buffer."
  (let ((s (if (stringp val)
               val
             (buffer-substring (car val) (cdr val)))))
    (string-match regexp s)
    (match-string n s)))

;;;###autoload
(defun string-join-g (strs sep)
  "Join a list of STRS using SEP."
  (pcase strs
    (`nil "")
    (`(,str) str)
    (_ (mapconcat #'identity strs sep))))

;;;###autoload
(defun string-chop-prefix-regexp (prefix s)
  "Remove PREFIX regexp if it is at the start of S."
  (s-chop-prefix (car (s-match prefix s)) s))

;;;###autoload
(defun string-chop-suffix-regexp (suffix s)
  "Remove SUFFIX regexp if it is at the end of S."
  (s-chop-suffix (car (s-match suffix s)) s))

(defvar string-http-url-regexp
  "\\(https?://.*\\)"
  "HTTP(s) URL regexp.")

(defvar string-uuid-regexp
  (concat
   "\\("
   "[a-zA-Z0-9]\\{8\\}"
   "-"
   "[a-zA-Z0-9]\\{4\\}"
   "-"
   "[a-zA-Z0-9]\\{4\\}"
   "-"
   "[a-zA-Z0-9]\\{4\\}"
   "-"
   "[a-zA-Z0-9]\\{12\\}"
   "\\)")
  "UUID regexp.")

(defun string-from (value)
  "Convert VALUE to string."
  (cond
   ((stringp value) value)
   ((numberp value) (number-to-string value))
   ((symbolp value) (symbol-name value))
   (t (user-error
       "Unsupported type of \"%s\"" value))))

(cl-defun string-table (&key data
                             pad-type
                             pad-str
                             sep
                             row-start
                             row-end)
  "Format DATA as a table.
  DATA is list of lists. Each column is aligned by padding with
  PAD-STR either on left or right depending on value of PAD-TYPE.
  Each row begins with ROW-START and ends with ROW-END. Each value
  in row is separated by SEP."
  (let* ((widths (seq-reduce
                  (lambda (r v)
                    (seq-map-indexed
                     (lambda (a i)
                       (max
                        (length (string-from a))
                        (or (nth i r)
                            0)))
                     v))
                  data
                  nil))
         (pad-fn (pcase (or pad-type 'left)
                   (`left #'s-pad-left)
                   (`right #'s-pad-right)))
         (pad-str (or pad-str " "))
         (row-start (or row-start ""))
         (row-end (or row-end ""))
         (sep (or sep " ")))
    (seq-reduce
     (lambda (r v)
       (concat
        r
        row-start
        (string-join
         (seq-map-indexed
          (lambda (a i)
            (funcall pad-fn
                     (nth i widths)
                     pad-str
                     (string-from a)))
          v)
         sep)
        row-end
        "\n"))
     data
     "")))

(provide 'lib-string)
;;; lib-string.el ends here
#+end_src
*** Orgmode config
:PROPERTIES:
:header-args: :tangle lisp/config-orgmode.el :noweb yes
:ID:       7df49a2c-aad7-472a-a186-c8db756aeb44
:END:
#+begin_src emacs-lisp
;;; config-orgmode.el --- Org-mode Directory -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:
(require 'config-path)

(defconst *notes/*
  (file-name-as-directory (expand-file-name "~/org")))

(provide 'config-orgmode)
;;; config-orgmode.el ends here
#+end_src
*** function lib
:PROPERTIES:
:header-args: :tangle lisp/lib-fun.el :noweb yes
:ID:       70df19e8-852a-472f-8d78-d24d1d45dd06
:END:
#+begin_src emacs-lisp
;;; lib-fun.el --- Extra function -*- lexical-binding: t -*-
<<disclaimer>>
;; Utilities to build functions.
;;
;;; Code:

;;;###autoload
(defun fun-unquote (exp)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

;;;###autoload
(defun fun-collect-while (fn filter &rest args)
  "Repeat FN and collect it's results until `C-g` is used.
Repeat cycle stops when `C-g` is used or FILTER returns nil.
If FILTER is nil, it does not affect repeat cycle.
If FILTER returns nil, the computed value is not added to result.
ARGS are passed to FN."
  (let (result
        value
        (continue t)
        (inhibit-quit t))
    (with-local-quit
      (while continue
        (setq value (apply fn args))
        (if (and filter
                 (null (funcall filter value)))
            (setq continue nil)
          (setq result (cons value result)))))
    (setq quit-flag nil)
    (seq-reverse result)))

;;;###autoload
(defun fun-repeat-while (fn filter &rest args)
  "Repeat FN and return the first unfiltered result.
Repeat cycle stops when `C-g` is used or FILTER returns nil.
ARGS are passed to FN."
  (let (value
        (continue t)
        (inhibit-quit t))
    (with-local-quit
      (while continue
        (setq value (apply fn args))
        (when (null (funcall filter value))
          (setq continue nil))))
    (setq quit-flag nil)
    (when (null continue)
      value)))

;;;###autoload
(defun fun-noop (&rest _)
  "Do nothing.
Useful for temporarily disabling a function.")

(provide 'lib-fun)
;;; lib-fun.el ends here
#+end_src
*** VCS
:PROPERTIES:
:header-args: :tangle lisp/lib-vcs.el :noweb yes
:ID:       05d0ed58-40b0-49a0-829b-7436db557594
:END:
#+begin_src emacs-lisp
;;; lib-vcs.el --- Librray -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(require 'init-kbd)



(defvar vcs-url-github-issue-regexp
  (format "\\(%s/\\(%s\\)/\\(%s\\)/\\(%s\\)/\\(%s\\)\\).*"
          "https://github\\.com"
          "[-\\.[:alnum:]]+"
          "[-\\.[:alnum:]]+"
          "[[:alpha:]]+"
          "[[:alnum:]]+")
  "GitHub issue/pull URL regexp.
- 1st group is whole URL.
- 2nd group is owner.
- 3rd group is repository name.
- 4th group is type of the object - issue/pull/miliestone/commit.
- 5th group is the number of the object.")

(defvar vcs-url-github-project-regexp
  (format "\\(%s/\\(%s\\)/\\(%s\\)/?\\)"
          "https://github\\.com"
          "[-\\.[:alnum:]]+"
          "[-\\.[:alnum:]]+")
  "GitHub project URL regexp.
- 1st group is whole URL.
- 2nd group is owner.
- 3rd group is repository name.")

(defvar vcs-url-known-github-users '("frap"
                                     "agasson")
  "List of 'known' GitHub users.")



;;;###autoload
(defun vcs-url-format-github-issue (owner repo type number)
  "Format GitHub issue.
Depending on the TYPE format can be one of the following:
- OWNER/REPO#NUMBER if TYPE is not milestone;
- OWNER/REPOmNUMBER otherwise.
In case OWNER is a member of `vcs-url-known-github-users', then OWNER
part of format is omitted."
  (concat
   (if (seq-contains-p vcs-url-known-github-users owner)
       repo
     (concat owner "/" repo))
   (if (string-equal type "milestone")
       "m"
     "#")
   (if (string-equal type "commit")
       (substring number 0 (min 7 (length number)))
     number)))

;;;###autoload
(defun vcs-url-format-github-project (owner repo)
  "Format GitHub REPO.
In case OWNER is a member of `vcs-url-known-github-users', then OWNER
part of format is omitted."
  (concat
   (if (seq-contains-p vcs-url-known-github-users owner)
       repo
     (concat owner "/" repo))))

(provide 'lib-vcs)
  ;;; lib-vcs.el ends here
#+end_src

*** File Templates aka YASnippet
:PROPERTIES:
:header-args: :tangle lisp/init-file-templates.el :noweb yes
:ID:       68ae83b4-14d3-4eb7-9c99-fd05cb6d9053
:END:
#+begin_src emacs-lisp
;;; init-file-templates.el --- File templates support -*- lexical-binding: t; -*-
<<disclaimer>>
;; Commentary:
;;
;; This module configures yasnippet.
;;
;;; Code:

(require 'init-project)

<<templates>>

(provide 'init-file-templates)
;;; init-file-templates.el ends here
#+end_src

*** Dash-functional fixup
:PROPERTIES:
:header-args: :tangle lisp/dash-functional.el :noweb yes
:ID:       5c50f26c-4d6f-4030-a94f-c2c5c0729585
:END:
#+begin_src emacs-lisp
  ;;; dash-functional.el --- Mocking dash-functional -*- lexical-binding: t; -*-
<<disclaimer>>
  ;;; Commentary:
;;
;; Unfortunately, dash-functional is obsolete. And instead of talking
;; to popular libraries, they simply put a warning inside this
;; package, meaning that people treating warnings as errors have no
;; way to load this module (even transitively).
;;
;; Thanks, folks! I really appreciate it.
;;
;; So this module is a fake to avoid byte compilation error.
;;
;;; Code:

(require 'dash)

(provide 'dash-functional)
;;; dash-functional.el ends here
#+end_src

** License
:PROPERTIES:
:header-args: :tangle LICENSE
:ID:       544ee924-beef-403c-b654-6fc255528de9
:END:

Copyright © 2023 Gas <gas@somewhere.red>

This work is free.  You can redistribute it and/or modify it under the
terms of the Do What the Fuck You Want To Public License, Version 2,
as published by Gas.  See the =LICENSE= file, tangled from the
following source block, for details.

#+begin_src text
DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE

Version 2, December 2004

Copyright (C) 2001-2023 Gas <gas@somewhere.red>

Everyone is permitted to copy and distribute verbatim or modified copies of
this license document, and changing it is allowed as long as the name is changed.

DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE

TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

0. You just DO WHAT THE FUCK YOU WANT TO.
#+end_src
***
