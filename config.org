#+title: Literate Roam Clojure Emacs Config
#+author: gas
#+startup: overview
#+property: header-args :cache yes :results output :mkdirp yes :padline no
#+auto_tangle: yes

* About me
Some scripts to setup whether I am on work computer or not
#+begin_src emacs-lisp :noweb-ref user-config
(if (getenv "USER")
     (defconst IS-WORK (string-match "WindoseUserName" (getenv "USER")))
     (defconst IS-WORK nil))

(if IS-WORK
    (setq
     user-full-name "Andrew Gasson"
     user-mail-address "gasson@somecompany.nz")
  (setq
   user-full-name "Andrés Gasson"
   user-mail-address "gas@tuatara.red"
   github-account-name "frap")
  )

#+end_src
** Where am I?
#+begin_src emacs-lisp :noweb-ref user-config
(setq calendar-location-name "Wellington, NZ"
      calendar-latitude -41.28
      calendar-longitude 174.78)

#+end_src

** Auth-sources
Here feels like as good a place as any to setup =auth-sources=.

#+begin_src emacs-lisp :noweb-ref user-config
(setq-default auth-sources (expand-file-name "authinfo.gpg" *xdg-state/* )
              auth-source-cache-expiry nil) ; default is 7200 (2h)

#+end_src
** init-usersetup tangle
:PROPERTIES:
:header-args: :tangle lisp/init-usersetup.el :noweb yes
:END:

#+begin_src emacs-lisp
;;; init-usersetup.el --- User Setup -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<user-config>>

(provide 'init-usersetup)
;;; init-usersetup.el ends here
#+end_src
* Emacs Startup

** Path & Directories
:PROPERTIES:
:header-args: :noweb-ref path-config
:end:
Need to setup some constants and try to keep state in a "clean" directory structure
#+begin_src emacs-lisp
  ;; For the rest of the Emacs configuration, set this directory to something
  ;; inside the standard cache directory, so we do not pollute our emacs.d
  ;; directory with files that we would then have to ignore with Git.
  (defconst *emacs-config/* user-emacs-directory)

  (defconst *gas-lisp/*
             (expand-file-name "lisp/" *emacs-config/*))

  (defconst *xdg-cache/* (or (getenv "XDG_CACHE_HOME") "~/.cache/"))

  (defconst *xdg-state/* (or (getenv "XDG_STATE_HOME") "~/.local/state/"))

  (defconst *emacs-cache/*
	 (expand-file-name "emacs/" *xdg-cache/* )
     "Directory for Emacs volatile storage.
   Use this for files that change often.")

  (defconst *emacs-autoloads-file*
      (expand-file-name "lisp/init-autoloads.el" *emacs-config/* )
      "The path to my personal autoloads file.")

  (defconst *emacs-etc/* (concat *emacs-cache/* "etc/")
	"Directory for non-volatile storage.
      Use this for files that don't change much, like servers binaries,
      external dependencies or long-term shared data.")

  ;; For the rest of the Emacs configuration, set this directory to something
  ;; inside the standard cache directory, so we do not pollute our emacs.d
  ;; directory with files that we would then have to ignore with Git.
  (setq user-emacs-directory *emacs-cache/*)

#+end_src
** native Compilation for >= Emacs28
setting some compliation default settings on early-init
#+begin_src emacs-lisp
;; For the list of native compilation ELN cache directories, delete all but the
;; last element, which is always assumed to be the system path, and then cons a
;; new path in our cache directory to the front. This effectively removes the
;; entry for the original ~/.emacs.d/eln-cache/ and any others that are
;; unwanted.
(when (featurep 'native-compile)
  (setq native-comp-eln-load-path
         (cons (expand-file-name "eln-cache/" *emacs-cache/* )
               (last native-comp-eln-load-path)))
  (defvar native-comp-deferred-compilation)
  (setq native-comp-deferred-compilation t)
  (defvar native-comp-async-report-warnings-errors)
  (setq native-comp-async-report-warnings-errors nil))
#+end_src
** Garbage Collection & File handlers
:PROPERTIES:
:header-args: :noweb-ref garbage-filehandler
:END:
Make startup faster by reducing the frequency of garbage collection and then use a hook to measure Emacs startup time.

#+begin_src emacs-lisp
;; Garbage collection slows down startup time, so we maximise the threshold for
;; it to run, and we will later reset it.
(let ((normal-gc-cons-threshold (* 20 1024 1024))  ;; 20mb
      (init-gc-cons-threshold (* 128 1024 1024)))    ;;128mb
  (setq gc-cons-threshold init-gc-cons-threshold)
  (add-hook 'emacs-startup-hook
            (lambda () (setq gc-cons-threshold
                             normal-gc-cons-threshold))))
;;(setq gc-cons-threshold most-positive-fixnum)

;; file-name-handler-alist is consulted on various I/O functions such as
;; REQUIRE, slowing down startup time, so we set it to NIL, and establish a hook
;; to restore when Emacs is finished starting.
(unless (or (daemonp) noninteractive)
  (let ((file-name-handler-alist/old file-name-handler-alist))
    (setq file-name-handler-alist nil)
    (add-hook 'emacs-startup-hook
              (lambda ()
                (let ((value (delete-dups
                              (append file-name-handler-alist
                                      file-name-handler-alist/old))))
                  (setq file-name-handler-alist value))))))

(unless (daemonp)
  (advice-add #'tty-run-terminal-initialization :override #'ignore)
  (add-hook 'window-setup-hook
            (lambda ()
              (advice-remove #'tty-run-terminal-initialization #'ignore)
              (tty-run-terminal-initialization (selected-frame) nil t))))

#+end_src
** Initial frame setup
:PROPERTIES:
:header-args: :noweb-ref early-init-frame
:ID:                     0ae373ff-ee6b-484d-9d03-99ce56f59dc8
:END:

I don't want the frame to resize when I change fonts and stuff, and I
want it to resize by pixels -- we /are/ using a GUI, after all.

*** Frame use pixel resize
:PROPERTIES:
:ID:                     d054c73f-121a-4155-964e-c4c3d7f1d2ce
:END:

#+begin_src emacs-lisp
(setq-default
 initial-frame-alist '((width . 170)
                       (height . 56)
                       (tool-bar-lines . 0)
                       (bottom-divider-width . 0)
                       (right-divider-width . 1)
                       (font . "Iosevka Slab 14"))
 default-frame-alist initial-frame-alist
 frame-inhibit-implied-resize t            ;; dont resize
 frame-resize-pixelwise t                  ;; as GUI use pixels
 x-gtk-resize-child-frames 'resize-mode
 fringe-indicator-alist (assq-delete-all 'truncation fringe-indicator-alist))

 (setq truncate-partial-width-windows nil)

#+end_src
 some stuff left off initial-frame-list
  (blink-cursor-mode 0)
  (column-number-mode 1)
  (display-time-mode 0)
  (fringe-mode '(4 . 0))
  (tooltip-mode 0)
  (window-divider-mode 1)

*** Turn off Tool bar
#+begin_src emacs-lisp
(when (fboundp #'tool-bar-mode)
  (tool-bar-mode -1))

#+end_src

*** Turn off Scroll bars
#+begin_src emacs-lisp
(when (fboundp #'scroll-bar-mode)
  (scroll-bar-mode -1))

#+end_src

** early-init.el tangle
:PROPERTIES:
:header-args: :tangle early-init.el :noweb yes
:END:
Beginning with 27.1, Emacs also loads an =early-init.el= file, before
the package manager or the UI code.

#+begin_src emacs-lisp
;;; early-init.el --- Early Customisations -*- lexical-binding: t; no-byte-compile: t; -*-
<<disclaimer>>
;;
;;; Code:

(message "Chargement en cours early-init.el...")

(define-advice load (:before (feature &rest _))
    "Message the user when loading a library."
    (with-temp-message (format "En cours de chargement de la bibliothèque: '%s'" feature)))

;;; ============================================================================
;;; Turn off Emacs "package" manager
;;; ============================================================================
<<turnoff-package>>

;;; ============================================================================
;;; Emacs startup optimisations
;;; ============================================================================
<<garbage-filehandler>>

;;; ============================================================================
;;; Frame parameters for faster startup
;;; ============================================================================
<<early-init-frame>>

(message "Chargement du early-init.el terminé!")
(provide 'early-init)
;;; early-init.el ends here
#+end_src

** init.el tangle
:PROPERTIES:
:header-args: :tangle init.el :noweb yes
:END:
The goal of this file is to require all init-xxx files. The structure is trivial:

- Add lisp folder to load-path, so we can use require.
- Adjust garbage collection thresholds, so things run smoother.
- Load config-path declaring various path constants.
- Load init-elpa which ‘bootstraps’ your package and configuration management tools.
- Load autoloads file.
- Load all other init-xxx files.
- Load custom-file, even if you are not using customize interface, you need this to use .dir-locals.el.

#+begin_src emacs-lisp
;;; init.el --- Gas Emacs Init -*- lexical-binding: t -*-
<<disclaimer>>

;;; Code:

(require 'subr-x)
;;; Bootstrap
;;; Set up extra load paths and functionality
;; Add our custom lisp modules to the Emacs load path so they can be discovered.
(push (expand-file-name "lisp/" (file-name-directory user-init-file)) load-path)
;;; ============================================================================
;;; Specify the directory paths
;;; ============================================================================
(require 'config-path)

;;; ============================================================================
;;; Set up the package manager
;;; ============================================================================
(require 'init-elpa)
(require 'init-corgi)

;; load autoloads file
(unless elpa-bootstrap-p
  (unless (file-exists-p *emacs-autoloads-file*)
    (error "Le fichier autoloads n'existe pas, veuillez exécuter '%s'"
           "eru install emacs"))
  (load *emacs-autoloads-file* nil 'nomessage))
#+end_src

#+begin_src emacs-lisp
;;; core
(require 'init-env)
(require 'init-kbd)
(require 'init-startup)
(require 'lib-fn-macros)
(require 'init-editor)
;;(require 'init-ui)
;;(require 'init-buffer)
;;(require 'init-window)
;;; utilities
;;(require 'init-selection)
(require 'init-project)
(require 'init-vcs)
;;(require 'enfer-pkg-builtin)

;; Org Note Taking
(require 'init-notes)
(require 'init-file-templates)

;;; languages
;;(require 'init-ide)
;;(require 'init-lisp)
;;(require 'init-elisp)
;;(require 'init-clisp)
;;(require 'init-clojure)
(require 'init-fennel)
;;(require 'init-ess)
;;(require 'init-utils)

;;; user config & some defaults
(require 'init-usersetup)
;;(require 'init-sanity)

;; I don't use `customize' interface, but .dir-locals.el put 'safe'
;; variables into `custom-file'. And to be honest, I hate to allow
;; them every time I restart Emacs.
(when (file-exists-p custom-file)
  (load custom-file nil 'nomessage))

(provide 'init)
;;; init.el ends here
#+end_src
*** Load the config -disabled
:PROPERTIES:
:ID:                     a40cbe30-7947-492b-a365-5dbba82a37a4
:END:

I keep most of my config in =config.el=, which is tangled directly from
this file.  This init just loads that file, either from lisp
or directly from Org if it's newer.  /Note/ the longish comment before
the =unless= form -- it was pretty tough for me to wrap my head around
the needed boolean expression to tangle config.org.  Booleans, yall!

#+begin_src emacs-lisp :tangle no
  (let* (;; Speed up init
        ;; (gc-cons-threshold most-positive-fixnum)
         ;; (gc-cons-percentage 0.6)
         ;;(file-name-handler-alist nil)
         ;; Config file names
         (config (expand-file-name "config"
                                   user-emacs-directory))
         (config.el (concat config ".el"))
         (config.org (concat config ".org"))
         (straight-org-dir (locate-user-emacs-file "straight/build/org")))
    ;; Okay, let's figure this out.
    ;; `and' evaluates each form, and returns nil on the first that
    ;; returns nil.  `unless' only executes its body if the test
    ;; returns nil.  So.
    ;; 1. Test if config.org is newer than config.el.  If it is (t), we
    ;;    *want* to evaluate the body, so we need to negate that test.
    ;; 2. Try to load the config.  If it errors (nil), it'll bubble that
    ;;    to the `and' and the body will be evaluated.
    (unless (and (not (file-newer-than-file-p config.org config.el))
                 (load config :noerror))
      ;; A plain require here just loads the older `org'
      ;; in Emacs' install dir.  We need to add the newer
      ;; one to the `load-path', hopefully that's all.
      (when (file-exists-p straight-org-dir)
        (add-to-list 'load-path straight-org-dir))
      ;; Load config.org
      (require 'org)
      (org-babel-load-file config.org)))

  ;;; init.el ends here
#+end_src


* Emacs Package Management
** Turn of legacy Emacs "package" Manager
#+begin_src emacs-lisp :noweb-ref turnoff-package
;; Pre-configure the package manager settings before it is loaded.
(setq package-enable-at-startup nil)
(setq package-quickstart nil)
#+end_src
** Straight Bootstrap
:PROPERTIES:
:header-args: :noweb-ref straight-setup
:END:
Use Straight for package Management.
#+begin_src emacs-lisp
  ;; Install the Straight package manager
  (defvar elpa-bootstrap-p nil)

  ;; keep this line here to shorten emacs-init-time
  ;;(setq straight-check-for-modifications '(check-on-save find-when-checking))

  (defvar bootstrap-version)

  (let ((install-url "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el")
	(bootstrap-file (expand-file-name "straight/repos/straight.el/bootstrap.el" *emacs-cache/* ))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer (url-retrieve-synchronously install-url 'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; Install the use-package convenience macro
  (straight-use-package 'use-package)

  ;; using use-package to configure straight
  (use-package straight
    :custom
    (straight-use-package-by-default t)
    (straight-base-dir *emacs-cache/* )
    :config
    (setq straight-use-package-by-default t)

    (setq straight-vc-git-default-clone-depth '(1 single-branch))  ;; instead of the default 'full
    (setq use-package-verbose t) ;; use 't' to see execution profile at startup
    (setq straight-profiles `((nil . ,(expand-file-name "lockfile" *emacs-cache/* ))))

    ;; Additional post-setup of straight.el.
    ;;(require 'straight-x)
;;; Appendix
    ;; Get rid of a dumb alias.  straight-ಠ_ಠ-mode really slows down all
    ;; minibuffer completion functions.  Since it's a (rarely-used, even)
    ;; alias anyway, I just define it back to nil.  By the way, the alias
    ;; is `straight-package-neutering-mode'.
    (defalias 'straight-ಠ_ಠ-mode nil)
    )

#+end_src
** Setup (no pun intended) the Emacs Package Manager
:PROPERTIES:
:header-args: :noweb-ref setup-setup
:END:
Using [[https://www.emacswiki.org/emacs/SetupEl][setup.el]] by pkal to manage packages as well as use-package for copied config
#+begin_src emacs-lisp
;; install setup
(straight-use-package '(setup :type git :host nil :repo "https://git.sr.ht/~pkal/setup"))

(require 'setup)

(defmacro define-setup-macro (name signature &rest body)
 "Shorthand for 'setup-define'. NAME is the name of the local macro. SIGNATURE
   is used as the argument list for FN. If BODY starts with a string, use this as
   the value for :documentation. Any following keywords are passed as OPTS to
     'setup-define'."
  (declare (debug defun))
  (let (opts)
    (when (stringp (car body))
      (setq opts (nconc (list :documentation (pop body)) opts)))
    (while (keywordp (car body))
      (let ((prop (pop body))
            (val `',(pop body)))
        (setq opts (nconc (list prop val) opts))))
    `(setup-define ,name
       (cl-function (lambda ,signature ,@body))
       ,@opts)))

(define-setup-macro :pkg (recipe)
  "Install RECIPE with 'straight-use-package'. This macro can be used as HEAD,
      and will replace itself with the first RECIPE's package."
  :repeatable t
  :shorthand (lambda (sexp)
               (let ((recipe (cadr sexp)))
                 (if (consp recipe)
                     (car recipe)
                   recipe)))
  `(straight-use-package ',recipe))

(defun +setup-warn (message &rest args)
  "Warn the user that something bad happened in `setup'."
  (display-warning 'setup (format message args)))

(setup-define :face
  (lambda (face spec)
    `(custom-set-faces '(,face ,spec 'now "Customised by `setup'.")))
  :documentation "Customise FACE with SPEC using `custom-set-faces'."
  :repeatable t)

(setup-define :pkg-when
  (lambda (recipe condition)
    `(if ,condition
         (straight-use-package ',recipe)
       ,(setup-quit)))
  :documentation
  "Install RECIPE with `straight-use-package' when CONDITION is met.
    If CONDITION is false, stop evaluating the body.  This macro can
    be used as HEAD, and will replace itself with the RECIPE's
    package.  This macro is not repeatable."
  :repeatable nil
  :indent 1
  :shorthand (lambda (sexp)
               (let ((recipe (cadr sexp)))
                 (if (consp recipe) (car recipe) recipe))))

(define-setup-macro :hide-mode (&optional mode)
  "Hide the mode-line lighter of the current mode. Alternatively, MODE can be
      specified manually, and override the current mode."
  :after-loaded t
  (let ((mode (or mode (setup-get 'mode))))
    `(progn
       (setq minor-mode-alist
             (remq (assq ',(intern (format "%s-mode" mode)) minor-mode-alist)
                   minor-mode-alist))
       (setq minor-mode-alist
             (remq (assq ',mode minor-mode-alist)
                   minor-mode-alist)))))

(define-setup-macro :load-after (features &rest body)
  "Load the current feature after FEATURES."
  :indent 1
  (let ((body `(progn
                 (require ',(setup-get 'feature))
                 ,@body)))
    (dolist (feature (nreverse (doom-enlist features)))
      (setq body `(with-eval-after-load ',feature ,body)))
    body))

(define-setup-macro :with-after (features &rest body)
  "Evaluate BODY after FEATURES are loaded."
  :indent 1
  (let ((body `(progn ,@body)))
    (dolist (feature (nreverse (ensure-list features)))
      (setq body `(with-eval-after-load ',feature ,body)))
    body))

(define-setup-macro :with-state (state &rest body)
  "Change the evil STATE that BODY will bind to. If STATE is a list, apply BODY
     to all elements of STATE. This is intended to be used with ':bind'."
  :indent 1
  :debug '(sexp setup)
  (let (bodies)
    (dolist (state (ensure-list state))
      (push (let ((setup-opts (cons `(state . ,state) setup-opts)))
              (setup-expand body))
            bodies))
    (macroexp-progn (nreverse bodies))))

(define-setup-macro :bind (key command)
  "Bind KEY to COMMAND in current map, and optionally for current evil states."
  :after-loaded t
  :debug '(form sexp)
  :repeatable t
  (let* ((state (cdr (assq 'state setup-opts)))
         (map (setup-get 'map))
         (map (if (eq map 'global-mode-map) 'global-map map))
         (key (setup-ensure-kbd key))
         (command (setup-ensure-function command)))
    (if state
        `(with-eval-after-load 'evil
           (evil-define-key* ',state ,map ,key ,command))
      `(define-key ,map ,key ,command))))

(define-setup-macro :disable ()
  "Unconditionally abort the evaluation of the current body."
  (setup-quit))

(define-setup-macro :delay (seconds)
  "Require the current FEATURE after SECONDS of idle time."
  :indent 1
  `(run-with-idle-timer ,seconds nil #'require ',(setup-get 'feature) nil t))

(define-setup-macro :with-idle-delay (seconds &rest body)
  "Evaluate BODY after SECONDS of idle time."
  :indent 1
  `(run-with-idle-timer ,seconds nil (lambda () ,@body)))

(define-setup-macro :advise (symbol where arglist &rest body)
  "Add a piece of advice on a function. See 'advice-add' for more details."
  :after-loaded t
  :debug '(sexp sexp function-form)
  :indent 3
  (let ((name (gensym "setup-advice-")))
    `(progn
       (defun ,name ,arglist ,@body)
       (advice-add ',symbol ,where #',name))))

(setup-define :needs
  (lambda (executable)
    `(unless (executable-find ,executable)
       ,(setup-quit)))
  :documentation "If EXECUTABLE is not in the path, stop here."
  :repeatable 1)
#+end_src
Sometimes it's good to clean up unused repositories if I've removed packages from my configuration.
Use =straight-remove-unused-repos= for this purpose.

** Emacs Environment inherited from shell
:PROPERTIES:
:header-args: :noweb-ref environment
:END:
Setup the Emacs environment from the local env
#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  ;;:if *mac-os*
  :hook (emacs-startup . (lambda ()
			   (setq exec-path-from-shell-arguments '("-l")) ; removed the -i for faster startup
			   (exec-path-from-shell-initialize)))
  ;; :config
  ;; (exec-path-from-shell-copy-envs
  ;;  '("GOPATH" "GO111MODULE" "GOPROXY"
  ;;    "NPMBIN" "LC_ALL" "LANG" "LC_TYPE"
  ;;    "SSH_AGENT_PID" "SSH_AUTH_SOCK" "SHELL"
  ;;    "JAVA_HOME"))
  )

(defun doom-load-envvars-file (file &optional noerror)
"Read and set envvars from FILE.
  If NOERROR is non-nil, don't throw an error if the file doesn't exist or is
    unreadable. Returns the names of envvars that were changed."
  (if (null (file-exists-p file))
      (unless noerror
	(signal 'file-error (list "No envvar file exists" file)))
    (with-temp-buffer
      (insert-file-contents file)
      (when-let (env (read (current-buffer)))
	(let ((tz (getenv-internal "TZ")))
	  (setq-default
	   process-environment
	   (append env (default-value 'process-environment))
	   exec-path
	   (append (split-string (getenv "PATH") path-separator t)
		   (list exec-directory))
	   shell-file-name
	   (or (getenv "SHELL")
	       (default-value 'shell-file-name)))
	  (when-let (newtz (getenv-internal "TZ"))
	    (unless (equal tz newtz)
	      (set-time-zone-rule newtz))))
	env))))

;; (doom-load-envvars-file (expand-file-name "env" *emacs-cache/*))

#+end_src
*** Shell Environment init-env
:PROPERTIES:
:header-args: :tangle lisp/init-env.el :noweb yes
:END:
load environment for Emacs from shell

#+begin_src emacs-lisp
;;; init-env.el --- Setup Environment -*- lexical-binding: t -*-

<<disclaimer>>
;;
;;; Code:

<<environment>>

(provide 'init-env)
;;; init-env.el ends here
#+end_src
** init-elpa tangle
*** Straight and use-package
:PROPERTIES:
:header-args: :tangle lisp/init-elpa.el :noweb yes
:END:
"Setup" of setup.el the emacs package manager and package setup to replace use-package

#+begin_src emacs-lisp
;;; init-elpa.el --- Initialise ELPA & Straight -*- lexical-binding: t -*-
<<disclaimer>>
;;
;; Setup Emacs for installing packages from MELPA and Git
;; repositories. Enable configuration via `use-package.
;;; Code:

(require 'config-path)

<<straight-setup>>

(provide 'init-elpa)
;;; init-elpa.el ends here
#+end_src
* Emacs Sane Setup
** Constants
:PROPERTIES:
:ID:                     8e5d71f2-1d6b-4a25-843d-980894a67fac
:END:
Set Up Good Defaults. [[https://github.com/protesilaos][Protesilaos]] has a few utilities that he keeps re-using in various parts of my Emacs code base. To keep things modular, I place them all in a dedicated prot-common.el file, which can then be marked as a dependency by other libraries of mine. As such, all we do here is load the file.
#+begin_src emacs-lisp :noweb-ref constants
;;(setup (:require prot-common))

;;; Initialise Gas Constants
(defconst *is-nativecomp?* (if (fboundp 'native-comp-available-p) (native-comp-available-p)))
(defconst *is-gui?*        (display-graphic-p))
(defconst *is-mac?*        (eq system-type 'darwin))
(defconst *is-linux?*      (eq system-type 'gnu/linux))
(defconst *is-termux?*
    (string-suffix-p "Android" (string-trim (shell-command-to-string "uname -a"))))
(defconst *hostname* (system-name))

(defmacro fn (&rest body)
   `(lambda () ,@body))

(defun doom-enlist (exp)
  "Return EXP wrapped in a list, or as-is if already a list."
  (declare (pure t) (side-effect-free t))
    (if (proper-list-p exp) exp (list exp)))

#+end_src
** Sanity settings
:PROPERTIES:
:header-args: :noweb-ref sanity
:END:
Setup Scratch and minibuffer
#+begin_src emacs-lisp
(use-package subr
  :straight nil
  :no-require t
  :init
  (fset 'yes-or-no-p 'y-or-n-p))

(use-package delight)

(defun save-in-etc-file! (file-name)
  (expand-file-name (format "etc/%s" file-name) *emacs-cache/*))

(use-package emacs
  :init
  (setq read-process-output-max (* 1024 1024)) ;; 1mb

  ;; always allow 'y' instead of 'yes'.
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; default to utf-8 for all the things
  (set-charset-priority 'unicode)
  (setq locale-coding-system    'utf-8
	coding-system-for-read  'utf-8
	coding-system-for-write 'utf-8)
  (set-terminal-coding-system   'utf-8)
  (set-keyboard-coding-system   'utf-8)
  (set-selection-coding-system  'utf-8)
  (prefer-coding-system         'utf-8)
  (setq default-process-coding-system '(utf-8-unix . utf-8-unix))

  ;; write over selected text on input... like all modern editors do
  (delete-selection-mode t)

  ;; enable recent files mode.
  (recentf-mode t)
  (setq recentf-exclude `(,(expand-file-name "straight/build/" user-emacs-directory)
			  ,(expand-file-name "eln-cache/" user-emacs-directory)
			  ,(expand-file-name "etc/" user-emacs-directory)
			  ,(expand-file-name "var/" user-emacs-directory)))

  ;; don't want ESC as a modifier
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  ;; Don't persist a custom file, this bites me more than it helps
					;(setq custom-file (make-temp-file "")) ; use a temp file as a placeholder
  (setq custom-safe-themes t)            ; mark all themes as safe, since we can't persist now
  (setq enable-local-variables :all)     ; fix =defvar= warnings
  ;; Completely hide visual-line-mode and change auto-fill-mode to " AF".
  :delight
  (auto-fill-function " AF")
  (visual-line-mode))

(use-package sanity
  :straight nil
  :no-require t
  :config
  (setq ad-redefinition-action 'accept)
  (setq bidi-inhibit-bpa t)
  (setq command-line-ns-option-alist nil)
  (setq confirm-kill-processes nil)
  (setq custom-file (save-in-etc-file! "custom.el"))
  (setq default-input-method "TeX")
  (setq ffap-machine-p-known 'reject)
  (setq inhibit-compacting-font-caches t)
  (setq inhibit-default-init t)
  (setq jit-lock-defer-time nil)
  (setq jka-compr-verbose nil)
  (setq native-comp-async-report-warnings-errors nil)
  (setq read-file-name-completion-ignore-case t)
  ;;(setq read-process-output-max (* 64 1024))
  (setq redisplay-skip-fontification-on-input t)
  (setq ring-bell-function 'ignore)
  (setq-default fill-column 80)
  (setq-default lexical-binding t))

(use-package files
  :straight nil
  :no-require t
  :config 
  (setq auto-mode-case-fold nil)
  (setq auto-save-default nil)
  (setq auto-save-list-file-prefix nil)
  (setq backup-inhibited t)
  (setq create-lockfiles nil)
  (setq delete-by-moving-to-trash nil)
  (setq find-file-suppress-same-file-warnings t)
  (setq find-file-visit-truename t)
  (setq load-prefer-newer t)
  (setq make-backup-files nil)
  (setq require-final-newline t)
  (setq vc-follow-symlinks t))

(use-package gcmh
  :demand
  :delight
  :config
  (setq gcmh-auto-idle-delay-factor 10)
  (setq gcmh-high-cons-threshold (* 128 1024 1024))
  (setq gcmh-idle-delay 'auto)
  (gcmh-mode 1))


(use-package eldoc
  :hook (emacs-lisp-mode cider-mode))

#+end_src
** Keep Emacs Directory clean
Use no-littering to automatically set common paths to the new user-emacs-directory
#+begin_src emacs-lisp
(use-package no-littering
  :demand
  :config
   (with-eval-after-load 'recentf
     (add-to-list 'recentf-exclude no-littering-var-directory)
     (add-to-list 'recentf-exclude no-littering-etc-directory))
   )

#+end_src

** Install some popular packages
#+begin_src emacs-lisp :tangle no
;; popular packages
(setup (:pkg el-patch))
(setup (:pkg s))
(setup (:pkg dash))
(setup (:pkg async))
(setup (:pkg request))
(setup (:pkg delight))



;; profiler
(setup (:pkg esup)
       (:delay 5)) ;; :defer t)

#+end_src

** Corgi setup
:PROPERTIES:
:header-args: :noweb-ref corgi-setup
:END:
#+begin_src emacs-lisp
;;(when (not (file-exists-p
;;(expand-file-name "straight/versions/default.el" straight-base-dir )))
;;(straight-freeze-versions))

;; Enable the corgi-packages repository so we can install our packages with
;; Straight. This also runs some Corgi initialization code, notably copying over
;; Corgi's version file, so you get the same versions of packages that Corgi was
;; tested with.
(use-package corgi-packages
  :straight (corgi-packages
	     :type git
	     :host github
	     :repo "corgi-emacs/corgi-packages"))

(add-to-list 'straight-recipe-repositories 'corgi-packages)
;;(let ((straight-current-profile 'corgi))
;; Change a bunch of Emacs defaults, from disabling the menubar and toolbar,
;; to fixing modifier keys on Mac and disabling the system bell.
;;(use-package corgi-defaults)
;;(require 'mf-settings)

;; UI configuration for that Corgi-feel. This sets up a bunch of packages like
;; Evil, Smartparens, Ivy (minibuffer completion), Swiper (fuzzy search),
;; Projectile (project-aware commands), Aggressive indent, Company
;; (completion).
(use-package corgi-editor)

;; The few custom commands that we ship with. This includes a few things we
;; emulate from Spacemacs, and commands for jumping to the user's init.el
;; (this file, with `SPC f e i'), or opening the user's key binding or signals
;; file.
(use-package corgi-commands)

;; Extensive setup for a good Clojure experience, including clojure-mode,
;; CIDER, and a modeline indicator that shows which REPLs your evaluations go
;; to.
;; Also contains `corgi/cider-pprint-eval-register', bound to `,,', see
;; `set-register' calls below.
(use-package corgi-clojure)

;; Emacs Lisp config, mainly to have a development experience that feels
;; similar to using CIDER and Clojure. (show results in overlay, threading
;; refactorings)
(use-package corgi-emacs-lisp)

;; Change the color of the modeline based on the Evil state (e.g. green when
;; in insert state)
(use-package corgi-stateline
  :config
  (global-corgi-stateline-mode))

;; Package which provides corgi-keys and corgi-signals, the two files that
;; define all Corgi bindings, and the default files that Corkey will look for.
(use-package corgi-bindings)

;; Corgi's keybinding system, which builds on top of Evil. See the manual, or
;; visit the key binding and signal files (with `SPC f e k', `SPC f e K', `SPC
;; f e s' `SPC f e S')
;; Put this last here, otherwise keybindings for commands that aren't loaded
;; yet won't be active.
(use-package corkey
  :config
  (corkey-mode 1)
  ;; Automatically pick up keybinding changes
  (let ((user-emacs-directory *emacs-config/*))
    (corkey/load-and-watch)))
;;)

#+end_src
*** init-corgi tangle
:PROPERTIES:
:header-args: :tangle lisp/init-corgi.el :noweb yes
:END:

Setup default corgi
#+begin_src emacs-lisp
;;; init-corgi.el --- Initialise Corgi -*- lexical-binding: t -*-
<<disclaimer>>
;;

;;; Code:

(require 'config-path)

<<corgi-setup>>

(provide 'init-corgi)
;;; init-corgi.el ends here
#+end_src

** Emacs Startup Setup
:PROPERTIES:
:header-args: :noweb-ref emacs-startup
:END:
Show startup time
#+begin_src emacs-lisp :noweb-ref startup-time

(setup show-startup-time
       (:with-hook emacs-startup-hook
		   (:hook enfer/show-startup-time)))

#+end_src
*** Garbage collection automatic
Configure grabage collection
#+begin_src emacs-lisp :noweb-ref garbage
(setup (:pkg gcmh)
       (setq gcmh-auto-idle-delay-factor 10)
       (setq gcmh-high-cons-threshold (* 128 1024 1024))
       (setq gcmh-idle-delay 'auto)
       (gcmh-mode 1)
       (:hide-mode))

#+end_src

*** local UI config
setup local config and personal functions
#+begin_src emacs-lisp :noweb-ref local-fns
(use-package functions
  :pkg nil
  :preface
  (defun split-pararagraph-into-lines ()
    "Split the current paragraph into lines with one sentence each."
    (interactive)
    (save-excursion
      (let ((fill-column most-positive-fixnum))
        (fill-paragraph))
      (let ((auto-fill-p auto-fill-function)
            (end (progn (end-of-line) (backward-sentence) (point))))
        (back-to-indentation)
        (unless (= (point) end)
          (auto-fill-mode -1)
          (while (< (point) end)
            (forward-sentence)
            (delete-horizontal-space)
            (newline-and-indent))
          (deactivate-mark)
          (when auto-fill-p
            (auto-fill-mode t))
          (when (looking-at "^$")
            (backward-delete-char 1))))))
  (defun indirect-narrow-to-defun ()
    (interactive)
    (clone-indirect-buffer (buffer-name) t t)
    (narrow-to-defun))
  (defun indirect-narrow-to-region ()
    (interactive)
    (let ((beg (mark))
          (end (point)))
      (clone-indirect-buffer (buffer-name) t t)
      (narrow-to-region beg end)))
  (defun narrow-next-page ()
    "Narrow to the next page."
    (interactive)
    (widen)
    (unless (looking-at "")
      (forward-page))
    (narrow-to-page))
  (defun narrow-prev-page ()
    "Narrow to the previous page."
    (interactive)
    (widen)
    (unless (looking-at "")
      (backward-page))
    (backward-page)
    (narrow-to-page))
  (defmacro comment (&rest _)
    nil)
  (provide 'functions))
#+end_src
*** Auto compile and Benchmarking
#+begin_src emacs-lisp :noweb-ref benchmarking

(setup (:pkg benchmark-init)
       (:disable) ; Disabled when not benchmarking.
       (define-advice define-obsolete-function-alias (:filter-args (ll))
	 (let ((obsolete-name (pop ll))
               (current-name (pop ll))
               (when (if ll (pop ll) "1"))
               (docstring (if ll (pop ll) nil)))
           (list obsolete-name current-name when docstring)))
       (:require benchmark-init-modes)
       (:global-bind
	"<M-f2>" #'benchmark-init/show-durations-tabulated
	"<M-f3>" #'benchmark-init/show-durations-tree)
       (:with-hook after-init-hook
		   (:hook benchmark-init/deactivate)))

(setup (:pkg auto-compile)
       (auto-compile-on-load-mode 1)
       (auto-compile-on-save-mode 1)
       (:hide-mode)
       (:hide-mode auto-compile-on-load))

#+end_src
* Utility Functions & macros

These have been sucked from [[https://github.com/mfiano/dotfiles/blob/master/.emacs.d/lisp/mf-util.el][mifano]], doom, d12frosted and andreorst

*** Macros
:PROPERTIES:
:header-args: :noweb-ref macros
:END:
#+begin_src emacs-lisp
(require 'cl-lib)

;;; Macros
(defmacro define-dir! (name directory &optional docstring inhibit-mkdir)
  "Define a variable and function NAME expanding to DIRECTORY.
        DOCSTRING is applied to the variable.  Ensure DIRECTORY exists in
        the filesystem, unless INHIBIT-MKDIR is non-nil."
  (declare (indent 2))
  (unless inhibit-mkdir
    (make-directory (eval directory) :parents))
  `(progn
     (defvar ,name ,directory
       ,(concat docstring (when docstring "\n")
                "Defined by `/define-dir'."))
     (defun ,name (file &optional mkdir)
       ,(concat "Expand FILE relative to variable `" (symbol-name name) "'.\n"
                "If MKDIR is non-nil, the directory is created.\n"
                "Defined by `/define-dir'.")
       (let ((file-name (expand-file-name (convert-standard-filename file)
                                          ,name)))
         (when mkdir
           (make-directory (file-name-directory file-name) :parents))
         file-name))))

(defun suppress-messages! (oldfn &rest args) ; from pkal
  "Advice wrapper for suppressing `message'.
        OLDFN is the wrapped function, that is passed the arguments
        ARGS."
  (let ((msg (current-message)))
    (prog1
        (let ((inhibit-message t))
          (apply oldfn args))
      (when msg
        (message "%s" msg)))))

(defmacro letenv! (envvars &rest body)
  "Lexically bind ENVVARS in BODY, like `let' but for `process-environment'."
  (declare (indent 1))
  `(let ((process-environment (copy-sequence process-environment)))
     (dolist (var (list ,@(cl-loop for (var val) in envvars
                                   collect `(cons ,var ,val))))
       (setenv (car var) (cdr var)))
     ,@body))

(defmacro letf! (bindings &rest body)
  "Temporarily rebind function, macros, and advice in BODY.

            Intended as syntax sugar for `cl-letf', `cl-labels', `cl-macrolet', and
            temporary advice.

            BINDINGS is either:

              A list of, or a single, `defun', `defun*', `defmacro', or `defadvice' forms.
              A list of (PLACE VALUE) bindings as `cl-letf*' would accept.

            TYPE is one of:

              `defun' (uses `cl-letf')
              `defun*' (uses `cl-labels'; allows recursive references),
              `defmacro' (uses `cl-macrolet')
              `defadvice' (uses `defadvice!' before BODY, then `undefadvice!' after)

            NAME, ARGLIST, and BODY are the same as `defun', `defun*', `defmacro', and
            `defadvice!', respectively.

            \(fn ((TYPE NAME ARGLIST &rest BODY) ...) BODY...)"
  (declare (indent defun))
  (setq body (macroexp-progn body))
  (when (memq (car bindings) '(defun defun* defmacro defadvice))
    (setq bindings (list bindings)))
  (dolist (binding (reverse bindings) body)
    (let ((type (car binding))
          (rest (cdr binding)))
      (setq
       body (pcase type
              (`defmacro `(cl-macrolet ((,@rest)) ,body))
              (`defadvice `(progn (defadvice! ,@rest)
                                  (unwind-protect ,body (undefadvice! ,@rest))))
              ((or `defun `defun*)
               `(cl-letf ((,(car rest) (symbol-function #',(car rest))))
                  (ignore ,(car rest))
                  ,(if (eq type 'defun*)
                       `(cl-labels ((,@rest)) ,body)
                     `(cl-letf (((symbol-function #',(car rest))
                                 (fn! ,(cadr rest) ,@(cddr rest))))
                        ,body))))
              (_
               (when (eq (car-safe type) 'function)
                 (setq type (list 'symbol-function type)))
               (list 'cl-letf (list (cons type rest)) body)))))))

(defmacro fn! (&rest body)
  `(lambda () (interactive) ,@body))

;;; Closure factories
(defmacro fn!! (arglist &rest body)
  "Returns (cl-function (lambda ARGLIST BODY...))
                The closure is wrapped in `cl-function', meaning ARGLIST will accept anything
                `cl-defun' will. Implicitly adds `&allow-other-keys' if `&key' is present in
                ARGLIST."
  (declare (indent defun) (doc-string 1) (pure t) (side-effect-free t))
  `(cl-function
    (lambda
      ,(letf! (defun* allow-other-keys (args)
                (mapcar
                 (lambda (arg)
                   (cond ((nlistp (cdr-safe arg)) arg)
                         ((listp arg) (allow-other-keys arg))
                         (arg)))
                 (if (and (memq '&key args)
                          (not (memq '&allow-other-keys args)))
                     (if (memq '&aux args)
                         (let (newargs arg)
                           (while args
                             (setq arg (pop args))
                             (when (eq arg '&aux)
                               (push '&allow-other-keys newargs))
                             (push arg newargs))
                           (nreverse newargs))
                       (append args (list '&allow-other-keys)))
                   args)))
              (allow-other-keys arglist))
      ,@body)))

(defmacro cmd! (&rest body)
  "Returns (lambda () (interactive) ,@body)
                A factory for quickly producing interaction commands, particularly for keybinds
                or aliases."
  (declare (doc-string 1) (pure t) (side-effect-free t))
  `(lambda (&rest _) (interactive) ,@body))

(defmacro quiet! (&rest forms)
  `(cond
    (noninteractive
     (let ((old-fn (symbol-function 'write-region)))
       (cl-letf ((standard-output (lambda (&rest _)))
                 ((symbol-function 'load-file)
                  (lambda (file) (load file nil t)))
                 ((symbol-function 'message) (lambda (&rest _)))
                 ((symbol-function 'write-region)
                  (lambda (start end filename &optional append visit lockname
                                 mustbenew)
                    (unless visit (setq visit 'no-message))
                    (funcall old-fn start end filename append visit lockname
                             mustbenew))))
         ,@forms)))
    ((or debug-on-error debug-on-quit)
     ,@forms)
    ((let ((inhibit-message t)
           (save-silently t))
       (prog1 ,@forms (message ""))))))

;;;; Mutation
(defmacro appendq! (sym &rest lists)
  "Append LISTS to SYM in place."
  `(setq ,sym (append ,sym ,@lists)))

(defmacro setq! (&rest settings)
  "A stripped-down `customize-set-variable' with the syntax of `setq'.

              This can be used as a drop-in replacement for `setq'. Particularly when you know
              a variable has a custom setter (a :set property in its `defcustom' declaration).
              This triggers setters. `setq' does not."
  (macroexp-progn
   (cl-loop for (var val) on settings by 'cddr
            collect `(funcall (or (get ',var 'custom-set) #'set)
                              ',var ,val))))

(defmacro delq! (elt list &optional fetcher)
  "`delq' ELT from LIST in-place.

              If FETCHER is a function, ELT is used as the key in LIST (an alist)."
  `(setq ,list
         (delq ,(if fetcher
                    `(funcall ,fetcher ,elt ,list)
                  elt)
               ,list)))

(defmacro pushnew! (place &rest values)
  "Push VALUES sequentially into PLACE, if they aren't already present.
              This is a variadic `cl-pushnew'."
  (let ((var (make-symbol "result")))
    `(dolist (,var (list ,@values) (with-no-warnings ,place))
       (cl-pushnew ,var ,place :test #'equal))))

(defmacro prependq! (sym &rest lists)
  "Prepend LISTS to SYM in place."
  `(setq ,sym (append ,@lists ,sym)))

;;; Loading
(defmacro add-load-path! (&rest dirs)
  "Add DIRS to `load-path', relative to the current file.
              The current file is the file from which `add-to-load-path!' is used."
  `(let ((default-directory ,(dir!))
         file-name-handler-alist)
     (dolist (dir (list ,@dirs))
       (cl-pushnew (expand-file-name dir) load-path :test #'string=))))

 #+end_src
*** Variables
:PROPERTIES:
:header-args: :noweb-ref variables
:ID:                     96932d92-d4cc-4d1f-ace0-60da51f8e009
:END:
#+begin_src emacs-lisp
;;; Variables
(defvar enfer/ignored-suffixes
  '(".7z" ".bz2" ".db" ".dll" ".dmg" ".elc" ".exe" ".fasl" ".gz" ".iso" ".jar"
    ".o" ".pyc" ".rar" ".so" ".sql" ".sqlite" ".tar" ".tgz" ".xz" ".zip"))
#+end_src
*** Functions
:PROPERTIES:
:header-args: :noweb-ref functions
:END:
#+begin_src emacs-lisp
;;; Functions
(defun enfer/show-startup-time ()
  (message "Heure de démarrage d'Emacs: %.2fs (%d GCs (ramasse-miettes))"
           (float-time (time-subtract after-init-time before-init-time))
           gcs-done))

(defun save-in-etc-file! (file-name)
  (expand-file-name (format "etc/%s" file-name) *emacs-cache/*))

(defun path-in-cache/? (path)
  (string-prefix-p (getenv "XDG_CACHE_HOME") (expand-file-name path)))

(define-dir! *emacs-sync/* (expand-file-name "~/Sync/emacs")
  "My Syncthing Emacs directory.")

(defun mf/smarter-move-beginning-of-line (arg)
  (interactive "^p")
  (setq arg (or arg 1))
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))
  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(defun mf/yank-primary-selection ()
  (interactive)
  (let ((primary (or (gui-get-primary-selection) (gui-get-selection))))
    (when primary
      (push-mark (point))
      (insert-for-yank primary))))

(defun mf/delete-file (filename)
  (interactive "f")
  (when (and filename (file-exists-p filename))
    (let ((buffer (find-buffer-visiting filename)))
      (when buffer
        (kill-buffer buffer)))
    (delete-file filename)))

(defun mf/rename-file ()
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' n'a ​​pas de fichier associé!" name)
      (let* ((dir (file-name-directory filename))
             (new-name (read-file-name "Nouveau nom de fichier: " dir)))
        (cond ((get-buffer new-name)
               (error "Un Buffer nommé '%s' existe déjà!" new-name))
              (t
               (let ((dir (file-name-directory new-name)))
                 (when (and (not (file-exists-p dir))
                            (yes-or-no-p (format "Créer le répertoire '%s'?"
                                                 dir)))
                   (make-directory dir t)))
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)
               (when (fboundp 'recentf-add-file)
                 (recentf-add-file new-name)
                 (recentf-remove-if-non-kept filename))
               (message "Fichier '%s' renommé avec succès en '%s'" name
                        (file-name-nondirectory new-name))))))))

(defun doom-unquote (exp)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

(defun doom-keyword-intern (str)
  "Converts STR (a string) into a keyword (`keywordp')."
  (declare (pure t) (side-effect-free t))
  (cl-check-type str string)
  (intern (concat ":" str)))

(defun doom-keyword-name (keyword)
  "Returns the string name of KEYWORD (`keywordp') minus the leading colon."
  (declare (pure t) (side-effect-free t))
  (cl-check-type keyword keyword)
  (substring (symbol-name keyword) 1))

(defun +ensure-after-init (function)
  "Ensure FUNCTION runs after init, or now if already initialised.
  If Emacs is already started, run FUNCTION.  Otherwise, add it to
  `after-init-hook'.  FUNCTION is called with no arguments."
  (if after-init-time
      (funcall function)
    (add-hook 'after-init-hook function)))

;;
;;; Sugars

(defun dir! ()
  "Returns the directory of the emacs lisp file this macro is called from."
  (when-let (path (file!))
    (directory-file-name (file-name-directory path))))

(defun file! ()
  "Return the emacs lisp file this macro is called from."
  (cond ((bound-and-true-p byte-compile-current-file))
        (load-file-name)
        ((stringp (car-safe current-load-list))
         (car current-load-list))
        (buffer-file-name)
        ((error "Cannot get this file-path"))))

#+end_src
** Tangle lib-fn-macros
:PROPERTIES:
:header-args: :tangle lisp/lib-fn-macros.el :noweb yes
:END:

File for my constants, macros and functions
#+begin_src emacs-lisp
;;; lib-fn-macros.el --- Util fns -*- lexical-binding: t -*-
<<disclaimer>>

;;; Code:

;;; ============================================================================
;;; Variables
;;; ============================================================================

<<variables>>

;;; ============================================================================
;;; Macros
;;; ============================================================================

<<macros>>

;;; ============================================================================
;;; Functions
;;; ============================================================================

<<functions>>

(provide 'lib-fn-macros)
;;; lib-fn-macros.el ends here
#+end_src

* Emacs as an Editor
:PROPERTIES:
:header-args: :noweb-ref pkg-editor
:END:
** Emacs Editor Sane Setting
#+begin_src emacs-lisp :noweb-ref editor-sanity
(use-package emacs

)
#+end_src
** Emacs keyboard Setting
*** Prot simple
prot-simple.el contains a wide range of commands that are broadly in line with the built-in simple.el and lisp.el libraries. While I could offer an overview of each item in my library, I feel the code and accompanying documentation strings are clear enough for you to peruse the source directly (reproduced further below).

Still, here are some highlights for those who don’t like studying the source code:

- prot-simple-insert-pair will surround either the symbol-at-point or the active region with a pair of delimiters. It prompts for completion on which pair to use, while the most recently used entry becomes the default, so next time the user can just add it with RET at the minibuffer prompt. With an optional prefix argument (C-u) it asks for how many times to insert the selected delimiters (e.g. you want to wrap two angled brackets around the region).
- prot-simple-scratch-buffer produces a buffer with the major-mode of the current one. With a prefix argument (C-u) it instead applies the major-mode which is stored in the user customisation option prot-simple-scratch-buffer-default-mode. With a double prefix argument (C-u C-u) it prompts for completion on which major-mode to use. If the region is active, its contents are copied to the newly created scratch buffer. The idea is based on the scratch.el package by Ian Eure.
- prot-simple-copy-line-or-region copies the current line or the region, if that is active. With a prefix argument (C-u) it creates a duplicate of it right below.

All of the other commands are optimisations for common motions or little quality-of-life improvements for oft-required operations (such as transposition of objects or marking of balanced expressions).

Given that this is a foundational piece of my Emacs setup, it is the appropriate place to re-bind or free up some common key combinations for use elsewhere.
#+begin_src emacs-lisp :noweb-ref prot-keyboard
(setup (:require prot-simple)
       (setq prot-simple-date-specifier "%F")
       (setq prot-simple-time-specifier "%R %z")
       (setq delete-pair-blink-delay 0.15) ; Emacs28 -- see `prot-simple-delete-pair-dwim'
       (setq prot-simple-scratch-buffer-default-mode 'markdown-mode)
       (setq help-window-select t)

       ;; General commands
       (let ((map global-map))
	 (define-key map (kbd "<insert>") nil)
	 (define-key map (kbd "C-z") nil)
	 (define-key map (kbd "C-x C-z") nil)
	 (define-key map (kbd "C-h h") nil)
	 (define-key map (kbd "M-`") nil)
	 (define-key map (kbd "C-h .") #'prot-simple-describe-symbol) ; overrides `display-local-help'
	 (define-key map (kbd "C-h K") #'describe-keymap) ; overrides `Info-goto-emacs-key-command-node'
	 (define-key map (kbd "C-h c") #'describe-char) ; overrides `describe-key-briefly'
	 (define-key map (kbd "C-c s") #'prot-simple-scratch-buffer)
	 ;; Commands for lines
	 (define-key map (kbd "C-S-w") #'prot-simple-copy-line-or-region)
	 (define-key map (kbd "C-S-y") #'prot-simple-yank-replace-line-or-region)
	 (define-key map (kbd "M-SPC") #'cycle-spacing)
	 (define-key map (kbd "M-o") #'delete-blank-lines)   ; alias for C-x C-o
	 (define-key map (kbd "M-k") #'prot-simple-kill-line-backward)
	 (define-key map (kbd "C-S-n") #'prot-simple-multi-line-next)
	 (define-key map (kbd "C-S-p") #'prot-simple-multi-line-prev)
	 (define-key map (kbd "<C-return>") #'prot-simple-new-line-below)
	 (define-key map (kbd "<C-S-return>") #'prot-simple-new-line-above)
	 ;; Commands for text insertion or manipulation
	 (define-key map (kbd "C-=") #'prot-simple-insert-date)
	 (define-key map (kbd "C-<") #'prot-simple-escape-url)
	 (define-key map (kbd "C-'") #'prot-simple-insert-pair)
	 (define-key map (kbd "M-'") #'prot-simple-insert-pair)
	 (define-key map (kbd "M-\\") #'prot-simple-delete-pair-dwim)
	 (define-key map (kbd "C-M-;") #'prot-simple-cite-region)
	 (define-key map (kbd "C-M-^") #'prot-simple-insert-undercaret)
	 (define-key map (kbd "<C-M-backspace>") #'backward-kill-sexp)
	 (define-key map (kbd "M-c") #'capitalize-dwim)
	 (define-key map (kbd "M-l") #'downcase-dwim)        ; "lower" case
	 (define-key map (kbd "M-u") #'upcase-dwim)
	 ;; Commands for object transposition
	 (define-key map (kbd "C-t") #'prot-simple-transpose-chars)
	 (define-key map (kbd "C-x C-t") #'prot-simple-transpose-lines)
	 (define-key map (kbd "C-S-t") #'prot-simple-transpose-paragraphs)
	 (define-key map (kbd "C-x M-t") #'prot-simple-transpose-sentences)
	 (define-key map (kbd "C-M-t") #'prot-simple-transpose-sexps)
	 (define-key map (kbd "M-t") #'prot-simple-transpose-words)
	 ;; Commands for marking objects
	 (define-key map (kbd "M-@") #'prot-simple-mark-word)       ; replaces `mark-word'
	 (define-key map (kbd "C-M-SPC") #'prot-simple-mark-construct-dwim)
	 (define-key map (kbd "C-M-d") #'prot-simple-downward-list)
	 ;; Commands for paragraphs
	 (define-key map (kbd "M-Q") #'prot-simple-unfill-region-or-paragraph)
	 ;; Commands for windows and pages
	 (define-key map (kbd "C-x n k") #'prot-simple-delete-page-delimiters)
	 (define-key map (kbd "C-x M") #'prot-simple-monocle)
	 ;; NOTE 2022-03-02: Elsewhere I provide my `logos.el' package which
	 ;; has the functionality of these three commands.
	 ;;
	 ;; (define-key map [remap narrow-to-region] #'prot-simple-narrow-dwim)
	 ;; (define-key map [remap forward-page] #'prot-simple-forward-page-dwim)
	 ;; (define-key map [remap backward-page] #'prot-simple-backward-page-dwim)
	 ;;
	 ;; Commands for buffers
	 (define-key map (kbd "M-=") #'count-words)
	 (define-key map (kbd "<C-f2>") #'prot-simple-rename-file-and-buffer)
	 (define-key map (kbd "C-x K") #'prot-simple-kill-buffer-current)
	 (define-key map (kbd "M-s b") #'prot-simple-buffers-major-mode)
	 (define-key map (kbd "M-s v") #'prot-simple-buffers-vc-root)))
)
(setup
 (use-package bind-key)
 (require 'bind-key)
 (require 'delight)

 (use-package bindings
   :straight nil
   :bind ( :map ctl-x-map
		("C-d" . dired-jump)
		:map narrow-map
		("i d" . indirect-narrow-to-defun)
		("i n" . indirect-narrow-to-region)
		("]" . narrow-next-page)
		("[" . narrow-prev-page))
   :init
   (setq mode-line-end-spaces nil))

 ;; (use-package simple
 ;;   :straight nil
 ;;   :bind (("M-z" . zap-up-to-char)
 ;;          ("M-S-z" . zap-to-char)
 ;;          ("C-x k" . kill-this-buffer)
 ;;          ("C-h C-f" . describe-face))
 ;;   :hook ((before-save . delete-trailing-whitespace)
 ;;          (overwrite-mode . overwrite-set-cursor-shape))
 ;;   :custom
 ;;   (yank-excluded-properties t)
 ;;   (blink-matching-delay 0)
 ;;   (blink-matching-paren t)
 ;;   (copy-region-blink-delay 0)
 ;;   :init
 ;;   (column-number-mode 1)
 ;;   (line-number-mode 1)
 ;;   (transient-mark-mode -1)
 ;;   (defun overwrite-set-cursor-shape ()
 ;;     (when (display-graphic-p)
 ;;       (setq cursor-type (if overwrite-mode 'hollow 'box))))
 ;;   (define-advice keyboard-quit (:around (quit))
 ;;     "Quit the current context.
 ;; When there is an active minibuffer and we are not inside it close
 ;; it.  When we are inside the minibuffer use the regular
 ;; `minibuffer-keyboard-quit' which quits any active region before
 ;; exiting.  When there is no minibuffer `keyboard-quit' unless we
 ;; are defining or executing a macro."
 ;;     (if (active-minibuffer-window)
 ;;         (if (minibufferp)
 ;;             (minibuffer-keyboard-quit)
 ;;           (abort-recursive-edit))
 ;;       (unless (or defining-kbd-macro
 ;;                   executing-kbd-macro)
 ;;         (funcall-interactively quit)))))

 (setup (:pkg which-key)
	;;    (which-key-mode 1)
	;;   (setq which-key-add-column-padding 2)
	;;   (setq which-key-idle-delay 0.5)
	;;   (setq which-key-idle-secondary-delay 0.1)
	;;   (setq which-key-max-display-columns nil)
	;;   (setq which-key-min-display-lines 6)
	;;   (setq which-key-replacement-alist
	;;     '((("left") . ("🡸"))
	;;       (("right") . ("🡺"))
	;;       (("up") . ("🡹"))
	;;       (("down") . ("🡻"))
	;;       (("delete") . ("DEL"))
	;;       (("\\`DEL\\'") . ("BKSP"))
	;;       (("RET") . ("⏎"))
	;;       (("next") . ("PgDn"))
	;;       (("prior") . ("PgUp"))))
	;;   (setq which-key-sort-order 'which-key-key-order-alpha)
	;;   (setq which-key-sort-uppercase-first nil)
	;;   (which-key-setup-minibuffer)
	;; ;;  (:with-hook which-key-init-buffer-hook
	;;  ;;   (:hook (lambda (setq line-spacing 4))))
	(:hide-mode))

 (use-package which-key
   :hook (after-init . which-key-mode))

#+end_src
*** Hydra
keychords with hydra
#+begin_src emacs-lisp :noweb-ref hydra
(use-package hydra
  :config
  (progn
    ;; (setq hydra-lv nil)
    (set-face-attribute 'hydra-face-red      nil :foreground "Red"        :bold t)
    (set-face-attribute 'hydra-face-blue     nil :foreground "RoyalBlue3" :bold t)
    (set-face-attribute 'hydra-face-amaranth nil :foreground "#e52b50"    :bold t)
    (set-face-attribute 'hydra-face-pink     nil :foreground "HotPink1"   :bold t)
    (set-face-attribute 'hydra-face-teal     nil :foreground "#367588"    :bold t)
    (hydra-add-font-lock)))

;; https://github.com/abo-abo/hydra/wiki/Hydra-Colors#colorful-hydras
;; https://github.com/abo-abo/hydra/wiki/internals#exit
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | Body     | Non-color                   | Head      | Executing             | After     |
;; | Color    | Alternative                 | Inherited | NON-HEADS             | executing |
;; |          |                             | Color     |                       | HEADS     |
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | red      | :foreign-keys nil (default) | red       | Allow and Quit        |           |
;; |          | :exit nil (default)         |           |                       | Continue  |
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | blue     | :foreign-keys nil (default) | blue      | Allow and Quit        |           |
;; |          | :exit t                     |           |                       | Quit      |
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | amaranth | :foreign-keys warn          | red       | Disallow and Continue |           |
;; |          | :exit nil (default)         |           |                       | Continue  |
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | teal     | :foreign-keys warn          | blue      | Disallow and Continue |           |
;; |          | :exit t                     |           |                       | Quit      |
;; |----------+-----------------------------+-----------+-----------------------+-----------|
;; | pink     | :foreign-keys run           | red       | Allow and Continue    |           |
;; |          | :exit nil (default)         |           |                       | Continue  |

#+end_src
*** Mac command bindings /mac-keys/
Change the Mac modifiers to my liking. I also disable passing Control characters to the system, to avoid that C-M-space launches the Character viewer instead of running mark-sexp.

#+begin_src emacs-lisp :noweb-ref mac-keys
(cond (*is-mac?*
       (setq  mac-command-modifier        'super
              mac-option-modifier         'meta
              mac-right-option-modifier   'alt
              mac-pass-control-to-system   nil)))

#+end_src
** File Management
:PROPERTIES:
:END:
*** Setup dired - directory fn of Emacs
#+begin_src emacs-lisp
  (setup dired
            (:also-load dired-x)
            (:pkg dired-collapse
                  dired-git-info
                  dired-single
                  dired-subtree
                  diredfl
                  dired+)
            (:option dired-recursive-copies 'always
                     dired-recursive-deletes 'always
                     dired-create-destination-dirs 'always
                     dired-do-revert-buffer t
                     dired-hide-details-hide-symlink-targets nil
                     dired-isearch-filenames 'dwim
                     delete-by-moving-to-trash t
                     dired-auto-revert-buffer t
                     dired-listing-switches "-Al"
                     ls-lisp-dirs-first t
                     dired-ls-F-marks-symlinks t
                     dired-clean-confirm-killing-deleted-buffers nil
                     dired-no-confirm '(byte-compile
                                        load chgrp chmod chown
                                        copy move hardlink symlink
                                        shell touch)
                     dired-dwim-target t)
            (:local-set truncate-lines t)
            (:bind
             "<backspace>" #'dired-up-directory
             "TAB" #'dired-subtree-cycle
             "i" #'dired-subtree-toggle
             ")" #'dired-git-info-mode
             "q" #'quit-window)
            (:hook #'dired-collapse-mode
                   #'dired-hide-details-mode
                   #'hl-line-mode)
            (:global "C-x C-j" #'dired-jump)
              (setq dired-recursive-copies 'top)
              (setq dired-recursive-deletes 'top)
              (diredfl-global-mode 1)
            )

#+end_src

*** setup abbrev
#+begin_src emacs-lisp :noweb-ref abbrev
(use-package abbrev
 :delight
 :config
   (setq abbrev-file-name (*emacs-sync/* "abbrev.el"))
   (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file))
    (setq save-abbrevs 'silent)
 :hook (text-mode circe-chat-mode))

(use-package hippie-expand
  :straight nil
  :config (setq hippie-expand-try-functions-list
      '(try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))
:bind ("M-/" . #'hippie-expand))

#+end_src
*** setup recent files
#+begin_src emacs-lisp :noweb-ref recent
(use-p (:require recentf)
       (setq recentf-auto-cleanup 'mode)
       (setq recentf-exclude `(,#'path-in-cache/?
			       "^/tmp/"
			       "COMMIT_EDITMSG$"
			       ".gz$"))
       (setq recentf-filename-handlers '(abbreviate-file-name))
       (setq recentf-max-menu-items 100)
       (setq recentf-max-saved-items nil)
       (recentf-mode 1)
       (run-at-time nil 120 (fn (quiet! (recentf-save-list))))
       (:with-hook kill-emacs-hook
		   (:hook recentf-cleanup recentf-save-list)))

                 #+end_src
** setup backups
#+begin_src emacs-lisp
(setup (:require savehist)
          (setq history-delete-duplicates t)
          (setq history-length t)
          (setq savehist-additional-variables
                '(extended-command-history
                  global-mark-ring
                  kill-ring
                  mark-ring
                  regexp-search-ring
                  search-ring))
          (setq savehist-autosave-interval 60)
          (setq savehist-file (save-in-etc-file! "history"))
          (setq savehist-save-minibuffer-history t)
          (savehist-mode 1))

        (setup (:require saveplace)
          (setq save-place-file (save-in-etc-file! "places"))
          (setq save-place-forget-unreadable-files nil)
          (save-place-mode 1))

#+end_src

** emacs server setup
#+begin_src emacs-lisp :noweb-ref server
(use-package edit-server
  :if window-system
  :init
  (add-hook 'after-init-hook 'server-start t)
  (add-hook 'after-init-hook 'edit-server-start t))

  #+end_src
** Electric
Emacs labels as “electric” any behaviour that involves contextual auto-insertion of characters. while the idea is neat, I generally dislike it because of its false positives. This is a summary of my settings:

- If electric-pair-mode is enabled (which I might do manually), insert quotes and brackets in pairs. Only do so if there is no alphabetic character after the cursor.
- The cryptic numbers in the pairs set, correspond to curly single and double quotes and these «». The contents of this set are always inserted in pairs, regardless of major mode. To get those numbers, evaluate (string-to-char CHAR) where CHAR is the one you are interested in. For example, get the literal tab’s character with (string-to-char "\t").
- While inputting a pair, inserting the closing character will just skip over the existing one, rather than add a new one. So typing ( will insert () and then typing ) will just be the same as moving forward one character C-f.
- Do not skip over whitespace when operating on pairs. Combined with the above point, this means that a new character will be inserted, rather than be skipped over. I find this better, because it prevents the point from jumping forward, plus it allows for more natural editing.
- The whitespace characters are space (\s), tab (\t), and newline (\n).
- The rest concern the conditions for transforming quotes into their curly equivalents. I keep this disabled, because curly quotes are distinct characters. It is difficult to search for them. Just note that on GNU/Linux you can type them directly by hitting the “compose” key and then an angled bracket (< or >) followed by a quote mark.
#+begin_src emacs-lisp
;;; Configure 'electric' behaviour
(setup electric
  (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars '(9 10 32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  (electric-pair-mode -1)
  (electric-quote-mode -1)
  ;; I don't like auto indents in Org and related.  They are okay for
  ;; programming.
  (electric-indent-mode -1)
  (add-hook 'prog-mode-hook #'electric-indent-local-mode))

;; electric everything (but there must be a way to disable it)
(when (fboundp 'electric-pair-mode)
(add-hook 'after-init-hook 'electric-pair-mode))
(add-hook 'after-init-hook 'electric-indent-mode)

(defun editor-disable-electric-indent ()
"Disable the command `electric-indent-mode' locally."
(electric-indent-local-mode -1))

(defun editor-disable-electric-pair ()
"Disable the command `electric-pair-mode' locally."
  (electric-pair-local-mode -1))

#+end_src
** Emacs *Help* functions
Help and which functions

#+begin_src emacs-lisp :noweb-ref emacs-help
 (use-package helpful
	 :after (evil avy)
	 :init
	 (setq evil-lookup-func #'helpful-at-point)
	 :bind
	 ([remap describe-function] . helpful-callable)
	 ([remap describe-command] . helpful-command)
	 ([remap describe-variable] . helpful-variable)
	 ([remap describe-key] . helpful-key)
	 :config
	  (defun avy-action-helpful (pt)
        (save-excursion
          (goto-char pt)
          (helpful-at-point))
        (select-window
         (cdr (ring-ref avy-ring 0)))
        t)
      ;; set H as avy dispatch to Help
      (setf (alist-get ?H avy-dispatch-alist) 'avy-action-helpful
	 )

#+end_src

#+begin_src emacs-lisp :tangle no
  (setup (:pkg helpful)
    (:when-loaded
      (:global-bind
       "C-h f" helpful-callable
       "C-h v" helpful-variable
       "C-h k" helpful-key)
      (defun avy-action-helpful (pt)
        (save-excursion
          (goto-char pt)
          (helpful-at-point))
        (select-window
         (cdr (ring-ref avy-ring 0)))
        t)
      ;; set H as avy dispatch to Help
      (setf (alist-get ?H avy-dispatch-alist) 'avy-action-helpful)

      (:load-after link-hint
        (:bind
         "o" link-hint-open-link-at-point)
        (setq helpful-switch-buffer-function
              (lambda (x)
                (if (eq major-mode 'helpful-mode)
                    (switch-to-buffer x)
                  (pop-to-buffer x)))))))

#+end_src


** Indentation
:PROPERTIES:
:ID:                     499df3a6-0e15-4f23-b915-ead73842e866
:END:
use electric-indent but have a way of turning it off
#+begin_src emacs-lisp
;; easier to search
(setq-default
search-default-mode #'char-fold-to-regexp
replace-char-fold t)





#+end_src

** Whitespaces
:PROPERTIES:
:ID:                     172e5cef-83e4-499b-a753-34beef9ad275
:END:
#+begin_src emacs-lisp
;; Whitespaces

(setq-default
 indent-tabs-mode nil
 tab-width 2
 require-final-newline t
 tab-always-indent t)

(defun editor-show-trailing-whitespace ()
  "Enable display of trailing whitespace in this buffer."
  (setq-local show-trailing-whitespace t))

(dolist (hook '(prog-mode-hook text-mode-hook conf-mode-hook))
  (add-hook hook 'editor-show-trailing-whitespace))

#+end_src

** Formatting
:PROPERTIES:
:ID:                     4b0da00e-0866-48e4-8cd7-0b34847c9d14
:END:
use ws-butler
#+begin_src emacs-lisp
    ;; Formatting
    (setq-default
     ;; `ws-butler' is used for better whitespace handling
     delete-trailing-lines nil
     sentence-end-double-space nil
     word-wrap t)

    (setup (:pkg (ws-butler
                 :type git
                 :host github
                 :repo "hlissner/ws-butler"))
     (:hide-mode)
     ;; :commands (ws-butler-global-mode)
      (ws-butler-global-mode)
      (setq ws-butler-global-exempt-modes
            (append ws-butler-global-exempt-modes
                    '(special-mode comint-mode term-mode eshell-mode))))


    
    ;; Disable backup files. While I find them useful in general, they
    ;; keep interfering with `org-roam'.

    (setq make-backup-files nil)

  #+end_src

  ACDW setup whitespace defaults
  #+begin_src emacs-lisp :tangle no
    (setup whitespace
      (setq backward-delete-char-untabify-method 'hungry)
      (setq next-line-add-newlines nil)
      (setq sentence-end-double-space nil)
      (setq-default indent-tabs-mode nil)
      (setq-default indicate-empty-lines nil)
      (setq-default tab-always-indent nil)
      (setq-default tab-width 4)
      (:with-hook before-save-hook
        (:hook delete-trailing-whitespace)))

#+end_src
** Long lines
:PROPERTIES:
:ID:                     07be8af1-fc88-4a04-b390-f40c054f1bd1
:END:
The visual-line-mode function enables line-wrapping. You can run the function separately for each buffer, but ideally, you hook it to all text modes.

When you select (mark) a section of text and start typing, Emacs will not replace the selected text. To enable Emacs deleting selected text, you set the delete-selection-mode variable, as below.

One last sensible default is to enure that Emacs lets you use the page-up and page-down buttons to
go to the first and last line in the buffer.
#+begin_src emacs-lisp
  ;; Long lines

  (setup (:pkg visual-fill-column)
    (:option visual-fill-column-center-text t)
;;             (append reading-modes) '(visual-fill-column-mode . +1))
    (:hook #'visual-line-mode)
    (:hook-into org-mode)
    (advice-add #'text-scale-adjust :after #'visual-fill-column-adjust))

  (setup (:pkg adaptive-wrap)
    (:with-mode adaptive-wrap-prefix-mode
      (:hook-into visual-column-mode)))


  (setup (:pkg unfill)
    ;;:commands (unfill-toggle)
    (:global "M-q"  #'unfill-toggle))

  ;; Overwrite selected text
  ;; (setup (:require delsel)
  ;;  (delete-selection-mode t))

  ;; Scroll to the first and last line of the buffer
  ;;(setq scroll-error-top-bottom t)

#+end_src
Undo is a key function of an editor - bind to Ctrl-Z - disabled
#+begin_src emacs-lisp :tangle no
 ;;undo
  (setup (:pkg undo-tree)
    (:hide-mode)
    (:global "C-z"   undo-tree-undo
           "C-S-z" undo-tree-redo)
    (setq undo-tree-auto-save-history nil)
    (global-undo-tree-mode 1))

    #+end_src
** Move Text
:PROPERTIES:
:ID:                     e876dc83-2902-46e7-8c1c-69e371a03b56
:END:
#+begin_src emacs-lisp
  (setup (:pkg move-text)
   ;; :commands (move-text-up
   ;;            move-text-down)
    (:global [M-S-down]  #'move-text-down
             [M-S-up]    #'move-text-up))

#+end_src
** Move where I Mean
:PROPERTIES:
:ID:                     0afacc7c-7b32-4047-842c-ade5637483c4
:END:
#+begin_src emacs-lisp
(setup  (:pkg mwim)
  (:delay 1)
  (:global "C-a"  mwim-beginning))

#+end_src

** Jump to visible position - Avy
:PROPERTIES:
:ID:                     e2c2803d-7159-4431-9bff-1ada59aaece5
:END:
The avy package by Oleh Krehel lets you select a location on the screen to move the cursor to. It does so by producing an overlay with characters that need to be typed to specify the location. By default, the overlay covers the candidate, though I change the avy-style to have it appear as a prefix instead.

There are several commands on offer which narrow down the candidates. My favourite is avy-goto-char-timer (closely followed by avy-goto-char-2 and avy-goto-word-1). It prompts for a character and then has a time window lasting avy-timeout-seconds during which it can read more characters. Once Avy receives the input, it overlays every word that contains those characters in succession. If there is a single match, it jumps directly to it.

Avy has the ability to act on the candidate rather than simply jump to it. Karthik Chikmagalur has a comprehensive essay on the matter, which I consider essential reading for anyone wanting to make best use of this package: Avy can do anything (2021-10-21). I still am not sure whether I need all that power though, as in my workflow I jump to a point and then invoke embark-act (see Extended minibuffer actions (embark.el)).

Finally, we can use Avy to select a candidate from the *Completions* buffer (see Minibuffer configurations and my extras (mct.el)).Setup avy in filter, select, act mode
#+begin_src emacs-lisp
 (setup (:pkg avy)
  (setq avy-all-windows nil) ; only the current window
  (setq avy-all-windows-alt t) ; all windows with C-u
  (setq avy-single-candidate-jump t)
  (setq avy-background nil)
  (setq avy-case-fold-search nil) ; case is significant
  (setq avy-timeout-seconds 0.5)
  (setq avy-style 'pre) ; prefixes candidate; otherwise use `at-full'
  (define-key global-map (kbd "C-.") #'avy-goto-char-timer))

 (setup (:pkg avy)
     (:disable)
      (:global  "M-j"  'avy-goto-char-timer
                "C-M-s" 'isearch-forward-other-window
                "C-M-r" 'isearch-backward-other-window)
      (setq avy-keys '(?q ?e ?r ?y ?u ?o ?p
                          ?a ?s ?d ?f ?g ?h ?j
                          ?k ?l ?' ?x ?c ?v ?b
                          ?n ?, ?/))

      (defun avy-show-dispatch-help ()
        (let* ((len (length "avy-action-"))
               (fw (frame-width))
               (raw-strings (mapcar
                             (lambda (x)
                               (format "%2s: %-19s"
                                       (propertize
                                        (char-to-string (car x))
                                        'face 'aw-key-face)
                                       (substring (symbol-name (cdr x)) len)))
                             avy-dispatch-alist))
               (max-len (1+ (apply #'max (mapcar #'length raw-strings))))
               (strings-len (length raw-strings))
               (per-row (floor fw max-len))
               display-strings)
          (cl-loop for string in raw-strings
                   for N from 1 to strings-len do
                   (push (concat string " ") display-strings)
                   (when (= (mod N per-row) 0) (push "\n" display-strings)))
          (message "%s" (apply #'concat (nreverse display-strings)))))

      ;; Kill text
      (defun avy-action-kill-whole-line (pt)
        (save-excursion
          (goto-char pt)
          (kill-whole-line))
        (select-window
         (cdr
          (ring-ref avy-ring 0)))
        t)

   ;; (:option avy-dispatch-alist (append (?k avy-action-kill-stay)))
  ;;    (add-to-list 'avy-dispatch-alist '(?k . avy-action-kill-stay))
      (setf (alist-get ?k avy-dispatch-alist) 'avy-action-kill-stay
            (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line)

      ;; Copy text
      (defun avy-action-copy-whole-line (pt)
        (save-excursion
          (goto-char pt)
          (cl-destructuring-bind (start . end)
              (bounds-of-thing-at-point 'line)
            (copy-region-as-kill start end)))
        (select-window
         (cdr
          (ring-ref avy-ring 0)))
        t)

      (setf (alist-get ?w avy-dispatch-alist) 'avy-action-copy
            (alist-get ?W avy-dispatch-alist) 'avy-action-copy-whole-line)

      ;; Yank text
      (defun avy-action-yank-whole-line (pt)
        (avy-action-copy-whole-line pt)
        (save-excursion (yank))
        t)

      (setf (alist-get ?y avy-dispatch-alist) 'avy-action-yank
            (alist-get ?Y avy-dispatch-alist) 'avy-action-yank-whole-line)

      ;; Transpose/Move text
      (defun avy-action-teleport-whole-line (pt)
        (avy-action-kill-whole-line pt)
        (save-excursion (yank)) t)

      (setf (alist-get ?t avy-dispatch-alist) 'avy-action-teleport
            (alist-get ?T avy-dispatch-alist) 'avy-action-teleport-whole-line)

      ;; Mark text
      (defun avy-action-mark-to-char (pt)
        (activate-mark)
        (goto-char pt))

      (setf (alist-get ?  avy-dispatch-alist) 'avy-action-mark-to-char)

      ;; Avy + Isearch
      (define-key isearch-mode-map (kbd "M-j") 'avy-isearch)

      ;; Isearch in other windows
      (defun isearch-forward-other-window (prefix)
        "Function to isearch-forward in other-window."
        (interactive "P")
        (unless (one-window-p)
          (save-excursion
            (let ((next (if prefix -1 1)))
              (other-window next)
              (isearch-forward)
              (other-window (- next))))))

      (defun isearch-backward-other-window (prefix)
        "Function to isearch-backward in other-window."
        (interactive "P")
        (unless (one-window-p)
          (save-excursion
            (let ((next (if prefix 1 -1)))
              (other-window next)
              (isearch-backward)
              (other-window (- next))))))

      (setq avy-all-windows t))

    ;; (setup (:pkg avy-zap)
    ;;   ;; : my-laptop-p
    ;;   (setq avy-zap-forward-only t)
    ;;   ;; (setq avy-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s))
    ;;   :global
    ;;   (("M-z" . avy-zap-up-to-char-dwim)
    ;;    ("M-Z" . avy-zap-to-char-dwim)))

#+end_src
** Search
The built-in search mechanisms, defined in the libraries isearch.el and replace.el are minimal in their presentation, yet powerful in their applications. There are the main points of entry to the commands they offer:

- isearch-forward (C-s) prompts for a string after point and offers live feedback on its progress. isearch-backward (C-r) moves in the opposite direction.
     - Two distinct keys may seem redundant at first, but you really appreciate this level of precision when recording keyboard macros (see, for example, my video about Isearch powers in keyboard macros (2020-01-21)).
     - Use C-M-s and C-M-r for running a search against a regular expression, or call isearch-toggle-regexp (M-r) after starting a regular isearch.
- query-replace (M-%) replaces all matches of a string and asks you for confirmation on each of them. If you check its help page (press ? after invoking the command), you will learn that ! stands for an affirmative answer to all, which is a standard in all such prompts.
     - query-replace-regexp (C-M-%) does the same for regular expressions.
- occur (M-s o) places all matches of a regular expression or string in a dedicated buffer. That can function as an index for moving to the relevant points in the buffer, but also as a means of refactoring all matches at once. Just make the *Occur* buffer editable with e. Running occur with a numeric argument provides N lines of context around the given match.

The beauty of the Occur and Replace commands is that they can be initiated from within an active Isearch session, using the same keys. So C-s INPUT M-s o will search for input and then run occur on it. Try C-h k C-s to get a help menu with all the extra keys you can use with isearch.
#+begin_src emacs-lisp
;;; Isearch, occur, grep, and extras (prot-search.el)
(setup (:require isearch)
  (setq search-highlight t)
  (setq search-whitespace-regexp ".*?")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)
  (setq isearch-lazy-highlight t)
  ;; All of the following variables were introduced in Emacs 27.1.
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format nil)
  (setq lazy-count-suffix-format " (%s/%s)")
  (setq isearch-yank-on-move 'shift)
  (setq isearch-allow-scroll 'unlimited)
  ;; These variables are from Emacs 28
  (setq isearch-repeat-on-direction-change t)
  (setq lazy-highlight-initial-delay 0.5)
  (setq lazy-highlight-no-delay-length 3)
  (setq isearch-wrap-pause t)

  (define-key minibuffer-local-isearch-map (kbd "M-/") #'isearch-complete-edit)
  (let ((map isearch-mode-map))
    (define-key map (kbd "C-g") #'isearch-cancel) ; instead of `isearch-abort'
    (define-key map (kbd "M-/") #'isearch-complete)))

(setup (:require replace)
  (setq list-matching-lines-jump-to-current-line t)
  (add-hook 'occur-mode-hook #'hl-line-mode)
  (add-hook 'occur-mode-hook #'prot-common-truncate-lines-silently) ; from `prot-common.el'
  (define-key occur-mode-map (kbd "t") #'toggle-truncate-lines))

(setup (:require grep))

(setup (:require prot-search)
  (setq prot-search-outline-regexp-alist
        '((emacs-lisp-mode . "^\\((\\|;;;+ \\)")
          (org-mode . "^\\(\\*+ +\\|#\\+[Tt][Ii][Tt][Ll][Ee]:\\)")))
  (setq prot-search-todo-keywords
        (concat "TODO\\|FIXME\\|NOTE\\|REVIEW\\|XXX\\|KLUDGE"
                "\\|HACK\\|WARN\\|WARNING\\|DEPRECATED\\|BUG"))

  (let ((map global-map))
    (define-key map (kbd "M-s %") #'prot-search-isearch-replace-symbol)
    (define-key map (kbd "M-s M-<") #'prot-search-isearch-beginning-of-buffer)
    (define-key map (kbd "M-s M->") #'prot-search-isearch-end-of-buffer)
    (define-key map (kbd "M-s g") #'prot-search-grep)
    (define-key map (kbd "M-s u") #'prot-search-occur-urls)
    (define-key map (kbd "M-s t") #'prot-search-occur-todo-keywords)
    (define-key map (kbd "M-s M-t") #'prot-search-grep-todo-keywords) ; With C-u it runs `prot-search-git-grep-todo-keywords'
    (define-key map (kbd "M-s M-o") #'prot-search-occur-outline)
    (define-key map (kbd "M-s M-u") #'prot-search-occur-browse-url))
  (let ((map isearch-mode-map))
    (define-key map (kbd "<up>") #'prot-search-isearch-repeat-backward)
    (define-key map (kbd "<down>") #'prot-search-isearch-repeat-forward)
    (define-key map (kbd "<backspace>") #'prot-search-isearch-abort-dwim)
    (define-key map (kbd "<C-return>") #'prot-search-isearch-other-end)))
#+end_src
** Writeable grep
With wgrep we can directly edit the results of a grep and save the changes to all affected buffers. In principle, this is the same as what the built-in occur offers. We can use it to operate on a list of matches by leveraging the full power of Emacs’ editing capabilities (e.g. keyboard macros, query and replace a regexp…).
#+begin_src emacs-lisp
;;; wgrep (writable grep)
(setup (:require wgrep)
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  (let ((map grep-mode-map))
    (define-key map (kbd "e") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-x C-q") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-c C-c") #'wgrep-finish-edit)))

#+end_src

** Cross-references
Xref provides helpful commands for code navigation and discovery, such as xref-find-definitions (M-.) and its counterpart xref-pop-marker-stack (M-,=). It is a library that gets used by a variety of tools, including =project.el (see Projects (project.el and prot-project.el)).
#+begin_src emacs-lisp
;;; Cross-references (xref.el)
(setup (:require xref)
  ;; All those have been changed for Emacs 28
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read) ; for M-.
  (setq xref-show-xrefs-function #'xref-show-definitions-buffer) ; for grep and the like
  (setq xref-file-name-display 'project-relative)
  (setq xref-search-program 'grep))
#+end_src
** Spelling
:PROPERTIES:
:ID:                     646035cd-ccc8-4a21-b116-f5d2269dbad9
:END:
The configuration below enables Flyspell for all text modes and sets Hunspell as the default checking program. The M-F7 key checks the spelling for all words in the buffer and F7 checks the word that you cursor is standing on.

A more productive method is to use the C-; function. This function provides the most likely correction of the first spelling error before the cursor is. Emacs will show the list of possible corrections in the mini buffer. Repeatedly pressing C-; will cycle through the options until you get back to the original. This function prevents you from having to jump to your spelling mistakes.
#+begin_src emacs-lisp
    (setup flyspell
      (:needs (or "hunspell"
                  "aspell"))
      (:load-after avy
        (:hook-into org-mode-hook git-commit-mode-hook markdown-mode-hook)
        (:bind "M-<f7>"  flyspell-buffer
               "<f7>"    flyspell-word
               "C-;"     flyspell-auto-correct-previous-word
               )
        (progn
          (cond
           ((executable-find "aspell")
            (setq ispell-program-name "aspell")
            (setq ispell-extra-args   '("--sug-mode=ultra"
                                        "--lang=en_AU")))
           ((executable-find "hunspell")
            (setq ispell-program-name "hunspell")
            (setq ispell-extra-args   '("-d en_AU"))))

          ;; Save a new word to personal dictionary without asking
          (setq ispell-silently-savep t)
          (setq ispell-default-dictionary "en_AU"))

        (defun avy-action-flyspell (pt)
          (save-excursion
            (goto-char pt)
            (when (require 'flyspell nil t)
              (flyspell-auto-correct-word)))
          (select-window
           (cdr (ring-ref avy-ring 0)))
          t)

        ;; Bind to semicolon (flyspell uses C-;)
        (setf (alist-get ?\; avy-dispatch-alist) 'avy-action-flyspell)

        (:when-loaded
          (:hide-mode))))
#+end_src

I use the dictionary package for Emacs, and I’m lazy about it:
#+begin_src emacs-lisp
  (setup (:pkg dictionary)
    (:load-after avy
      (defun dictionary-search-dwim (&optional arg)
        "Search for definition of word at point. If region is active,
    search for contents of region instead. If called with a prefix
    argument, query for word to search."
        (interactive "P")
        (if arg
            (dictionary-search nil)
          (if (use-region-p)
              (dictionary-search (buffer-substring-no-properties
                                  (region-beginning)
                                  (region-end)))
            (if (thing-at-point 'word)
                (dictionary-lookup-definition)
              (dictionary-search-dwim '(4))))))

      ;; dictionary
      (defun avy-action-define (pt)
        (save-excursion
          (goto-char pt)
          (dictionary-search-dwim))
        (select-window
         (cdr (ring-ref avy-ring 0)))
        t)

      (setf (alist-get ?= avy-dispatch-alist) 'dictionary-search-dwim))
    (:option dictionary-use-single-buffer t)
    (autoload 'dictionary-search "dictionary"
      "Ask for a word and search it in all dictionaries" t)
    (:hook #'reading-mode))

#+end_src

** Colour previewing
The following package reads a colour value, such as hexadecimal RGB, and sets the background for the value in that colour. Quite useful when reviewing my themes (rainbow-mode is activated manually).
#+begin_src emacs-lisp
(setup (:pkg rainbow-mode)
    (setq rainbow-ansi-colors nil)
    (setq rainbow-x-colors nil))

#+end_src
** Conveniences
*** Automatic time stamps for files (time-stamp.el)

The built-in time-stamp.el provides the means to automatically update a predefined header with the time its file was last edited/saved. This is, in my experience, particularly useful for packages that have a stable version but also need to disambiguate their latest tagged release from their current development state.

By default, this is done by checking the first eight lines of the file for the Time-stamp: <> entry. Though that is configurable. To properly utilise this library, you need to implement file-local variables. Those should control the exact format of the time stamp. For examples, this is what I have in my modus-themes.el:

;; Local Variables:
;; time-stamp-start: "Last-Modified:[ \t]+\\\\?[\"<]"
;; time-stamp-end: "\\\\?[\">]"
;; time-stamp-format: "%Y-%02m-%02d %02H:%02M:%02S %5z"
;; End:

Check M-x find-library RET time-stamp RET for all variables you may want to control.

All we do here is enable the package and add a hook to insert a time stamp upon save, where relevant. It works seamlessly.

#+begin_src emacs-lisp
;;; Automatic time stamps for files (time-stamp.el)
(setup (:require time-stamp)
  (add-hook 'before-save-hook #'time-stamp))

#+end_src
*** Auto revert mode
This mode ensures that the buffer is updated whenever the file changes. A change can happen externally or by some other tool inside of Emacs (e.g. kill a Magit diff).
#+begin_src emacs-lisp
(setup (:require autorevert)
          (setq auto-revert-check-vc-info t)
          (setq auto-revert-remote-files t)
          (setq global-auto-revert-non-file-buffers t)
          (setq auto-revert-verbose nil)
          (add-hook 'after-init-hook #'global-auto-revert-mode)
          (:hide-mode auto-revert))

#+end_src
*** Preserve contents of system clipboard

Say you copied a link from your web browser, then switched to Emacs to paste it somewhere. Before you do that, you notice something you want to kill. Doing that will place the last kill to the clipboard, thus overriding the thing you copied earlier. We can have a kill ring solution to this with the following:
#+begin_src emacs-lisp
;;; Preserve contents of system clipboard
(setq save-interprogram-paste-before-kill t)

#+end_src
Now the contents of the clipboard are stored in the kill ring and can be retrieved from there (e.g. with M-y).
*** Newline characters for file ending

For some major modes, such as diff-mode, a final newline is of paramount importance. Without it you cannot, for instance, apply a patch cleanly. As such, the mode-require-final-newline will add a newline character when visiting or saving a buffer of relevance.

#+begin_src emacs-lisp
;;; Newline characters for file ending
(setq mode-require-final-newline 'visit-save)

#+end_src

*** Zap characters
There are two kinds of “zap” functionality:

- `zap-up-to-char` will delete everything from point up to the character you provide it with. Think of how you may want to remove a file name but keep its file type extension, so M-x zap-up-to-char RET . will do just that.
- zap-to-char, which is bound to M-z by default, will delete the target character as well.

I bind the former to M-z as I use it more often and leave its counterpart on M-Z (M-S-z).
#+begin_src emacs-lisp
;;; Zap characters
(let ((map global-map))
  (define-key map (kbd "M-z") #'zap-up-to-char)
  (define-key map (kbd "M-Z") #'zap-to-char)) ; M-S-z

#+end_src
** Encodings & expand region
Setup encodings
#+begin_src emacs-lisp :noweb-ref sanity

(use-package encoding
  :straight nil
  :no-require t
  :config
      (setq coding-system-for-read 'utf-8-unix)
      (setq coding-system-for-write 'utf-8-unix)
      (setq default-process-coding-system '(utf-8-unix utf-8-unix))
      (setq locale-coding-system 'utf-8-unix)
      (setq selection-coding-system 'utf-8)
      (setq x-select-request-type nil)
      (setq-default buffer-file-coding-system 'utf-8-unix)
      (prefer-coding-system 'utf-8-unix)
      (set-clipboard-coding-system 'utf-8)
      (set-default-coding-systems 'utf-8-unix)
      (set-keyboard-coding-system 'utf-8-unix)
      (set-language-environment "UTF-8")
      (set-selection-coding-system 'utf-8)
      (set-terminal-coding-system 'utf-8-unix))

#+end_src
Setup undo , whitespace, expand, indentation
#+begin_src emacs-lisp
  ;; (setup (:pkg aggressive-indent)
  ;;   (:hook-into prog-mode)
  ;;   (:hide-mode))

  ;; (setup (:pkg hungry-delete)
  ;;   (:load-after smartparens
  ;;     (setq hungry-delete-join-reluctantly t)
  ;;     (global-hungry-delete-mode 1)
  ;;     (:hook-into smartparens-enabled)
  ;;     (:hide-mode)))

   (setup (:pkg expand-region)
    (:require expand-region))

  ;; (setup (:pkg undo-fu undo-fu-session)
  ;;   (:with-map (prog-mode-map text-mode-map)
  ;;     (:bind
  ;;      "u" undo-fu-only-undo
  ;;      "C-r" undo-fu-only-redo))
  ;;   (setq undo-fu-session-incompatible-files
  ;;         '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'"))
  ;;   (global-undo-fu-session-mode 1))



#+end_src

** Buffers in Emacs
:PROPERTIES:
:header-args: :noweb-ref buffers
:ID:                     e82ac276-b2db-434f-83aa-da6df0f3b90e
:END:
Setup the buffers to my liking
#+begin_src emacs-lisp
  (defvar buffer-fallback-name "*scratch*"
    "The name of the buffer to fall back to.
    Used when no other buffers exist.")

  (defun buffer-fallback ()
    "Return the fallback buffer, creating it if necessary.
    By default this is the scratch buffer. See
    `buffer-fallback-name' to change this."
    (get-buffer-create buffer-fallback-name))

  

  (defun buffer-display-and-switch (buffer-or-name)
    "Display BUFFER-OR-NAME in some window and switch to it."
    (select-window (display-buffer buffer-or-name)))

  

  (defvar buffer-messages-display-fn #'buffer-display-and-switch
    "The function to use to display messages buffer.
    Must accept one argument: the buffer to display.")

  (defvar buffer-messages-name "*Messages*"
    "The name of the messages buffer.")

  (defun buffer-pop-messages ()
    "Open `buffer-messages-name' buffer."
    (interactive)
    (funcall buffer-messages-display-fn
             (get-buffer-create buffer-messages-name)))

  (defun buffer-switch-to-messages ()
    "Open `buffer-messages-name' buffer."
    (interactive)
    (let ((buffer-messages-display-fn #'switch-to-buffer))
      (buffer-pop-messages)))

  

  (defvar buffer-scratch-files-dir (concat *emacs-etc/* "scratch/")
    "Where to store project scratch files.
    Files are created by `buffer-open-project-scratch'.")

  (defvar buffer-scratch-display-fn #'buffer-display-and-switch
    "The function to use to display the scratch buffer.
    Must accept one argument: the buffer to display.")

  (defvar buffer-scratch-major-mode nil
    "What major mode to use in scratch buffers.
    This can be one of the following:
      t          Inherits the major mode of the last buffer you had
                 selected.
      nil        Uses `fundamental-mode'
      MAJOR-MODE  Any major mode symbol")

  (defvar buffer-scratch-hook ()
    "The hooks to run after a scratch buffer is made.")

  (defun buffer-scratch (&optional file mode text)
    "Return a scratch buffer in major MODE with TEXT in it.
    If FILE is a valid path, open it as if it were a persistent
    scratch."
    (if file (setq file (file-truename file)))
    (let ((buffer
           (if file
               (with-current-buffer (find-file-noselect file)
                 (rename-buffer (format "*scratch (%s)*"
                                        (file-name-nondirectory file)))
                 (current-buffer))
             (get-buffer-create "*scratch*"))))
      (with-current-buffer buffer
        (when (and (functionp mode)
                   (not (eq major-mode mode)))
          (funcall mode))
        (when text
          (insert text))
        (run-hooks 'buffer-scratch-hook)
        (current-buffer))))

  (defun buffer-pop-scratch (&optional arg)
    "Opens a scratch pad window in the same `major-mode'.
    If ARG (universal argument), then open a persistent scratch
    buffer. You'll be prompted for its name, or to open a previously
    created. These are stored in `buffer-scratch-files-dir'.
    If a region is active, copy its contents to the scratch."
    (interactive "P")
    (funcall
     buffer-scratch-display-fn
     (buffer-scratch
      (when arg
        (if-let* ((file (read-file-name
                         "Ouvrir le fichier de scratch > "
                         buffer-scratch-files-dir
                         "scratch")))
            file
          (user-error "Abandon..")))
      (cond ((eq buffer-scratch-major-mode t)
             (unless (or buffer-read-only
                         (derived-mode-p 'special-mode)
                         (string-match-p "^ ?\\*" (buffer-name)))
               major-mode))
            ((null buffer-scratch-major-mode) nil)
            ((symbolp buffer-scratch-major-mode)
             buffer-scratch-major-mode))
      (and (region-active-p)
           (buffer-substring-no-properties
            (region-beginning) (region-end))))))

  (defun buffer-switch-to-scratch (&optional arg)
    "Switch to a scratch buffer in the current window.
    Otherwise, does exactly what `buffer-pop-scratch' does.
    ARG is passed to `buffer-pop-scratch'."
    (interactive "P")
    (let ((buffer-scratch-display-fn #'switch-to-buffer))
      (buffer-pop-scratch arg)))

  (defun buffer-delete-scratch-files ()
    "Deletes all scratch buffers in `buffer-scratch-files-dir'."
    (interactive)
    (dolist (file (directory-files buffer-scratch-files-dir
                                   t "[^.]" t))
      (delete-file file)
      (message "Supprimé '%s'" (file-name-nondirectory file))))

  

  (defun buffer-sudo-edit (&optional arg)
    "Edit currently visited file as root.
    With a prefix ARG prompt for a file to visit. Will also prompt
    for a file to visit if current buffer is not visiting a file."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (read-file-name "Rechercher le fichier (en tant que root): ")))
      (find-alternate-file
       (concat "/sudo:root@localhost:"
               buffer-file-name))))

  

  (defhydra hydra-buffer-menu (:color pink
                                      :hint nil)
    "
  ^Mark^             ^Unmark^           ^Actions^          ^Search
  ^^^^^^^^-----------------------------------------------------------------
  _m_: mark          _u_: unmark        _x_: execute       _R_: re-isearch
  _s_: save          _U_: unmark up     _b_: bury          _I_: isearch
  _d_: delete        ^ ^                _g_: refresh       _O_: multi-occur
  _D_: delete up     ^ ^                _T_: files only: % -28`Buffer-menu-files-only
  _~_: modified
  "
    ("m" Buffer-menu-mark)
    ("u" Buffer-menu-unmark)
    ("U" Buffer-menu-backup-unmark)
    ("d" Buffer-menu-delete)
    ("D" Buffer-menu-delete-backwards)
    ("s" Buffer-menu-save)
    ("~" Buffer-menu-not-modified)
    ("x" Buffer-menu-execute)
    ("b" Buffer-menu-bury)
    ("g" revert-buffer)
    ("T" Buffer-menu-toggle-files-only)
    ("O" Buffer-menu-multi-occur :color blue)
    ("I" Buffer-menu-isearch-buffers :color blue)
    ("R" Buffer-menu-isearch-buffers-regexp :color blue)
    ("c" nil "cancel")
    ("v" Buffer-menu-select "select" :color blue)
    ("o" Buffer-menu-other-window "other-window" :color blue)
    ("q" quit-window "quit" :color blue))

  (define-key Buffer-menu-mode-map "." 'hydra-buffer-menu/body)

#+end_src

#+begin_src emacs-lisp
  (setup scratch
   ;; (setq initial-major-mode #'emacs-lisp-mode)
    (setq initial-scratch-message
          ";; ABANDONNEZ TOUT ESPOIR VOUS QUI ENTREZ ICI\n\n" )
  ;;   (defun +scratch-immortal ()
  ;;     "Bury, don't kill \"*scratc*\" buffer.
  ;;       For `kill-buffer-query-functions'."
  ;;     (if (eq (current-buffer) (get-buffer "*scratch*"))
  ;;         (progn (bury-buffer)
  ;;                nil)
  ;;       t))
  ;;   (defun +scratch-buffer-setup ()
  ;;     "Add comment to `scratch' buffer and name it accordingly."
  ;;     (let* ((mode (format "%s" major-mode))
  ;;            (string (concat "Scratch buffer for:" mode "\n\n")))
  ;;       (when scratch-buffer
  ;;         (save-excursion
  ;;           (insert string)
  ;;           (goto-char (point-min))
  ;;           (comment-region (point-at-bol) (point-at-eol)))
  ;;         (next-line 2))
  ;;       (rename-buffer (concat "*scratch<" mode ">*") t)))
  ;;   (add-hook 'kill-buffer-query-functions #'+scratch-immortal)
     )

  (use-package region-bindings
  :straight nil
  :bind ( :map region-bindings-mode-map
          ("q" . region-bindings-disable)
          ("r" . replace-string)
          ("R" . replace-regexp))
  :preface
  (define-minor-mode region-bindings-mode
    "Minor mode for mapping commands while region is active.
\\<region-bindings-mode-map>"
    :lighter " rbm"
    :group 'convenience
    :keymap (make-sparse-keymap))
  (defun region-bindings-disable (&optional force)
    "Turn off bindings temporarely while keeping the region active.
Bindings will be enabled next time region is highlighted."
    (interactive)
    (region-bindings-mode -1))
  (defun region-bindings-enable ()
    "Enable bindings temporarely while keeping the region active."
    (interactive)
    (when (or transient-mark-mode
              (eq #'mouse-set-region this-command))
      (region-bindings-mode 1)))
  (defun region-bindings-mode-enable ()
    "Enable region bindings for all buffers."
    (interactive)
    (add-hook 'activate-mark-hook #'region-bindings-enable)
    (add-hook 'deactivate-mark-hook #'region-bindings-disable))
  (defun region-bindings-mode-disable ()
    "Disable region bindings."
    (interactive)
    (remove-hook 'activate-mark-hook #'region-bindings-enable)
    (remove-hook 'deactivate-mark-hook #'region-bindings-disable)
    (region-bindings-mode -1))
  (provide 'region-bindings)
  :init
  (region-bindings-mode-enable))
#+end_src
*** Ibuffer and extras
ibuffer.el ships with Emacs and it provides a drop-in replacement for list-buffers. Compared to its counterpart, it allows for granular control over the buffer list and is more powerful overall. For this reason I bind it to C-x C-b.

Overview of its features:

- mark and delete buffers same way you do in dired (see the previous sections on dired (directory editor, file manager));
- mark by a predicate, such as name, major mode, etc.;
- sort buffers by name, filesystem path, major mode, size;
- run occur on the marked buffers (remember: Occur produces a buffer that you can edit once you enable the editable state with e);
- run query-replace or query-replace-regexp on marked buffers.

Run the universal help command for major mode documentation (C-h m) while inside ibuffer to get a detailed list of all available commands and their key bindings.
#+begin_src emacs-lisp
(setup ibuffer
    (:also-load ibuf-ext)
    (:option ibuffer-expert t
               ibuffer-display-summary nil
               ibuffer-use-other-window nil
               ibuffer-show-empty-filter-groups nil
               ibuffer-movement-cycle nil
               ibuffer-default-sorting-mode 'filename/process
               ibuffer-use-header-line t
               ibuffer-default-shrink-to-minimum-size nil
               ibuffer-formats
               '((mark modified read-only locked " "
                  (name 40 40 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " " filename-and-process)
                 (mark " "
                  (name 16 -1)
                  " " filename))
               ibuffer-saved-filter-groups nil
               ibuffer-old-time 48)
      (:global "C-x C-b" #'ibuffer)
      (:hook hl-line-mode)
      ;; (let ((map ibuffer-mode-map))
      ;;   (define-key map (kbd "* f") #'ibuffer-mark-by-file-name-regexp)
      ;;   (define-key map (kbd "* g") #'ibuffer-mark-by-content-regexp) ; "g" is for "grep"
      ;;   (define-key map (kbd "* n") #'ibuffer-mark-by-name-regexp)
      ;;   (define-key map (kbd "s n") #'ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
      ;;   (define-key map (kbd "/ g") #'ibuffer-filter-by-content))
  )

#+end_src
The default way Emacs makes buffer names unique is really ugly and,
  dare I say it, stupid.  Instead, I want them to be uniquified by their
  filesystem paths.

#+begin_src emacs-lisp
(setup (:require uniquify)
  (setq uniquify-after-kill-buffer-p t)
  (setq uniquify-buffer-name-style 'forward)
  (setq-default
   uniquify-separator "/"
   uniquify-ignore-buffers-re "^\\*"))

#+end_src
** init-editor tangle
:PROPERTIES:
:header-args: :tangle lisp/init-editor.el :noweb yes
:END:
Setup Editor functions

#+begin_src emacs-lisp
;;; init-editor.el --- Editor  -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(require 'init-elpa)
(require 'init-kbd)
(require 'lib-vcs)
(require 'lib-string)


<<pkg-editor>>

(provide 'init-editor)
;;; init-editor.el ends here
#+end_src
* Emacs UI Appearance
** Default Appearance setting
Some Defaults for my preferred appearance
#+begin_src emacs-lisp :noweb-ref appearance
  (use-package local-config
    :straight nil
    :preface
    (defgroup local-config ()
      "Customisation group for local settings."
      :prefix "local-config-"
      :group 'emacs)
    (defcustom local-config-title-show-bufname t
      "Whether to include bufname in the title bar.
    Bufname is not necessary on GNOME but may be useful in other DEs."
      :type 'boolean
      :tag "Title bufname"
      :group 'local-config)
    (defcustom local-config-dark-theme 'modus-vivendi
      "Dark theme to use."
      :tag "Dark theme"
      :type 'symbol
      :group 'local-config)
    (defcustom local-config-light-theme 'modus-operandi
      "Light theme to use."
      :tag "Light theme"
      :type 'symbol
      :group 'local-config)
    (defvar local-config-line-pixel-height (line-pixel-height)
      "Line height in pixels.
    Used in various places to avoid getting wrong line height when
    `text-scale-mode' is active.")
    (provide 'local-config)
    :hook (prog-mode text-mode conf-mode)
    :init
     (add-hook 'prog-mode-hook #'display-line-numbers-mode )
     (add-hook 'text-mode-hook #'visual-line-mode )
    :config
    (setq-default
     inhibit-startup-message t
     inhibit-startup-screen t
     inhibit-startup-echo-area-message user-login-name
     inhibit-default-init t
     initial-major-mode 'fundamental-mode
     initial-scratch-message nil
     use-file-dialog nil
     use-dialog-box nil)

    (setq display-time-default-load-average nil)
    (setq echo-keystrokes 0.1)
    (setq highlight-nonselected-windows nil)
    (setq visible-bell nil)
    (setq x-gtk-use-system-tooltips nil)
    (setq x-stretch-cursor nil)

    ;; update
    (setq idle-update-delay 1.0)

    ;; disable cursor blinking
    (blink-cursor-mode -1)
    (setq blink-matching-paren nil)
    ;; hide cursors in other windose
    (setq-default cursor-in-non-selected-windows nil)
    (setq-default cursor-type 'hbar)

    ;; play around with frame title (which I rarely see)
    (setq frame-title-format
	  '("%b@"
	    (:eval (or (file-remote-p default-directory 'host)
		       system-name))
	    " — Emacs"))

    ;; y/n instead of yes/no
    (fset #'yes-or-no-p #'y-or-n-p)

    ;; mode line
    (column-number-mode)
    (size-indication-mode)
    ;; Wait until my *fancy* modeline is loaded -- from Furkan Karataş.
    (setq-default mode-line-format nil)

    ;; line numbers
    (setq-default display-line-numbers-widen t)
    (setq-default display-line-numbers-width 3)

    (setq-default
     ;; no beeping and no blinking please
     ring-bell-function #'ignore
     visible-bell nil

     ;; make sure that trash is not drawn
     indicate-buffer-boundaries nil
     indicate-empty-lines nil

     ;; don't resize emacs in steps, it looks weird and plays bad with
     ;; window manager.
     window-resize-pixelwise t
     frame-resize-pixelwise t

     ;; disable bidirectional text for tiny performance boost
     bidi-display-reordering 'left-to-right
     bidi-paragraph-direction 'left-to-right

     ;; truncate lines
     truncate-lines t))

  

  (use-package formfeed
    :straight nil
    :preface
    (defun formfeed-make-display-line ()
      "Display the formfeed ^L char as a comment or as a continuous line."
      (unless buffer-display-table
	(setq buffer-display-table (make-display-table)))
      (aset buffer-display-table ?\^L
	    (vconcat (make-list (or fill-column 70)
				(make-glyph-code
				 (string-to-char (or comment-start "-"))
				 'shadow)))))
    (provide 'formfeed)
    :init
    (dolist (mode-hook '(help-mode-hook
			 org-mode-hook
			 outline-mode-hook
			 prog-mode-hook))
      (add-hook mode-hook #'formfeed-make-display-line)
      ))

  

#+end_src
** Menu bar & fringe on
#+begin_src elisp  :tangle no
(menu-bar-mode -1)            ; Disable the menu bar
(unless *is-termux?*
  (set-fringe-mode 10)        ; Give some breathing room
  (menu-bar-mode 1))          ; I like menu whilst learning



#+end_src
** Fonts, Emojis & Icons

On Linux, I have a custom build of Iosevka that I like.

#+begin_src emacs-lisp :noweb-ref fonts
    (use-package all-the-icons
      :after (marginalia dired)
      :init
      (add-hook 'marginalia-mode #'all-the-icons-completion-marginalia-setup)
      (add-hook 'dired-mode #'all-the-icons-dired-mode)
      :config
      (use-package all-the-icons-dired)
      (use-package all-the-icons-completion
	:config
	(all-the-icons-completion-mode 1)))

    (use-package emojify
      :config
      (setq emojify-emoji-styles '(unicode))
      (global-emojify-mode 1))

    (use-package unicode-fonts
      :config
      (unicode-fonts-setup))

   ;; (use-package mixed-pitch
   ;;   :config
   ;;   :hook (text-mode org-mode))

    ;;; Font configurations (prot-fonts.el)
    (use-package prot-fonts
      :straight nil
      :load-path *gas-lisp/*
      :config
      ;; This is defined in Emacs C code: it belongs to font settings.
      (setq x-underline-at-descent-line t)

      ;; And this is for Emacs28.
      ;;(setq-default text-scale-remap-header-line t)

      ;; Make sure to read the `prot-fonts-typeface-sets-alist' doc string,
      ;; as it explains what those property lists should contain.
      ;;
      ;; The version of "Hack" that I custom is a custom build on mine:
      ;; <https://gitlab.com/protesilaos/hack-font-mod>.  Same principle for
      ;; Iosevka Comfy: <https://gitlab.com/protesilaos/iosevka-comfy>.
      (setq prot-fonts-typeface-sets-alist
	    '((small . ( :fixed-pitch-family "JetBrains Mono"
			 :fixed-pitch-regular-weight regular
			 :fixed-pitch-heavy-weight bold
			 :fixed-pitch-height 75
			 :fixed-pitch-line-spacing 1
			 :variable-pitch-family "Iosevka Aile"
			 :variable-pitch-height 1.05
			 :variable-pitch-regular-weight normal))

	      (small-alt . ( :fixed-pitch-family "JetBrains Mono"
			     :fixed-pitch-regular-weight regular
			     :fixed-pitch-heavy-weight extrabold
			     :fixed-pitch-height 80
			     :fixed-pitch-line-spacing 1
			     :variable-pitch-family "Iosevka Aile"
			     :variable-pitch-height 1.0
			     :variable-pitch-regular-weight normal))

	      (regular . ( :fixed-pitch-family "JetBrains Mono"
			   :fixed-pitch-regular-weight regular
			   :fixed-pitch-heavy-weight extrabold
			   :fixed-pitch-height 100
			   :fixed-pitch-line-spacing nil
			   :variable-pitch-family "Iosevka Aile"
			   :variable-pitch-height 1.0
			   :variable-pitch-regular-weight normal))

	      (large . ( :fixed-pitch-family "JetBrains Mono"
			 :fixed-pitch-regular-weight semilight
			 :fixed-pitch-heavy-weight bold
			 :fixed-pitch-height 135
			 :fixed-pitch-line-spacing nil
			 :variable-pitch-family "Iosevka Aile"
			 :variable-pitch-height 1.0
			 :variable-pitch-regular-weight normal))

	      (large-alt . ( :fixed-pitch-family "JetBrains Mono"
			     :fixed-pitch-regular-weight normal
			     :fixed-pitch-heavy-weight bold
			     :fixed-pitch-height fixed
			     :130-pitch-line-spacing nil
			     :variable-pitch-family "FiraGO"
			     :variable-pitch-height 1.05
			     :variable-pitch-regular-weight normal))))

    ;; TODO 2021-08-27: I no longer have a laptop.  Those configurations
    ;; are not relevant, but I keep them around as the idea is still good.

    ;; The value of `prot-fonts--laptop-desktop-keys-list' becomes '(small
    ;; regular) based on the car of the first two cons cells found in
    ;; `prot-fonts-typeface-sets-alist'.  The assumption is that those
    ;; contain sets from smaller to larger display types.
    (setq prot-fonts--laptop-desktop-keys-list
	  (prot-fonts--laptop-desktop-keys))

      ;; This is the breakpoint, in pixels, for determining whether we are
      ;; on the small or large screen layout.  The number here is my
      ;; laptop's screen width, while it expands beyond that when I connect
      ;; it to an external monitor (how I normally set it up on my desk).
      (setq prot-fonts-max-small-resolution-width 1366)

      ;; And this just sets the right font depending on whether my laptop is
      ;; connected to an external monitor or not.
      (prot-fonts-fonts-per-monitor)

      ;; See theme section for this hook and also read the doc string of
      ;; `prot-fonts-restore-last'.
      :init
      (add-hook 'modus-themes-after-load-theme-hook #'prot-fonts-restore-last)
       :bind
	(( "C-c f"  . prot-fonts-set-fonts)
	 ( "C-c F"  . prot-fonts-set-default-font)))

    ;; Required for proportional font in posframe
    (use-package company-posframe
      :config
      (company-posframe-mode 1))

    (use-package default-text-scale
      :bind (( "M--" . default-text-scale-decrease)
	     ( "M-+" . default-text-scale-increase)
	     ( "M-=" . default-text-scale-reset))
      :config
      (setq default-text-scale-mode 1))

    ;; Dimm the colours of inactive windows
    (use-package dimmer
      :config
      (setq dimmer-fraction 0.3)
      (setq dimmer-adjustment-mode :foreground)
      (setq dimmer-use-colorsapce :rgb)
      (dimmer-mode 1))

    ;; Install it from sources, because ELPA version has invalid
    ;; signature.
    (use-package spinner
      :straight '( spinner
		   :type git
		   :host github
		   :repo "Malabarba/spinner.el"))
#+end_src

** Mouse & scrolling setup and initial framesize

#+begin_src emacs-lisp :noweb-ref mouse

(unless *is-termux?*
  (setup mouse
	 (setq focus-follows-mouse t)
	 (setq make-pointer-invisible t)
	 (setq mouse-1-click-follows-link t)
	 (setq mouse-autoselect-window t)
	 (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
	 (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
	 ;;(setq mouse-wheel-scroll-amount '(3 ((shift) . hscroll)))
	 (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
	 (setq mouse-wheel-scroll-amount-horizontal 2)
	 (setq mouse-yank-at-point t)
	 (setq scroll-step 1) ;; keyboard scroll one line at a time
	 (setq use-dialog-box nil))) ;; Disable dialog boxes since they weren't working in Mac OSX


(unless *is-termux?*
  (setup scrolling
	 (setq auto-hscroll-mode 'current-line)
	 (setq auto-window-vscroll nil)
	 (setq fast-but-imprecise-scrolling t)
	 (setq hscroll-margin 16)
	 (setq hscroll-step 1)
	 (setq scroll-conservatively 101)
	 (setq scroll-margin 8)
	 (setq scroll-preserve-screen-position t)
	 (setq scroll-step 1)))

(unless *is-termux?*
  (set-frame-parameter (selected-frame) 'alpha '(90 . 90))
  (add-to-list 'default-frame-alist '(alpha . (90 . 90)))
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized)))



#+end_src

** Themes & Modeline

#+begin_src emacs-lisp :noweb-ref modus
    ;;; Modus themes (Prositelaus highly accessible themes)
    (use-package modus-themes
      ;; Add all your customisations prior to loading the themes
      ;;
      :requires highlight-parentheses
      ;; Also check my package configurations for `prot-fonts' because I use
      ;; the `modus-themes-after-load-theme-hook' for some typeface-related
      ;; tweaks (as those are made at the "face" level).
      :bind ( "<f5>" .  #'modus-themes-toggle)
      :config
      (setq modus-themes-italic-constructs t
	    modus-themes-bold-constructs t
	    modus-themes-mixed-fonts nil
	    modus-themes-subtle-line-numbers nil
	    modus-themes-intense-mouseovers nil
	    modus-themes-deuteranopia t
	    modus-themes-tabs-accented nil
	    modus-themes-variable-pitch-ui t
	    modus-themes-inhibit-reload t ; only applies to `customize-set-variable' and related

	    modus-themes-fringes nil ; {nil,'subtle,'intense}

	    ;; Options for `modus-themes-lang-checkers' are either nil (the
	    ;; default), or a list of properties that may include any of those
	    ;; symbols: `straight-underline', `text-also', `background',
	    ;; `intense' OR `faint'.
	    modus-themes-lang-checkers nil

	    ;; Options for `modus-themes-mode-line' are either nil, or a list
	    ;; that can combine any of `3d' OR `moody', `borderless',
	    ;; `accented', a natural number for extra padding (or a cons cell
	    ;; of padding and NATNUM), and a floating point for the height of
	    ;; the text relative to the base font size (or a cons cell of
	    ;; height and FLOAT)
	    modus-themes-mode-line '(borderless accented (padding . 4) (height . 0.9))

	    ;; Options for `modus-themes-markup' are either nil, or a list
	    ;; that can combine any of `bold', `italic', `background',
	    ;; `intense'.
	    modus-themes-markup nil

	    ;; Options for `modus-themes-syntax' are either nil (the default),
	    ;; or a list of properties that may include any of those symbols:
	    ;; `faint', `yellow-comments', `green-strings', `alt-syntax'
	    modus-themes-syntax nil

	    ;; Options for `modus-themes-hl-line' are either nil (the default),
	    ;; or a list of properties that may include any of those symbols:
	    ;; `accented', `underline', `intense'
	    modus-themes-hl-line '(intense)

	    ;; Options for `modus-themes-paren-match' are either nil (the
	    ;; default), or a list of properties that may include any of those
	    ;; symbols: `bold', `intense', `underline'
	    modus-themes-paren-match '(intense)

	    ;; Options for `modus-themes-links' are either nil (the default),
	    ;; or a list of properties that may include any of those symbols:
	    ;; `neutral-underline' OR `no-underline', `faint' OR `no-color',
	    ;; `bold', `italic', `background'
	    modus-themes-links nil

	    ;; Options for `modus-themes-box-buttons' are either nil (the
	    ;; default), or a list that can combine any of `flat',
	    ;; `accented', `faint', `variable-pitch', `underline', the
	    ;; symbol of any font weight as listed in
	    ;; `modus-themes-weights', and a floating point number
	    ;; (e.g. 0.9) for the height of the button's text.
	    modus-themes-box-buttons '(variable-pitch flat faint 0.9)

	    ;; Options for `modus-themes-prompts' are either nil (the
	    ;; default), or a list of properties that may include any of those
	    ;; symbols: `background', `bold', `gray', `intense', `italic'
	    modus-themes-prompts '(background subtle)

	    ;; The `modus-themes-completions' is an alist that reads three
	    ;; keys: `matches', `selection', `popup'.  Each accepts a nil
	    ;; value (or empty list) or a list of properties that can include
	    ;; any of the following (for WEIGHT read further below):
	    ;;
	    ;; `matches' - `background', `intense', `underline', `italic', WEIGHT
	    ;; `selection' - `accented', `intense', `underline', `italic', `text-also', WEIGHT
	    ;; `popup' - same as `selected'
	    ;; `t' - applies to any key not explicitly referenced (check docs)
	    ;;
	    ;; WEIGHT is a symbol such as `semibold', `light', or anything
	    ;; covered in `modus-themes-weights'.  Bold is used in the absence
	    ;; of an explicit WEIGHT.
	    modus-themes-completions
	    '((matches . (extrabold background))
	      (selection . (semibold intense accented text-also))
	      (popup . (accented intense)))

	    modus-themes-mail-citations nil ; {nil,'intense,'faint,'monochrome}

	    ;; Options for `modus-themes-region' are either nil (the default),
	    ;; or a list of properties that may include any of those symbols:
	    ;; `no-extend', `bg-only', `accented'
	    modus-themes-region '(no-extend bg-only)

	    ;; Options for `modus-themes-diffs': nil, 'desaturated, 'bg-only
	    modus-themes-diffs 'desaturated

	    modus-themes-org-blocks nil ; {nil,'gray-background,'tinted-background}

	    modus-themes-org-agenda ; this is an alist: read the manual or its doc string
	    '((header-block . (variable-pitch regular 1.4))
	      (header-date . (bold-today grayscale underline-today 1.2))
	      (event . (accented varied))
	      (scheduled . uniform)
	      (habit . nil))

	    modus-themes-headings ; this is an alist: read the manual or its doc string
	    '((1 . (variable-pitch light 1.6))
	      (2 . (variable-pitch regular 1.4))
	      (3 . (variable-pitch regular 1.3))
	      (4 . (1.2))
	      (5 . (1.1))
	      (t . (monochrome 1.05)))
	    )

      ;; Load the theme files before enabling a theme (else you get an error).
      (modus-themes-load-themes)

      ;; (defun prot/modus-themes-custom-faces ()
      ;;   (modus-themes-with-colors
      ;;    (custom-set-faces
      ;;     `(cursor ((,class :background ,magenta-intense)))
      ;;     `(fill-column-indicator ((,class :background ,bg-inactive
      ;;                                      :foreground ,bg-inactive))))))

      ;; (add-hook 'modus-themes-after-load-theme-hook #'prot/modus-themes-custom-faces)

      ;; Enable the theme at startup.  This is done after loading the files.
      ;; You only need `modus-themes-load-operandi' for the light theme or
      ;; `modus-themes-load-vivendi' for the dark one.  What I have here is
      ;; a simple test to load a light/dark theme based on some general time
      ;; ranges (just accounting for the hour and without checking for the
      ;; actual sunrise/sunset times).  Plus we have `modus-themes-toggle'
      ;; to switch themes at will.
      (let ((time (string-to-number (format-time-string "%H"))))
	(if (and (> time 7) (< time 18))
	    (modus-themes-load-operandi)
	  (modus-themes-load-vivendi)))
      )

    (use-package highlight-parentheses
      ;;:requires  highlight-parentheses
      ;; :straight (:type built-in)
      :config
      (defvar my-highlight-parentheses-use-background t
	"Prefer `highlight-parentheses-background-colors'.")

      ;;(setq my-highlight-parentheses-use-background nil) ; Set to nil to disable backgrounds

      (defun my-modus-themes-highlight-parentheses ()
	(modus-themes-with-colors
	 ;; Our preference for setting either background or foreground
	 ;; styles, depending on `my-highlight-parentheses-use-background'.
	 (if my-highlight-parentheses-use-background

	     ;; Here we set color combinations that involve both a background
	     ;; and a foreground value.
	     (setq highlight-parentheses-background-colors
		   (list cyan-refine-bg
			 magenta-refine-bg
			 green-refine-bg
			 yellow-refine-bg)
		   highlight-parentheses-colors (list cyan-refine-fg
						      magenta-refine-fg
						      green-refine-fg
						      yellow-refine-fg))

	   ;; And here we pass only foreground colors while disabling any
	   ;; backgrounds.
	   (setq highlight-parentheses-colors (list green-intense
						    magenta-intense
						    blue-intense
						    red-intense)
		 highlight-parentheses-background-colors nil)))

	;; Include this if you also want to make the parentheses bold:
	(set-face-attribute 'highlight-parentheses-highlight nil :inherit 'bold)

	;; Our changes must be evaluated before enabling the relevant mode, so
	;; this comes last.
	(global-highlight-parentheses-mode 1))
      :init
      (add-hook 'modus-themes-after-load-theme-hook #'my-modus-themes-highlight-parentheses)
      (add-hook 'minibuffer-setup-hook #'highlight-parentheses-minibuffer-setup))

    (use-package doom-themes
      :config
      (setq doom-themes-enable-bold t)
      (setq doom-themes-enable-italic t)
      (doom-themes-org-config))

    (unless *is-termux?*
      ;; (modus-themes-load-vivendi)
      ;;(load-theme 'doom-one-light t)
      (doom-themes-visual-bell-config))

    ;; Mode-line
    ;;Basic Customisation
    (setq display-time-format "%l:%M %p %b %y"
	  display-time-default-load-average nil)

    ;; Doom Modeline

    (use-package minions
      :hook doom-modeline-mode)

    (use-package doom-modeline
      :init
      (add-hook 'window-setup-hook #'(face-remap-add-relative  'mode-line nil :family "Iosevka Slab" :height 140))
      (add-hook 'doom-modeline-mode #'(face-remap-add-relative  'mode-line nil :family "Iosevka Slab" :height 130))
      :custom-face
      (mode-line ((t (:height 0.85))))
      (mode-line-inactive ((t (:height 0.85))))
      :config
      ;; (setq doom-modeline-bar-width 4)
      (setq doom-modeline-buffer-encoding nil)
      (setq doom-modeline-buffer-file-name-style 'relative-from-project)
      (setq doom-modeline-height 30)
      (setq doom-modeline-major-mode-icon t)
      (setq doom-modeline-minor-modes t)
      ;;(:with-hook window-setup-hook
      ;;  (:hook (fn (set-face-attribute
      ;;		      'mode-line nil :family "Iosevka Slab" :height 130))))
      ;;(:hook-into window-setup)
      (setq doom-modeline-height 15
	    doom-modeline-bar-width 6
	    doom-modeline-lsp t
	    doom-modeline-github nil
	    doom-modeline-mu4e nil
	    doom-modeline-irc t
	    doom-modeline-minor-modes t
	    doom-modeline-persp-name nil
	    doom-modeline-buffer-file-name-style 'truncate-except-project
	    doom-modeline-major-mode-icon nil))

    (use-package bui
      :defer t)

#+end_src
** highlights and diff
:PROPERTIES:
:ID:                     6d744ef7-add5-408d-8f5f-e7112027ce62
:END:
setup diff and highlights
#+begin_src emacs-lisp :noweb-ref highlights
  (use-package highlight-numbers
    :delight t
    ;;:hook prog-mode
     )

  (use-package hl-fill-column
    :requires hl-fill-column
    :hook (prog-mode text-mode conf-mode))

  (use-package hl-line
    :config
      (global-hl-line-mode 1))

  (use-package hl-todo
    :config
     (global-hl-todo-mode 1))

  (use-package diff-hl
    :after magit
    :init
    (add-hook 'dired-mode #'diff-hl-dired-mode)
    (add-hook 'magit-pre-refesh-hook #'diff-hl-magit-pre-refresh)
    (add-hook 'magit-post-refesh-hook #'diff-hl-magit-post-refresh)
    :config
    (global-diff-hl-mode 1))

#+end_src
** Window Setup
:PROPERTIES:
:header-args: :noweb-ref windose
:ID:                     1c36aad2-dfb6-4189-9aea-45732dba3d5d
:END:

1st some defaults

#+begin_src emacs-lisp
  (setup windows
      (setq display-buffer-alist
        `(;; no window
          ("\\`\\*Async Shell Command\\*\\'"
           (display-buffer-no-window))
          ;; top side window
          ("\\*\\(Flymake diagnostics\\|Package-Lint\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Flymake log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2))
          ;; left side window
          ("\\*\\(.* # Help.*\\|Help\\)\\*"    ; See the hooks for `visual-line-mode'
           (display-buffer-reuse-mode-window display-buffer-in-side-window)
           (window-width . 0.25)
           (side . left)
           (slot . 0))
          ;; right side window
          ("\\*keycast\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (window-width . 0.25)
           (side . right)
           (slot . -1)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; bottom side window
          ("\\*Org Select\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((mode-line-format . none))))
          ;; bottom buffer (NOT side window)
          ("\\*Embark Actions\\*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . fit-window-to-buffer)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; below current window
          ("\\*.*\\(e?shell\\|v?term\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected))
          ("\\*\\vc-\\(incoming\\|outgoing\\|git : \\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           ;; NOTE 2021-10-06: we cannot `fit-window-to-buffer' because
           ;; the height is not known in advance.
           (window-height . 0.2))
          ("\\*\\(Calendar\\|Bookmark Annotation\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . fit-window-to-buffer))))
      ;;(setq split-height-threshold nil)
      ;;(setq split-width-threshold 160)
      (setq window-divider-default-bottom-width 2)
      (setq window-divider-default-places t)
      (setq window-divider-default-right-width 2)
      (setq window-resize-pixelwise nil)
      (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)

  (add-hook 'help-mode-hook #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)

  (let ((map global-map))
    (define-key map (kbd "C-x <down>") #'next-buffer)
    (define-key map (kbd "C-x <up>") #'previous-buffer)
    (define-key map (kbd "C-x C-n") #'next-buffer)     ; override `set-goal-column'
    (define-key map (kbd "C-x C-p") #'previous-buffer) ; override `mark-page'
    (define-key map (kbd "C-x !") #'delete-other-windows-vertically)
    (define-key map (kbd "C-x _") #'balance-windows)      ; underscore
    (define-key map (kbd "C-x -") #'fit-window-to-buffer) ; hyphen
    (define-key map (kbd "C-x +") #'balance-windows-area)
    (define-key map (kbd "C-x }") #'enlarge-window)
    (define-key map (kbd "C-x {") #'shrink-window)
    (define-key map (kbd "C-x >") #'enlarge-window-horizontally) ; override `scroll-right'
    (define-key map (kbd "C-x <") #'shrink-window-horizontally)) ; override `scroll-left'

 ;; (let ((map resize-window-repeat-map))
 ;;   (define-key map ">" #'enlarge-window-horizontally)
 ;;   (define-key map "<" #'shrink-window-horizontally))
)

 

#+end_src
#+begin_src emacs-lisp
  ;; (setup (:pkg ace-window)
  ;;   (setq aw-background t)
  ;;   (setq aw-scope 'frame)
  ;;   (ace-window-display-mode 1)
  ;;   (:hide-mode))

(setup (:pkg windmove)
    (setq windmove-create-window nil)     ; Emacs 27.1
  (let ((map global-map))
    ;; Those override some commands that are already available with
    ;; C-M-u, C-M-f, C-M-b.
    (define-key map (kbd "C-M-<up>") #'windmove-up)
    (define-key map (kbd "C-M-<right>") #'windmove-right)
    (define-key map (kbd "C-M-<down>") #'windmove-down)
    (define-key map (kbd "C-M-<left>") #'windmove-left)
    (define-key map (kbd "C-M-S-<up>") #'windmove-swap-states-up)
    (define-key map (kbd "C-M-S-<right>") #'windmove-swap-states-right) ; conflicts with `org-increase-number-at-point'
    (define-key map (kbd "C-M-S-<down>") #'windmove-swap-states-down)
    (define-key map (kbd "C-M-S-<left>") #'windmove-swap-states-left)))

(setup (:pkg winner)
  (winner-mode 1))
  (setq-default window-divider-default-places 'right-only ; only right
                window-divider-default-bottom-width 2
                window-divider-default-right-width 2)
#+end_src

#+begin_src emacs-lisp :noweb-ref pkg-uis
 ;; (window-divider-mode +1)
#+end_src

*** Splitting windows sensibly
:PROPERTIES:
:ID:                     43136dd2-3231-485b-89d9-88c8fe9fd6aa
:END:

This is extremely fiddly and I'd love another option.
- [[https://www.emacswiki.org/emacs/ToggleWindowSplit][ToggleWindowSplit, EmacsWiki]]

#+begin_src emacs-lisp :noweb-ref pkg-window
  (defun window-split-vertically ()
      "Split window vertically."
      (interactive)
      (split-window-right))

    (defun window-split-vertically-and-focus ()
      "Split window vertically and focus it."
      (interactive)
      (split-window-right)
      (windmove-right))

    (defun window-split-horizontally ()
      "Split window horizontally."
      (interactive)
      (split-window-below))

    (defun window-split-horizontally-and-focus ()
      "Split window horizontally and focus it."
      (interactive)
      (split-window-below)
      (windmove-down))

    (defun window-zoom ()
      "Close other windows to focus on this one.
    Activate again to undo this. If the window changes before then,
    the undo expires."
      (interactive)
      (if (and (one-window-p)
               (assq ?_ register-alist))
          (jump-to-register ?_)
        (window-configuration-to-register ?_)
        (delete-other-windows)))

  ;;(setq-default split-width-threshold 100
  ;;                  split-height-threshold 50)
#+end_src
*** Fringes
:PROPERTIES:
:ID:                     2d868201-f74e-4308-9326-55ffecb072a3
:END:

I have grown to love Emacs's little fringes on the side of the
windows.  In fact, I love them so much that I really went overboard
and have made a custom fringe bitmap.

**** Indicate empty lines after the end of the buffer
:PROPERTIES:
:ID:                     ed5dbc40-17dc-4dc1-afe9-438667404b90
:END:

#+begin_src emacs-lisp
  (setq-default indicate-empty-lines t)
#+end_src

**** Indicate the boundaries of the buffer
:PROPERTIES:
:ID:                     18a0a877-886e-4258-9cec-b4c7ade6acb8
:END:

#+begin_src emacs-lisp
  (setq-default indicate-buffer-boundaries 'right)
#+end_src

**** Indicate continuation lines, but only on the left fringe
:PROPERTIES:
:ID:                     a9d9c920-70a0-44f8-9a35-e8dbab82ee02
:END:

#+begin_src emacs-lisp
  (setq-default visual-line-fringe-indicators '(left-curly-arrow nil))
#+end_src

**** Customise fringe bitmaps
:PROPERTIES:
:ID:                     809ba958-cf27-4d36-91a1-cee523bb164c
:END:

***** Curly arrows (continuation lines)
:PROPERTIES:
:ID:                     a6b18024-eff2-4daa-bff3-37a9b190c6a8
:END:

#+begin_src emacs-lisp
  (define-fringe-bitmap 'left-curly-arrow
    [#b11000000
     #b01100000
     #b00110000
     #b00011000])

  (define-fringe-bitmap 'right-curly-arrow
    [#b00011000
     #b00110000
     #b01100000
     #b11000000])
#+end_src

***** Arrows (truncation lines)
:PROPERTIES:
:ID:                     34b749d5-dc05-4f04-ad4a-6477dd225bc6
:END:

#+begin_src emacs-lisp
  (define-fringe-bitmap 'left-arrow
    [#b00000000
     #b01010100
     #b01010100
     #b00000000])

  (define-fringe-bitmap 'right-arrow
    [#b00000000
     #b00101010
     #b00101010
     #b00000000])
#+end_src
* Project Setup
:PROPERTIES:
:header-args: :noweb-ref projet
:END:
Setup of emacs project
#+begin_src emacs-lisp
(setq project-list-file (expand-file-name "projects" *emacs-etc/*))

(defalias 'project-switch #'project-switch-project)

(defun project-p ()
  "Return non-nil when located in a project."
  (project-current))

;; Emacs 27
(unless (fboundp 'project-root)
  (cl-defmethod project-root ((project (head transient)))
    (cdr project)))

(defun project-shell-command ()
  "Invoke `shell-command' in the project's root."
  (interactive)
  (if-let* ((project (project-current))
            (root (project-root project)))
      (eval-with-default-dir root
        (call-interactively #'shell-command))
    (user-error "You are not in project")))

(defun project-magit ()
  "Start `magit-status' in the current project's root directory."
  (interactive)
  (magit-status-setup-buffer (project-root (project-current t))))

(setq project-switch-commands
      '((?f "Find file" project-find-file)
        (?g "Find regexp" project-find-regexp)
        (?d "Dired" project-dired)
        (?v "Magit" project-magit)
        (?e "Eshell" project-eshell)))

(use-package rg
  :defer t
  :commands (rg-project)
  :init
  (defalias 'project-find-regexp #'rg-project))

#+end_src
** VCS
:PROPERTIES:
:header-args: :noweb-ref vcs
:ID:                     6862765e-98fc-4855-b14b-1c9300cc9885
:END:
Setup of magit for cool git
#+begin_src emacs-lisp
(setq-default vc-follow-symlinks t)

;; (remove-hook 'find-file-hook #'vc-refresh-state)
;; (hook-with-delay 'find-file-hook 1 #'vc-refresh-state)

(use-package magit
      :defer t
      :defines (magit-status-mode-map
                magit-revision-show-gravatars
                magit-display-buffer-function
                magit-diff-refine-hunk)
      :commands (magit-display-buffer-same-window-except-diff-v1
                 magit-stage-file
                 magit-unstage-file)
      :init
      (setq-default magit-git-executable (executable-find "git"))
      :config
      ;; properly kill leftover magit buffers on quit
      (define-key magit-status-mode-map
        [remap magit-mode-bury-buffer]
        #'vcs-quit)

      (setq magit-revision-show-gravatars
            '("^Author:     " . "^Commit:     ")
            magit-display-buffer-function
            #'magit-display-buffer-same-window-except-diff-v1
            ;; show word-granularity on selected hunk
            magit-diff-refine-hunk t))

;;(use-package forge
;;      :commands forge-create-pullreq forge-create-issue
;;      :init
;;      (setq-default forge-database-file
;;                    (expand-file-name "forge/forge-database.sqlite"
;;                                      *emacs-etc/*)))

;;(setup (:pkg git-timemachine)
;;          (:bind
;;           "[" git-timemachine-show-previous-revision
;;           "]" git-timemachine-show-next-revision
;;           "b" git-timemachine-blame))

(use-package ediff-wind
    :straight nil
    :defer t
    :init
    (setq ediff-window-setup-function 'ediff-setup-windows-plain
          ediff-split-window-function 'split-window-horizontally))

(use-package diff-hl
    :defer t
    :hook ((prog-mode . turn-on-diff-hl-mode)
           (text-mode . turn-on-diff-hl-mode)
           (vc-dir-mode . turn-on-diff-hl-mode)
           (dired-mode . diff-hl-dired-mode)))

(defun vcs-quit (&optional _kill-buffer)
  "Clean up magit buffers after quitting `magit-status'.
  And don't forget to refresh version control in all buffers of
  current workspace."
    (interactive)
    (quit-window)
    (unless (cdr
             (delq nil
                   (mapcar (lambda (win)
                             (with-selected-window win
                               (eq major-mode 'magit-status-mode)))
                           (window-list))))
      (when (fboundp 'magit-mode-get-buffers)
        (mapc #'vcs--kill-buffer (magit-mode-get-buffers)))))

(defun vcs--kill-buffer (buffer)
  "Gracefully kill `magit' BUFFER.
  If any alive process is related to this BUFFER, wait for 5
  seconds before nuking BUFFER and the process. If it's dead -
  don't wait at all."
    (when (and (bufferp buffer) (buffer-live-p buffer))
      (let ((process (get-buffer-process buffer)))
        (if (not (processp process))
            (kill-buffer buffer)
          (with-current-buffer buffer
            (if (process-live-p process)
                (run-with-timer 5 nil #'vcs--kill-buffer buffer)
              (kill-process process)
              (kill-buffer buffer)))))))

;; (setup (:pkg magit)
      ;;   (setq git-commit-summary-max-length 120)
      ;;   (setq magit-commit-show-diff nil)
      ;;   (setq magit-delete-by-moving-to-trash nil)
      ;;   (setq magit-display-buffer-function
      ;;         #'magit-display-buffer-same-window-except-diff-v1)
      ;;   (setq magit-log-auto-more t)
      ;;   (setq magit-log-margin-show-committer-date t)
      ;;   (setq magit-revert-buffers 'silent)
      ;;   (setq magit-save-repository-buffers 'dontask)
      ;;   (setq magit-wip-after-apply-mode t)
      ;;   (setq magit-wip-after-save-mode t)
      ;;   (setq magit-wip-before-change-mode t)
      ;;   (setq transient-values
      ;;         '((magit-log:magit-log-mode "--graph" "--color" "--decorate"))))

;;(setup magit-wip
;;        (:load-after magit
;;          (magit-wip-mode 1)
;;          (:hide-mode)))

;;(setup (:pkg magit-todos)
;;        (:load-after magit
;;          (magit-todos-mode 1)))
#+end_src
* Completion Framework & Extras
:PROPERTIES:
:header-args: :noweb-ref pkg-completion
:ID:                     73011391-29f2-4810-b02e-b4b9775c1554
:END:
Unlike the desktop metaphor, the optimal way to use Emacs is through searching and narrowing selection candidates. Spend less time worrying about where things are on the screen and more on how fast you can bring them into focus. This is, of course, a matter of realigning priorities, as we still wish to control every aspect of the interface, as we do elsewhere in this document.
** Orderless
The, dare I say, sublime “orderless” package is developed by Omar Antolín Camarena. It provides the orderless completion style for efficient, out-of-order grouped pattern matching. The components can be determined using several styles, such as regexp, flex, prefix, initialism (check its README because there are lots of variations). Delimiters are literal spaces by default, but can be configured to match other characters, with hyphens and slashes being likely choices. As such, Orderless can supersede—and for most part improve upon—many of the completion styles that come built into Emacs, adding to them the powerful out-of-order capability.

All we do here is set up Orderless. The orderless completion style is appended to the minibuffer’s customisation option for completion-styles. That is defined in Minibuffer configurations and extras.

My prot-orderless.el contains the few minor tweaks I introduce (full code further below). It defines three style dispatchers. Those are single characters that acquire a special meaning while at the end of a given input:

- With the equals sign appended to a sequence of characters, we call prot-orderless-literal-dispatcher which instructs orderless to match that sequence as a literal string.
- A comma at the end of a string of characters treats that group as an initialism, per prot-orderless-initialism-dispatcher.
- While a tilde (prot-orderless-flex-dispatcher) makes it a flex match.

#+begin_src emacs-lisp :noweb-ref orderless
;;; Orderless completion style (and prot-orderless.el)
(setup (:pkg orderless)
  (:require prot-orderless)
  (setq orderless-component-separator " +")
  ;; NOTE 2022-02-06: I made some major changes and this list may need
  ;; to be refined further.  Remember to check my `completion-styles'
  ;; and the `completion-category-overrides'.
  (setq orderless-matching-styles
        '( orderless-prefixes orderless-strict-leading-initialism
           orderless-flex orderless-regexp))
  (setq orderless-style-dispatchers
        '(prot-orderless-literal-dispatcher
          prot-orderless-initialism-dispatcher
          prot-orderless-flex-dispatcher))

  ;; SPC should never complete: use it for `orderless' groups.
  ;; The `?' is a regexp construct.
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "SPC") nil)
    (define-key map (kbd "?") nil)))

#+end_src
** Completion annotations
This is a utility jointly developed by Daniel Mendler and Omar Antolín Camarena that provides annotations to completion candidates. It is meant to be framework-agnostic
#+begin_src emacs-lisp :noweb-ref annotations
;;; Completion annotations (marginalia)
 (setup (:pkg marginalia)
    (:load-after vertico
      (setq marginalia-max-relative-age 0)  ; time is absolute here!
		 (marginalia-mode 1))
    (:with-map minibuffer-local-map
      (:bind "M-A" marginalia-cycle)))

#+end_src
** Selection
#+begin_src emacs-lisp :noweb-ref pkg-completion
 (setup selection
    (setq kill-do-not-save-duplicates t)
    (setq select-enable-clipboard t)
    (setq select-enable-primary t)
    (setq x-select-enable-clipboard-manager nil))

#+end_src
** Minibuffer Configurations
:PROPERTIES:
:ID:                     4cac10bb-2e1d-4ca3-8a9b-11ef8ca3611f
:END:
The minibuffer is the epicentre of extended interactivity with all sorts of Emacs workflows: to select a buffer, open a file, provide an answer to some prompt, such as a number, regular expression, password, and so on.

Emacs has built-in capabilities to perform two distinct tasks related to such interactions:

*** Narrowing
    Use pattern matching algorithms to limit the list of choices (known as “candidates” or “completion candidates”) to those matching the given input. There are several pattern matching styles already built-in, while we can opt to extend them further.
*** Selecting
    Visualise the list of completion candidates and pick an item out of it using regular motions or concomitant extras. By default, Emacs visualises results in a special *Completions* buffer, which does not have lots of features and is not particularly pleasing to use.
*** Completion styles
    I rely on a mixture of built-in styles as well as the external orderless package by Omar Antolín Camarena. Orderless is placed last on some lists because simpler searches work fine with the other styles. My ordering goes from least to most powerful. Orderless is better suited for complex pattern matching. The way completion styles work, when one style cannot match anything, Emacs tries the next one on the list, until one of them yields results. As such, it is easy to activate Orderless on demand, either by separating input groups with spaces or passing one of the style dispatchers that are acceptable (read the Orderless completion style).

    For file queries in particular, there exists a niche functionality in the built-in initials and partial-completion styles to navigate abbreviated paths. Here is an example with the latter: you can type ~/.l/s/fo which will match ~/.local/share/fonts. The variable completion-category-overrides can control the standard option of completion-styles on a per-category basis.
*** Recursive minibuffers
    I enable recursive minibuffers. This practically means that you can start something in the minibuffer, switch to another window, call the minibuffer again, run some commands, and then move back to what you initiated in the original minibuffer. Or simply call an M-x command while in the midst of a minibuffer session. To exit, hit C-] (abort-recursive-edit), though the regular C-g should also do the trick.

    The minibuffer-depth-indicate-mode will show a recursion indicator, represented as a number, next to the minibuffer prompt, if a recursive edit is in progress (also check Mode line recursion indicators).

#+begin_src emacs-lisp :noweb-ref pkg-completion
  (use-package vertico
  :bind ( :map vertico-map
          ("M-RET" . vertico-exit-input))
  :init
  (vertico-mode))

(use-package vertico-directory
  :after vertico
  :straight nil
  :load-path "straight/repos/vertico/extensions/"
  :bind ( :map vertico-map
          ("RET" . vertico-directory-enter)
          ("DEL" . vertico-directory-delete-char)
          ("M-DEL" . vertico-directory-delete-word))
  ;; Tidy shadowed file names
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

  ;;; Minibuffer configurations and my extras (mct.el)
(setup  minibuffer
  (setq completion-styles '(basic orderless)) ; also see `completion-category-overrides'
  (setq completion-category-defaults nil)
  ;; For a list of known completion categories, check the MCT manual's
  ;; section on the matter:
  ;; <https://protesilaos.com/emacs/mct#h:1f42c4e6-53c1-4e8a-81ef-deab70822fa4>
  (setq completion-category-overrides
        ;; NOTE 2021-10-25: I am adding `basic' because it works better as a
        ;; default for some contexts.  Read:
        ;; <https://debbugs.gnu.org/cgi/bugreport.cgi?bug=50387>.
        ;;
        ;; `partial-completion' is a killer app for files, because it
        ;; can expand ~/.l/s/fo to ~/.local/share/fonts.
        '((file (styles . (basic partial-completion orderless)))
          (project-file (styles . (basic substring partial-completion orderless)))
          (imenu (styles . (basic substring orderless)))
          (kill-ring (styles . (basic substring orderless)))
          (consult-location (styles . (basic substring orderless)))))

  (setq completion-cycle-threshold 2)
  (setq completion-flex-nospace nil) ; though I don't use the built-in `flex' style...
  (setq completion-pcm-complete-word-inserts-delimiters nil)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-ignore-case t)
  (setq completions-detailed t)
  (setq-default case-fold-search t)   ; For general regexp

  ;; Grouping of completions for Emacs 28
  (setq completions-group t)
  (setq completions-group-sort nil)
  (setq completions-group-format
        (concat
         (propertize "    " 'face 'completions-group-separator)
         (propertize " %s " 'face 'completions-group-title)
         (propertize " " 'face 'completions-group-separator
                     'display '(space :align-to right))))

  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)

  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t) ; also check `use-short-answers' for Emacs28
  (setq resize-mini-windows t)
  (setq minibuffer-eldef-shorten-default t)

  (setq echo-keystrokes 0.25)           ; from the C source code
  (setq kill-ring-max 60)               ; Keep it small

  ;; Do not allow the cursor to move inside the minibuffer prompt.  I
  ;; got this from the documentation of Daniel Mendler's Vertico
  ;; package: <https://github.com/minad/vertico>.
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))

  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Adapted from Vertico.
  (defun crm-indicator (args)
    "Add prompt indicator to `completing-read-multiple' filter ARGS."
    ;; The `error' face just makes the text red.
    (cons (concat (propertize "[CRM] " 'face 'error) (car args)) (cdr args)))

  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)

  ;; I use this prefix for other searches
  (define-key minibuffer-local-must-match-map (kbd "M-s") nil))

   ;; (setup minibuffer
   ;;   (file-name-shadow-mode 1)
   ;;   (minibuffer-depth-indicate-mode 1)
   ;;  (minibuffer-electric-default-mode 1)
   ;;  (fset #'yes-or-no-p #'y-or-n-p)
   ;;  (setq enable-recursive-minibuffers t)
   ;;  (setq file-name-shadow-properties '(invisible t intangible t))
   ;;  (setq minibuffer-eldef-shorten-default t)
   ;;  (setq minibuffer-prompt-properties
   ;;        '(read-only t cursor-intangible t face minibuffer-prompt))
   ;;  (setq read-answer-short t)
   ;;  (setq read-extended-command-predicate #'command-completion-default-include-p)
   ;;  (setq use-short-answers t)
   ;;  ;; https://www.manueluberti.eu//emacs/2021/12/10/shell-command/
   ;;  (defun +minibuffer-complete-history ()
   ;;    "Complete minibuffer history."
   ;;    (interactive)
   ;;    (completion-in-region (minibuffer--completion-prompt-end) (point-max)
   ;;                          (symbol-value minibuffer-history-variable)
   ;;                          nil))
   ;;  (:with-hook minibuffer-setup-hook
   ;;    (:hook cursor-intangible-mode))
   ;;  (:with-map minibuffer-local-map
   ;;    (:bind "M-/" #'+minibuffer-complete-history))
   ;;  (:with-map minibuffer-inactive-mode-map
   ;;    (:bind "<mouse-1>" ignore)))
#+end_src

*** Enhanced minibuffer commands
Daniel Mendler’s Consult is a welcome addition to the ecosystem of modular, extensible tools that work with the standard minibuffer completion mechanisms and, by extension, with every user interface that largely conforms with them (Icomplete, Selectrum) or fully respects them (Embark and Daniel’s own Vertico). For my case, this means that it works with everything included in Completion framework and extras.

Consult’s value proposition is two-fold: (1) remain aligned with the Emacs completion paradigm, and (2) offer minibuffer-centric commands that either enhance aspects of interactivity and functionality found in existing commands or outright provide them from scratch.

Some Consult commands are drop-in replacements for built-in options. For example consult-complex-command offers an improved interactive experience over the default repeat-complex-command. Same principle for consult-goto-line which displays the line numbers and offers a live preview of where you are about to land.

Other commands enhance the defaults with a filtering mechanism that targets candidates by their type. A case in point is consult-imenu which recognises syntactic constructs that are variables, functions, macros (configurable via consult-imenu-narrow, consult-imenu-toplevel).

This “filtering” mechanism, which is internally known as “narrowing”, can be accessed via a key binding for all commands that support it. In my case, that key is the right angled bracket, or greater than sign (>) from inside the minibuffer (configure consult-narrow-key). So you type the narrow key and follow it up with another key that matches the relevant targets. Hit backspace to remove the narrowing. As for the available keys, type ? which calls consult-narrow-help.

This narrowing-by-type mechanism can also be used without inputting the consult-narrow-key, just by typing in the appropriate character and inserting a space. For instance, to search only for functions in consult-imenu, you type f and then a space. Consult will add an indicator to the minibuffer prompt describing the active filter.

In general, commands that involve multiple groups can benefit from this type of narrowing. The prime example is consult-buffer which combines sources of recently visited files, bookmarks, and buffers (those are configurable via the variable consult-buffer-sources). Though others follow the same principle, such as the aforementioned consult-imenu and consult-bookmark.

Another intriguing facility of Consult is its asynchronous call to external processes, such as grep and find. Those calls can be configured to return some output based on a minimum number of characters, while they also allow for tweaks to their update delays. Interactivity is already a given, meaning that you can continue typing and see the results pop up. Furthermore, they implement a two-stage input scheme, separated by a configurable delimiter (# by default and controlled with consult-async-default-split):

    First you type in the pattern that should be sent to the external program. This is what triggers the asynchronous call. So your input looks like this: #PATTERN. The pattern will typically consist of some text or a regular expression, but can also include command line flags for the underlying CLI program (check Consult’s documentation for the technicalities).
    Then you can add another field delimiter to instruct Consult to (i) keep the results that #PATTERN gave you and (ii) leverage Emacs’ own mechanisms to further narrow the list. Now your input looks like this: #PATTERN#MORE-PATTERNS. The #MORE-PATTERNS will use whatever completion styles you have configured (check my completion-styles).

As already suggested, Consult provides previews for its commands. This feature should work without any further intervention.

Consult can shine when used in tandem with Embark to produce buffers that hold all the candidates of any given minibuffer completion command (Extended minibuffer actions and more (embark.el and prot-embark.el)). For example, embark-export can be called from inside consult-grep (and variants) to deliver a dedicated grep-mode buffer, which can then be edited with the help of the wgrep package (check wgrep (writable grep)). Use that to quickly refactor some pattern across your files.

Other nice extensions of Consult are (i) its ability to work as a generic front-end for completion, and (ii) its preview facility for registers. The former is done by consult-completion-in-region which provides completion for commands such as dabbrev-completion or the TAB key in programming buffers (see Tabs, indentation, and the TAB key). While the latter is an overall prettier presentation for the familiar register preview window
#+begin_src emacs-lisp
  (use-package consult
    :preface
    (defvar consult-prefix-map (make-sparse-keymap))
    (fset 'consult-prefix-map consult-prefix-map)
    :bind ( :map ctl-x-map
            ("c" . consult-prefix-map)
            :map consult-prefix-map
            ("r" . consult-recent-file)
            ("o" . consult-outline)
            ("i" . consult-imenu)
            ("g" . consult-grep)
            ("f" . jnf/consult-ripgrep))
    :custom
    (consult-preview-key any)
    :init
    (setq completion-in-region-function #'consult-completion-in-region)
    :config
     (setq consult-line-numbers-widen t)
    ;; (setq completion-in-region-function #'consult-completion-in-region)
    (setq consult-async-min-input 3)
    (setq consult-async-input-debounce 0.5)
    (setq consult-async-input-throttle 0.8)
    (setq consult-narrow-key ">")
    (setq consult-imenu-config
          '((emacs-lisp-mode :toplevel "Functions"
                             :types ((?f "Functions" font-lock-function-name-face)
                                     (?m "Macros"    font-lock-keyword-face)
                                     (?p "Packages"  font-lock-constant-face)
                                     (?t "Types"     font-lock-type-face)
                                     (?v "Variables" font-lock-variable-name-face)))))
     ;; Updating the default to include "--ignore-case"
       (setq consult-ripgrep-command "rg --null --line-buffered --color=ansi --max-columns=1000 --ignore-case --no-heading --line-number . -e ARG OPTS")

       ;; From https://github.com/minad/consult/wiki#find-files-using-fd
       ;; Note: this requires lexical binding
       (defun jnf/consult-find-using-fd (&optional dir initial)
         "Find project files.
    A replacement for `projectile-find-file'."
         (interactive "P")
         (let ((consult-find-command "fd --color=never --hidden --exclude .git/ --full-path ARG OPTS"))
           (consult-find dir initial)))

       (defun jnf/consult-line (consult-line-function &rest rest)
         "Advising function around `CONSULT-LINE-FUNCTION'.
    When there's an active region, use that as the first parameter
    for `CONSULT-LINE-FUNCTION'.  Otherwise, use the current word as
    the first parameter.  This function handles the `REST' of the
    parameters."
         (interactive)
         (apply consult-line-function
                (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
                rest))

       (defun jnf/consult-ripgrep (consult-ripgrep-function &optional dir &rest rest)
         "Use region or thing at point to populate initial parameter for `CONSULT-RIPGREP-FUNCTION'.
    When there's an active region, use that as the initial parameter
    for the `CONSULT-RIPGREP-FUNCTION'.  Otherwise, use the thing at
    point.
    `DIR' use the universal argument (e.g. C-u prefix) to first set
    the directory.  `REST' is passed to the `CONSULT-RIPGREP-FUNCTION'."
         (interactive "P")
         (apply consult-ripgrep-function
                dir
                (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
                rest))

       ;; Optionally tweak the register preview window.
       ;; This adds thin lines, sorting and hides the mode line of the window.
       (advice-add #'register-preview :override #'consult-register-window)
       (advice-add #'consult-line :around #'jnf/consult-line '((name . "wrapper")))
       (advice-add #'consult-ripgrep :around #'jnf/consult-ripgrep '((name . "wrapper")))
       (setq consult-after-jump-hook nil) ; reset it to avoid conflicts with my function
    (add-hook 'consult-after-jump-hook #'prot-pulse-recentre-top) ; see `prot-pulse.el'

    (add-hook 'completion-list-mode-hook #'consult-preview-at-point-mode)

    (require 'consult-imenu) ; the `imenu' extension is in its own file

    (let ((map global-map))
      (define-key map (kbd "C-x r b") #'consult-bookmark) ; override `bookmark-jump'
      (define-key map (kbd "C-x M-:") #'consult-complex-command)
      (define-key map (kbd "C-x M-m") #'consult-minor-mode-menu)
      (define-key map (kbd "C-x M-k") #'consult-kmacro)
      (define-key map [remap goto-line] #'consult-goto-line)
      (define-key map (kbd "M-K") #'consult-keep-lines) ; M-S-k is similar to M-S-5 (M-%)
      (define-key map (kbd "M-F") #'consult-focus-lines) ; same principle
      (define-key map (kbd "M-s M-b") #'consult-buffer)
      (define-key map (kbd "M-s M-f") #'consult-find)
      (define-key map (kbd "M-s M-g") #'consult-grep)
      (define-key map (kbd "M-s M-h") #'consult-history)
      (define-key map (kbd "M-s M-i") #'consult-imenu)
      (define-key map (kbd "M-s M-l") #'consult-line)
      (define-key map (kbd "M-s M-m") #'consult-mark)
      (define-key map (kbd "M-s M-s") #'consult-outline)
      (define-key map (kbd "M-s M-y") #'consult-yank-pop)
      (define-key map (kbd "C-x r r") #'consult-register)) ; Use the register's prefix
    (define-key consult-narrow-map (kbd "?") #'consult-narrow-help))

 
  (use-package corfu
    :straight ( :host github
                :repo "minad/corfu"
                :branch "main")
    :bind ( :map corfu-map
            ("TAB" . corfu-next)
            ([tab] . corfu-next)
            ("S-TAB" . corfu-previous)
            ([backtab] . corfu-previous)
            ([remap completion-at-point] . corfu-complete)
            ("RET" . corfu-complete-and-quit)
            ("<return>" . corfu-complete-and-quit))
    :custom
    (corfu-cycle t)
    (corfu-preselect-first t)
    (corfu-scroll-margin 4)
    (corfu-quit-no-match t)
    (corfu-quit-at-boundary t)
    (corfu-max-width 100)
    (corfu-min-width 42)
    (corfu-count 9)
    ;; should be configured in the `indent' package, but `indent.el'
    ;; doesn't provide the `indent' feature.
    (tab-always-indent 'complete)
    :config
    (defun corfu-complete-and-quit ()
      (interactive)
      (corfu-complete)
      (corfu-quit))
    :init
    (corfu-global-mode))

  (use-package corfu-doc
    :straight ( :host github
                :repo "galeo/corfu-doc"
                :branch "main")
    :bind ( :map corfu-map
            ("M-p" . corfu-doc-scroll-down)
            ("M-n" . corfu-doc-scroll-up))
    :hook (corfu-mode . corfu-doc-mode)
    :custom
    (corfu-doc-delay 1.25)
    (corfu-doc-max-height 20)
    (corfu-doc-max-width 84))

  (use-package cape
    :config
    (setq completion-at-point-functions '(cape-file cape-dabbrev)))

  (setup (:pkg ripgrep)
      (:needs "rg")
      (setq ripgrep-arguments "--ignore-case"))

#+end_src

* Note Taking
In its purest form, Org is a markup language that is similar to Markdown: symbols are used to denote the meaning of a construct in its context, such as what may represent a headline element or a phrase that calls for emphasis.
What lends Org its super powers though is everything else built around it: a rich corpus of Elisp functions that automate, link, combine, enhance, structure, or otherwise enrich the process of using this rather straightforward system of plain text notation.
Couched in those terms, Org is at once a distribution of well integrated libraries and a vibrant ecosystem that keeps producing new ideas and workflows on how to organise one’s life with plain text.c

** Org mode Use-package Defaults
Org mode defaults for consistency
#+begin_src emacs-lisp :noweb-ref org-defaults
(use-package org
  :straight (:type built-in)
  :preface
  ;; Set my default org-export backends. This variable needs to be set before
  ;; org.el is loaded.
  (setq org-export-backends '(ascii html latex md))
  ;; Do not open links of mouse left clicks.
  ;; Default behavior caused inline images in Org buffers to pop up in their
  ;; own buffers when left clicked on by mistake. I can still intentionally
  ;; open links and such images in new buffers by doing C-c C-o.
  (setq org-mouse-1-follows-link nil)
  :mode ("\\.org\\'" . org-mode)
  :hook ((org-mode . visual-line-mode)
         (org-mode . adaptive-wrap-prefix-mode)
         ;; oh, how much I hate it in Org mode buffers
         (org-mode . editor-disable-electric-indent))
  :hook  ((org-capture-mode org-src-mode) . discard-history)
  :commands (org-check-agenda-file
             org-link-set-parameters)
  :custom-face
  (org-block ((t (:extend t))))
  (org-block-begin-line ((t ( :slant unspecified
                              :weight normal
                              :background unspecified
                              :inherit org-block
                              :extend t))))
  (org-block-end-line ((t ( :slant unspecified
                            :weight normal
                            :background unspecified
                            :inherit org-block-begin-line
                            :extend t))))
  (org-drawer ((t (:foreground nil :inherit shadow))))
  :custom
  (org-ellipsis "…")
  :init
  ;; This is where my ~heart~ org files are.
  (setq org-directory
        (if *is-termux?*
            "~/storage/shared/org"
          "~/org"))

  (defun add-path-to-org/ (path)
    (expand-file-name path org-directory))

  :config
  ;;;; general settings
  (setq org-adapt-indentation nil)      ; No, non, nein, όχι!
  ;; Prevent auto insertion of blank lines before headings and list items
  (setq org-blank-before-new-entry '((heading)
				     (plain-list-item)))
  ;; http://emacs.stackexchange.com/a/17513/115, values: nil, t, 'reverse
  (setq org-special-ctrl-a/e nil)
  (setq org-special-ctrl-k nil)
  (setq org-M-RET-may-split-line '((default . nil)))
  ;; Single key command execution when at beginning of a headline
  (setq org-use-speed-commands t)     ;? speed-key opens Speed Keys help
  (setq org-speed-commands-user '(("m" . org-mark-subtree)))
  (setq org-hide-emphasis-markers nil)  ;; so dont see text markers aka bold italic
  (setq org-hide-macro-markers nil)
  (setq org-hide-leading-stars nil)
  (setq org-cycle-separator-lines 0)
  (setq org-structure-template-alist    ; CHANGED in Org 9.3, Emacs 27.1
	'(("s" . "src")
	  ("E" . "src emacs-lisp")
	  ("e" . "example")
	  ("q" . "quote")
	  ("v" . "verse")
	  ("V" . "verbatim")
	  ("c" . "center")
	  ("C" . "comment")))
  (setq org-catch-invisible-edits 'smart) ;; try not to accidently do wierd stuff in invisible regions : show smart, error
  (setq org-return-follows-link t)
  (setq org-loop-over-headlines-in-active-region 'start-level)
  ;; Setup list of Org modules that should always be loaded together
  ;; with Org.
  (setq org-modules '(org-id org-attach ol-info))
  ;; Allow _ and ^ characters to sub/super-script strings but only when
  ;; string is wrapped in braces
  (setq org-use-sub-superscripts '{}) ; In-buffer rendering
  (setq org-pretty-entities t)        ; special symbols, latex
  ;; Render subscripts and superscripts in Org buffers
  (setq org-pretty-entities-include-sub-superscripts t)
  (setq org-insert-heading-respect-content t)

  ;;;; code blocks
  (setq org-hide-block-startup nil)
  (setq org-fontify-quote-and-verse-blocks t
	org-fontify-whole-heading-line t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t) ;; Display entities like \tilde, \alpha, etc in UTF-8 characters
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t) ;; TAB as if code tab settings
  (setq org-edit-src-content-indentation 0) ;; remove 2 space indent in src code blocks
  (setq org-use-property-inheritance t) ;; for tangling

  ;;;; images
  (setq org-startup-with-inline-images t)
  (setq org-image-actual-width '(300))

  ;;;; export
  (setq org-export-with-toc t)
  (setq org-export-headline-levels 8)
  (setq org-export-in-background t)     ; run export processes in external emacs process
  (setq org-export-with-section-numbers nil)
  (setq org-export-with-smart-quotes t)
  (setq org-export-with-sub-superscripts '{}) ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
  (setq org-export-dispatch-use-expert-ui nil)
  (setq org-html-coding-system 'utf-8-unix)
  (setq org-html-todo-kwd-class-prefix "keyword ")
  (setq org-html-htmlize-output-type nil)
  (setq org-html-head-include-default-style nil)
  (setq org-html-head-include-scripts nil)
  (require 'ox-texinfo)
  (require 'ox-md)

  ;; fold / overview  - collapse everything, show only level 1 headlines
  ;; content          - show only headlines
  ;; nofold / showall - expand all headlines except the ones with :archive:
  ;;                    tag and property drawers
  ;; showeverything   - same as above but without exceptions
  (setq org-startup-folded 'content)

  ;; https://orgmode.org/manual/Clean-view.html
  (setq org-startup-indented t)       ;;; removed leading * for nicer view
  (with-eval-after-load 'org-indent
    (setq org-indent-indentation-per-level 1)) ;Default = 2

  (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (clojure . t)
       (shell . t)
       (python . t)
       (latex . t)
       ))
  ;; change CAPITAL Keywords to lowercase
  (defun org-syntax-convert-keyword-case-to-lower ()
    "Convert all #+KEYWORDS to #+keywords."
    (interactive)
    (save-excursiont
      (goto-char (point-min))
      (let ((count 0)
	    (case-fold-search nil))
	(while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
	(unless (s-matches-p "RESULTS" (match-string 0))
	  (replace-match (downcase (match-string 0)) t)
	  (setq count (1+ count))))
	(message "Remplacement de %d occurrences" count))))
  (defun discard-history ()
    "Discard undo history of org src and capture blocks."
    (setq buffer-undo-list nil)
    (set-buffer-modified-p nil))
  (define-advice org-return (:around (f &rest args))
    (let ((org-src-preserve-indentation t))
      (apply f args)))
  (define-advice org-cycle (:around (f &rest args))
    (let ((org-src-preserve-indentation t))
      (apply f args)))
  (defun org-babel-edit-prep:emacs-lisp (_)
    "Setup Emacs Lisp buffer for Org Babel."
    (setq lexical-binding t)
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
  ;; open directory links in `dired'
  (add-to-list 'org-file-apps '(directory . emacs))

  ;; open files in the same window
  (add-to-list 'org-link-frame-setup '(file . find-file))
  (setq org-indirect-buffer-display 'current-window)

  (defun gas/org-mode-setup ()
    (org-indent-mode)       ;; turn on org indent
    (variable-pitch-mode 1) ;; turn on variable-pitch
    (auto-fill-mode 0)      ;; turn off auto-fill
    (visual-line-mode 1)    ;; turn on visual-line-mode
    (show-paren-mode 1)     ;; show parentheses
    )
 )
#+end_src

** Org agenda
#+begin_src elisp :noweb-ref org-agenda
(use-package org-agenda
  :straight nil
  :defer t
  :config      ;; formatting for properties
  (setq org-property-format "%-24s %s")
  ;; setup todo keywords
  (setq
   org-todo-keywords
   '((sequence "TODO(t)" "EN_COURS(n)" "|" "FINI(d!)")
     (sequence "ATTENDRE(w@/!)"
	       "ENATTENTE(h@/!)"
	       "|"
	       "ANNULÉ(c@/!)"
	       "RÉUNION(m)")))
  (setq org-todo-keyword-faces
	'(("TODO"     . org-todo)
	  ("ENATTENTE"  . (:foreground "black" :background "#FFEF9F"))
	  ("ANNULÉ" . (:foreground "#94BFF3" :weight bold :strike-through t))
	  ("FINI"     . (:foreground "black" :background "#91ba31"))
	  ("RÉUNION" . '(bold org-todo))
	  ("ATTENDRE" . '(bold shadow))))
  (setq org-use-fast-todo-selection 'expert)
  (setq org-priority-faces
	'((?A . '(bold org-priority))
	  (?B . org-priority)
	  (?C . '(shadow org-priority))))
  (setq org-fontify-done-headline nil)
  (setq org-fontify-todo-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-heading-line nil)
  (setq org-fontify-whole-block-delimiter-line nil)
  (setq org-highlight-latex-and-related nil) ; other options affect elisp regexp in src blocks
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-track-ordered-property-with-tag t)
  (setq org-highest-priority ?A)
  (setq org-lowest-priority ?C)
  (setq org-default-priority ?A)

  (setq org-todo-keywords
	'((sequence
	   "TODO(t)"  ; A task that needs doing & is ready to do
	   ;;  "PROJ(p)"  ; A project, which usually contains other tasks
	   "EN_COURS(s)"  ; A task that is in progress
	   "ATTE(w)"  ; Something external is holding up this task
	   "SUSP(h)"  ; This task is paused/on hold because of me
	   "|"
	   "FINI(d)"  ; Task successfully completed
	   "KILL(k)") ; Task was cancelled, aborted or is no longer applicable
	  (sequence
	   "[ ](T)"   ; A task that needs doing
	   "[-](S)"   ; Task is in progress
	   "[?](W)"   ; Task is being held up or paused
	   "|"
	   "[X](D)")  ; Task was completed
	  (sequence
	   "|"
	   "OKAY(o)"
	   "YES(y)"
	   "NO(n)"))
	org-todo-keyword-faces
	'(("[ ]"   . org-todo-keyword-todo)
	  ("SUIV" .  org-todo-keyword-next)
	  ("[-]"  .  org-todo-keyword-next)
	  ("[?]"  .  org-todo-keyword-wait)
	  ("ATTE" .  org-todo-keyword-wait)
	  ("SUSP" .  org-todo-keyword-wait)
	  ("PROJ" .  org-todo-keyword-proj)
	  ("KILL" .  org-todo-keyword-kill)
	  ("FINI" .  org-todo-keyword-done)
	  ("[X]"  .  org-todo-keyword-done)
	  ))

  (setq org-agenda-custom-commands
	(quote
	 (("n" "Prochaines Tâches"
	   ((agenda "" ((org-deadline-warning-days 7)))
	    (todo "SUIV"
		  ((org-agenda-overriding-header "Prochaines Tâches")))))

	  ;; Low-effort next actions
	  ("l" tags-todo "+TODO=\"EN_COURS\"+Effort<15&+Effort>0"
	   ((org-agenda-overriding-header "Tâches à faible Effort")
	    (org-agenda-max-todos 20)
	    (org-agenda-files org-agenda-files)))
	  ("h" "Habitudes" tags-todo "STYLE=\"habit\""
	   ((org-agenda-overriding-header "Habitudes")
	    (org-agenda-sorting-strategy
	     '(todo-state-down priority-down category-keep))))
	  ("e" "Eisenhower Matrix"
	   ((agenda
	     ""
	     ((org-agenda-overriding-header "Calendrier Eisenhower:")
	      (org-agenda-show-log t)
	      (org-agenda-log-mode-items '(clock state))
	      (org-agenda-category-filter-preset '("-Habitudes"))
	      (org-agenda-span 5)
	      (org-agenda-start-on-weekday t)
	      ;;            (org-agenda-ndays 5)
	      ;;            (org-agenda-start-day "-2d")
	      (org-deadline-warning-days 30)))
	    (tags-todo
	     "+important+urgent/!FINI"
	     ((org-agenda-overriding-header "Tâches importantes et urgentes")
	      (org-tags-match-list-sublevels nil)))
	    (tags-todo  "+important-urgent"
			((org-agenda-overriding-header "Tâches importantes mais non urgentes")
			 (org-tags-match-list-sublevels nil)))
	    (tags-todo "-important+urgent"
		       ((org-agenda-overriding-header "Tâches urgentes mais sans importance")
			(org-tags-match-list-sublevels nil)))
	    (tags-todo "-important-urgent/!TODO"
		       ((org-agenda-overriding-header "Tâches non importantes ni urgentes")
			(org-agenda-category-filter-preset '("-Habitudes"))
			(org-tags-match-list-sublevels nil)))
	    (tags-todo "values"
		       ((org-agenda-overriding-header "Valeurs")
			(org-tags-match-list-sublevels nil)))
	    ))
	  (" " "Agenda"
	   ((agenda ""
		    ((org-agenda-overriding-header "Calendrier d'aujourd'hui:")
		     (org-agenda-show-log t)
		     (org-agenda-log-mode-items '(clock state))
		     ;; (org-agenda-files '(,(add-path-to-org/ "inbox.org")))
		     (org-agenda-text-search-extra-files nil)
		     ;;   (org-agenda-span 'day)
		     ;;   (org-agenda-ndays 3)
		     (org-agenda-start-on-weekday nil)
		     (org-agenda-start-day "-d")
		     (org-agenda-todo-ignore-deadlines nil)))
	    (tags-todo "+important"
		       ((org-agenda-overriding-header "Tâches Importantes à Venir")
			(org-tags-match-list-sublevels nil)))
	    (tags-todo "-important/TODO"
		       ((org-agenda-overriding-header "Tâches de Travail")
			(org-agenda-category-filter-preset '("-Habitudes"))
			(org-agenda-sorting-strategy
			 '(todo-state-down priority-down))))
	    (tags-todo "-important-urgent/TODO"
		       ((org-agenda-overriding-header "Habitudes")
			(org-agenda-sorting-strategy
			 '(todo-state-down priority-down))))
	    (tags "FINI"
		  ((org-agenda-overriding-header "Tâches à la Représenter")
		   (org-tags-match-list-sublevels nil)))))
	  ))))

#+end_src
*** Org clock
#+begin_src emacs-lisp
(use-package org-clock
  :straight nil
  :defer t
  :commands (org-clock-save)
  :init
  (setq
   org-clock-persist-file (expand-file-name "org-clock-save.el" *emacs-etc/* )
   ;; remove clocked tasks with 0:00 duration
   org-clock-out-remove-zero-time-clocks t
   org-clock-persist 'history
   ;; Resume when clocking into task with open clock
   org-clock-in-resume t)
  :config
  (add-hook 'kill-emacs-hook #'org-clock-save))


#+end_src
*** Org refile
#+begin_src emacs-lisp
(use-package org-refile
  :straight nil
  :defer t
  :init
       ;;;; refile, todo
  (setq org-refile-targets
	'((org-agenda-files . (:maxlevel . 2))
	  (nil . (:maxlevel . 2))))
  (setq org-refile-use-outline-path t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache t)
  (setq org-reverse-note-order nil)
  (setq org-outline-path-complete-in-steps nil)
  ;;	(setq org-refile-target-verify-function #'vulpea-refile-verify-target)
  )


#+end_src
*** Org Archive
#+begin_src emacs-lisp
(use-package org-archive
  :straight nil
  :defer t
  :init
  (setq-default
   org-archive-location
   (concat org-directory ".archive/%s_archive" "::" "datetree/*")
   org-archive-save-context-info
   '(time file ltags itags todo category olpath)))


#+end_src
*** Org ID
#+begin_src emacs-lisp
(use-package org-id
  :straight nil
  :defer t
  :hook ( ;;(before-save . vulpea-id-auto-assign)
         (org-capture-prepare-finalize . org-id-get-create))
  :init
  (setq org-id-uuid-program
        "uuidgen | tr \"[:upper:]\" \"[:lower:]\"")
  :config
  ;;(org-link-set-parameters
  ;; "id" :activate-func #'vulpea-activate-link)
  (setq
   org-id-track-globally t
   org-id-extra-files
   (list (expand-file-name ".archive/archive" org-directory)
         (expand-file-name ".archive/archive.org" org-directory))
   org-id-link-to-org-use-id t
   org-id-locations-file (expand-file-name "org-id-locations" *xdg-cache/*)))


#+end_src
*** Org attach
#+begin_src emacs-lisp
(use-package org-attach
  :straight nil
  :defer t
  :config
  (setq-default
   org-attach-id-dir (expand-file-name ".data/" org-directory)
   org-attach-auto-tag nil
   org-attach-file-list-property nil
   org-attach-store-link-p 'attached))
#+end_src

** Org Roam /org-roam/
#+begin_src emacs-lisp :noweb-ref org-roam

(use-package org-roam
  :after org
  :commands (org-roam-db-autosync-enable
             org-roam-db-sync)
  :init
  (setq
   org-roam-v2-ack t
   org-roam-directory vulpea-directory
   org-roam-dailies-directory (expand-file-name
                               "journal/" org-roam-directory)
   org-roam-db-location (expand-file-name "org-roam.db" *xdg-cache/*)
   org-roam-completion-everywhere t)
  :config
  ;; For some reason org-roam is loaded on init and twice! Suspect it
  ;; is related to the fact that I am loading it from different
  ;; branch.
  ;;
  ;; So since I need a quick remedy, I noop `org-roam-db-sync' during
  ;; setup, because I sync data base time to time from terminal via
  ;; eru.
  (advice-add #'org-roam-db-sync :around #'fun-noop)
  (ignore-errors
    (org-roam-db-autosync-enable))
  (advice-remove #'org-roam-db-sync #'fun-noop))



;; (with-eval-after-load 'org

;;     ;; (add-to-list 'org-after-todo-state-change-hook
;;     ;;              (lambda ()
;;     ;;                (when (equal org-state "FINI")
;;     ;;                  (my/org-roam-copy-todo-to-today))))



;;     (defun dw/org-roam-goto-month ()
;;       (interactive)
;;       (org-roam-capture- :goto (when (org-roam-node-from-title-or-alias (format-time-string "%Y-%B")) '(4))
;;                          :node (org-roam-node-create)
;;                          :templates '(("m" "month" plain "\n* Objectifs\n\n%?* Résumé\n\n"
;;                                        :if-new (file+head "%<%Y-%B>.org"
;;                                                           "#+title: %<%Y-%B>\n#+filetags: projet\n")
;;                                        :unnarrowed t))))

;;     (defun dw/org-roam-goto-year ()
;;       (interactive)
;;       (org-roam-capture- :goto (when (org-roam-node-from-title-or-alias (format-time-string "%Y")) '(4))
;;                          :node (org-roam-node-create)
;;                          :templates '(("y" "year" plain "\n* Objectifs\n\n%?* Résumé\n\n"
;;                                        :if-new (file+head "%<%Y>.org"
;;                                                           "#+title: %<%Y>\n#+filetags:projet\n")
;;                                        :unnarrowed t))))

;;   (setup (:pkg org-roam)
;;     (setq org-roam-v2-ack t)
;;     (setq dw/daily-note-filename "%<%Y-%m-%d>.org"
;;           dw/daily-note-header "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")


;;     (:when-loaded
;;       (org-roam-db-autosync-mode)
;;       )

;;     (:option
;;      org-roam-directory "~/org/roam/"
;;      org-roam-dailies-directory "journal/"
;;      org-roam-completion-everywhere t
;;      org-roam-capture-templates
;;      '(("d" "default" plain "%?"
;;         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
;;                            "#+title: ${title}\n")
;;         :unnarrowed t))
;;      org-roam-dailies-capture-templates
;;      `(("d" "default" entry
;;         "* %?"
;;         :if-new (file+head ,dw/daily-note-filename
;;                            ,dw/daily-note-header))
;;        ("t" "tâche" entry
;;         "* TODO %?\n  %U\n  %a\n  %i"
;;         :if-new (file+head+olp ,dw/daily-note-filename
;;                                ,dw/daily-note-header
;;                                ("Tâches"))
;;         :empty-lines 1)
;;        ("l" "log entry" entry
;;         "* %<%I:%M %p> - %?"
;;         :if-new (file+head+olp ,dw/daily-note-filename
;;                                ,dw/daily-note-header
;;                                ("Log")))
;;        ("j" "journal" entry
;;         "* %<%I:%M %p> - Journal  :journal:\n\n%?\n\n"
;;         :if-new (file+head+olp ,dw/daily-note-filename
;;                                ,dw/daily-note-header
;;                                ("Log")))
;;        ("m" "meeting" entry
;;         "* %<%I:%M %p> - %^{Meeting Title}  :meetings:\n\n%?\n\n"
;;         :if-new (file+head+olp ,dw/daily-note-filename
;;                                ,dw/daily-note-header
;;                                ("Log")))))
;;    )


#+end_src
** Vulpea
Setup d12frosted's vulpea's helper for org-roam
#+begin_src emacs-lisp  :noweb-ref vulpea
(setup (:pkg org-cliplink))

(use-package vulpea
  :straight (vulpea
             :type git
             :host github
             :repo "d12frosted/vulpea")
  :defer t
  :general
  (leader-def
   "n" '(nil :which-key "vulpea...")
   "nd" '(nil :which-key "by date...")
   "ndd" '(vulpea-dailies-date :which-key "arbitrary date")
   "ndt" '(vulpea-dailies-today :which-key "today")
   "ndn" '(vulpea-dailies-next :which-key "next")
   "ndp" '(vulpea-dailies-prev :which-key "previous")
   "nf" '(vulpea-find :which-key "find")
   "nF" '(vulpea-find-backlink :which-key "find backlink")
   "ni" '(vulpea-insert :which-key "insert")
   "nt" '(vulpea-tags-add :which-key "tag")
   "nT" '(vulpea-tags-delete :which-key "untag")
   "na" '(vulpea-alias-add :which-key "alias")
   "nA" '(vulpea-alias-delete :which-key "unalias")
   "ol" '(litnotes :which-key "litnotes"))
  :hook ((before-save . vulpea-pre-save-hook)
         (org-roam-db-autosync-mode . vulpea-db-autosync-enable))
  :init
  (add-to-list 'window-buffer-change-functions
               #'vulpea-setup-buffer)
  (add-hook 'vulpea-insert-handle-functions
            #'vulpea-insert-handle)
  (setq-default
   vulpea-find-default-filter
   (lambda (note)
     (= (vulpea-note-level note) 0))
   vulpea-insert-default-filter
   (lambda (note)
     (= (vulpea-note-level note) 0))))



#+end_src
** Org Setup /org-setup/
use Setup to setup Org Mode

#+begin_src emacs-lisp :noweb-ref org-setup
;;; org-setup.el --- Orgmode Setup  -*- lexical-binding: t -*-
;; setup of org-mode keybindings
(setup (:pkg org)
  (:also-load org-tempo)
  (:hook gas/org-mode-setup)
  (:global "C-c a"  org-agenda
           "C-c c"  org-capture
           "C-c l"  org-store-link)
  (:bind   "C-'"  nil
           "C-,"  nil
           "<C-return>"    nil
           "<C-S-return>"  nil
           "C-M-S-<right>" nil
           "C-M-S-<left>"  nil
           "C-c S-l"       org-toggle-link-display
           "C-c C-S-l"     org-insert-last-stored-link)

  (push '("conf-unix" . conf-unix) org-src-lang-modes)
  (:load-after hl-fill-column
    (:hook gas/org-mode-setup)))

(setup (:require org-indent)
  (:load-after org
    (setq evil-auto-indent nil)
    (org-indent-mode 1)
    (:hide-mode)))

(setup (:pkg org-appear)
  (:load-after org
    (:option org-appear-autoemphasis t
             org-appear-autoentities t
             org-appear-autokeywords t
             org-appear-autolinks nil
             org-appear-autosubmarkers t
             org-appear-delay 0)
    (:hook-into org-mode)))

  (setup org-faces
    (:load-after org-indent
      (dolist (face-cons '((org-document-title . 1.75)
                           (org-level-1 . 1.5)
                           (org-level-2 . 1.25)
                           (org-level-3 . 1.12)
                           (org-level-4 . 1.05)
                           (org-level-5 . 1.0)
                           (org-level-6 . 1.0)
                           (org-level-7 . 1.0)
                           (org-level-8 . 1.0)))
        (cl-destructuring-bind (face . height) face-cons
          (set-face-attribute face
                              nil
                              :weight 'bold
                              :font "Iosevka Aile"
                              :height height))))

  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
  (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

  ;; Get rid of the background on column views
  (set-face-attribute 'org-column nil :background nil)
  (set-face-attribute 'org-column-title nil :background nil))

#+end_src

** Org Capture /vulp-capture/
#+begin_src emacs-lisp :noweb-ref vulp-capture
  (use-package org-capture
    :straight nil
    :defer t
    :general
    (leader-def
      "c" '(nil :which-key "capture...")
      "cX" '(org-capture :which-key "dispatch")
      "ca" '(vulpea-capture-article :which-key "article")
      "cj" '(vulpea-capture-journal :which-key "journal")
      "cl" '(org-store-link :which-key "link")
      "cm" '(vulpea-capture-meeting :which-key "meeting")
      "cx" '(vulpea-capture-task :which-key "task"))
    :init
    (setq-default org-capture-bookmark nil)
    :config
    (vulpea-capture-setup))

  

#+end_src
** Org Vulpea Agenda /agenda-vulpea/
org-capture provides a generic and extensible interface to capturing things into org-mode in
different formats
#+begin_src emacs-lisp :noweb-ref agenda-vulpea
(use-package org-agenda
  :straight nil
  :defer t
  :general
  (leader-def
    "oA" '(org-agenda :which-key "agenda dispatch")
    "oa" '(vulpea-agenda-main :which-key "agenda")
    "op" '(vulpea-agenda-person :which-key "person"))
  :config
  (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
  (setq org-log-done 'time) ;Insert only timestamp when closing an Org TODO item
  ;; (setq org-log-done 'note) ;Insert timestamp and note when closing an Org TODO item
  ;; https://orgmode.org/manual/Closing-items.html

  ;; use drawer for state changes
  (setq org-log-into-drawer t)

  ;; Block entries from changing state to DONE while they have children
  ;; that are not DONE - https://orgmode.org/manual/TODO-dependencies.html
  (setq org-enforce-todo-dependencies t)

  ;; use fast todo selection
  (setq org-use-fast-todo-selection t)

  ;; allow to fast fix todo state without triggering anything
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)

  ;; setup state triggers
  (setq org-todo-state-tags-triggers
        '(("ANNULÉ" ("ANNULÉ" . t))
          ("ATTENDRE" ("ATTENDRE" . t))
          ("ENATTENTE" ("ATTENDRE") ("ENATTENTE" . t))
          (done ("ATTENDRE") ("ENATTENTE") ("FOCUS"))
          ("TODO" ("ATTENDRE") ("ANNULÉ") ("ENATTENTE"))
          ("FINI" ("ATTENDRE") ("ANNULÉ") ("ENATTENTE"))))

  ;; tags
  (setq
   org-tag-persistent-alist '(("FOCUS" . ?f)
                              ("PROJET" . ?p))
   org-use-tag-inheritance t
   org-tags-exclude-from-inheritance '("projet"
                                       "litnotes"
                                       "people"))
  (setq
   org-agenda-dim-blocked-tasks nil
   ;; setting it to t speeds up agenda, but... initial visibility is
   ;; not honored, which for me is a bigger issue
   org-agenda-inhibit-startup nil

   ;; also show state change in log mode
   org-agenda-log-mode-items '(closed clock state)

   ;; tags
   org-agenda-show-inherited-tags nil

   ;; priorities
   org-fancy-priorities-list '("⚡" "⬆" "⬇" "☕")

   org-priority-faces
   `((?A . ,(face-foreground 'error))
     (?B . ,(face-foreground 'warning))
     (?C . ,(face-foreground 'success)))

   ;; more structured view
   org-agenda-prefix-format
   '((agenda . " %(vulpea-agenda-category 24) %?-12t %12s")
     (todo . " %(vulpea-agenda-category 24) ")
     (tags . " %(vulpea-agenda-category 24) ")
     (search . " %(vulpea-agenda-category 24) "))
   org-agenda-todo-keyword-format "%-1s"
   org-agenda-tags-column 0

   ;; show agenda in current window
   org-agenda-window-setup 'current-window

   org-agenda-custom-commands
   `((" " "Agenda"
      (,vulpea-agenda-cmd-refile
       ,vulpea-agenda-cmd-today
       ,vulpea-agenda-cmd-focus
       ,vulpea-agenda-eisen-imp-y-urg
       ,vulpea-agenda-cmd-projects
       ,vulpea-agenda-cmd-waiting)
      ((org-agenda-buffer-name vulpea-agenda-main-buffer-name)))
     ("e" "Matrice d'Eisenhower:"
      (,vulpea-agenda-cmd-eisen
       ,vulpea-agenda-eisen-imp-y-urg
       ,vulpea-agenda-eisen-imp
       ,vulpea-agenda-eisen-urg
       ,vulpea-agenda-eisen-alltodos)
      ((org-agenda-buffer-name vulpea-agenda-main-buffer-name)))))
  ;;tag-alist
  (setq-default
   org-tag-alist
   (quote (("@errand"     . ?e)
           ("@bureau"    . ?o)
           ("@maison"    . ?h)
           ("important"  . ?i)
           ("urgent"     . ?u)

           (:newline)
           ("ATTENDRE"  . ?w)
           ("SUSPENDUÉ" . ?h)
           ("ANNULÉ"    . ?c)
           ("RÉUNION"   . ?m)
           ("TÉLÉPHONE" . ?p)
           ("french"    . ?f)
           ("spanish"   . ?s))))
  ;;(with-no-warnings
  (setq org-ts-regexp-both-braket "\\([[<]\\)\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} ?[^]\n>]*?\\)\\([]>]\\)")
  ;; (defface org-deadline-custom-braket '((t (:inherit 'default))) "org-deadline" :group 'org)
  ;; (defface org-scheduled-custom-braket '((t (:inherit 'default))) "org-schedule" :group 'org)
  ;; (defface org-priority-hide '((t ())) "org-priority-hide" :group 'org)
  ;; (defface org-scheduled-custom '((t (:inherit 'default))) "org-schedule" :group 'org)
  ;; (defface org-closed-custom '((t (:inherit 'default))) "org-close" :group 'org)
  ;; (defface org-todo-keyword-done '((t ())) "org-done" :group 'org)
  ;; (defface org-todo-keyword-next '((t ())) "org-next" :group 'org)
  ;; (defface org-todo-keyword-proj '((t ())) "org-proj" :group 'org)
  ;; (defface org-todo-keyword-wait '((t ())) "org-wait" :group 'org)
  ;; (defface org-todo-keyword-todo '((t ())) "org-todo" :group 'org)
  ;; (defface org-todo-keyword-kill '((t ())) "org-kill" :group 'org)
  ;; ;;)
  ;; (with-no-warnings
  ;;   (custom-declare-face 'org-todo-keyword-next  '((t (:inherit (bold font-lock-constant-face org-todo)))) "")
  ;;   (custom-declare-face 'org-todo-keyword-proj '((t (:inherit (bold font-lock-doc-face org-todo)))) "")
  ;;   (custom-declare-face 'org-todo-keyword-wait  '((t (:inherit (bold warning org-todo)))) "")
  ;;   (custom-declare-face 'org-todo-keyword-kill  '((t (:inherit (bold error org-todo)))) ""))
)


#+end_src

** Latex OX (Presentation) /org-latex/
Setup of latex
#+begin_src emacs-lisp :noweb-ref org-latex
(use-package ox-latex
  :straight nil
  :after org
  :config
  (setq org-latex-compiler "xelatex") ;introduced in Org 9.0

  (setq org-latex-prefer-user-labels t) ;org-mode version 8.3+

  ;; Previewing latex fragments in Org mode
  ;; https://orgmode.org/worg/org-tutorials/org-latex-preview.html
  ;; (setq org-latex-create-formula-image-program 'dvipng) ;NOT Recommended
  (setq org-latex-create-formula-image-program 'imagemagick) ;Recommended

  (setq org-highlight-latex-and-related '(latex script))

  (add-to-list 'org-latex-packages-alist '("newfloat" "minted"))
  ;;(add-to-list 'org-latex-packages-alist '("" "color"))
  (setq org-preview-latex-image-directory
        (expand-file-name "ltximg/" *xdg-cache/*))
  (setq org-format-latex-options
        (list :foreground 'auto
              :background 'auto
              :scale 1.5
              :html-foreground "Black"
              :html-background "Transparent"
              :html-scale 1.0
              :matchers '("begin" "$1" "$" "$$" "\\(" "\\[")))
  (setq org-latex-listings 'minted)
  (setq org-preview-latex-default-process 'dvisvgm)
  (setq org-latex-pdf-process
        (seq-map
         (lambda (_)
           (string-join '("pdflatex"
                          "-shell-escape"
                          "-interaction nonstopmode"
                          "-output-directory %o %f")
                        " "))
         '(1 2 3))))


(use-package ox-beamer
  :straight nil
  :defer t
  :config
  (add-to-list
   'org-beamer-environments-extra
   '("onlyenv" "O" "\\begin{onlyenv}%a" "\\end{onlyenv}")))



(use-package ob-plantuml
  :straight nil
  :defer t
  :defines (org-plantuml-jar-path))


#+end_src

** Org TOC /org-toc/
#+begin_src emacs-lisp :noweb-ref org-toc
(use-package toc-org
  :hook (org-mode . toc-org-mode))

  
#+end_src
* Templates & YAS /templates/
These templates enable you to type things like =<el= and then hit =Tab= to expand
the template.  More documentation can be found at the Org Mode [[https://orgmode.org/manual/Easy-templates.html][Easy Templates]]
documentation page.

#+begin_src emacs-lisp :noweb-ref templates
;; This is needed as of Org 9.2
(with-eval-after-load 'org
(use-package org-tempo
  :straight nil
  :unless (version<= org-version "9.1.9")
  :after org
  :config   
  (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("li" . "src lisp"))
  (add-to-list 'org-structure-template-alist '("cli" . "src common-lisp"))
  (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
  (add-to-list 'org-structure-template-alist '("cl" . "src clojure"))
  (add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  (add-to-list 'org-structure-template-alist '("go" . "src go"))
  (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
  (add-to-list 'org-structure-template-alist '("json" . "src json"))))

(defvar file-templates-dir
  (expand-file-name "templates/" *emacs-config/* )
  "The path to yasnippet folders.")

(defvar file-templates-default-trigger "__"
  "The default yasnippet trigger key (a string).
Used for file template rules that don't have a :trigger property
in `file-templates-alist'.")

(defvar file-templates-alist
  `(
    ;; elisp
    ("dir-locals.el$"
     :ignore t)
    ("settings.el$"
     :ignore t)
    (emacs-lisp-mode
     :trigger "__package")
    (snippet-mode))
  "An alist of file template rules.
The CAR of each rule is either a major mode symbol or regexp
string.
The CDR is a plist. See `file-templates-set' for more
information.")

(use-package yasnippet
  :diminish yas-minor-mode
  :commands (yas-minor-mode-on
             yas-expand
             yas-expand-snippet
             yas-lookup-snippet
             yas-insert-snippet
             yas-new-snippet
             yas-visit-snippet-file
             yas-reload-all
             yas-dropdown-prompt
             yas--all-templates
             yas--get-snippet-tables
             yas--template-key)
  :hook ((text-mode . yas-minor-mode-on)
         (prog-mode . yas-minor-mode-on)
         (conf-mode . yas-minor-mode-on)
         (snippet-mode . yas-minor-mode-on))
  :init
  (add-hook 'find-file-hook #'file-templates-check)
  :config
  (setq yas-prompt-functions (delq #'yas-dropdown-prompt
                                   yas-prompt-functions)
        yas-snippet-dirs '(file-templates-dir))
  ;; Ensure file templates in `file-templates-dir' are visible
  (yas-reload-all))

(defun file-templates-check ()
  "Check the current buffer for file template expansion.
Returns non-nil when current buffer is a candidate for file
template expansion.
The buffer must be non-read-only, empty, and there must be a rule
in `file-templates-alist' that applies to it."
  (when (and (not buffer-read-only)
             (bobp) (eobp)
             (not (string-match-p "^ *\\*" (buffer-name))))
    (let ((rule (cl-find-if #'file-templates-p
                            file-templates-alist)))
      (when rule (apply #'file-templates--expand rule)))))

(defun file-templates--set (pred plist)
  "Register a file template.
Refer to `file-templates-set' documentation on the meaning of
PRED and PLIST."
  (if (null (car-safe plist))
      (setq file-templates-alist
            (delq (assoc pred file-templates-alist)
                  file-templates-alist))
    (push `(,pred ,@plist) file-templates-alist)))

(defun file-templates-set (pred &rest plist)
  "Register a file template.
PRED can either be a regexp string or a major mode symbol.
PLIST may contain these properties:
  :when FUNCTION
    Provides a secondary predicate. This function takes no
    arguments and is executed from within the target buffer. If
    it returns nil, this rule will be skipped over.
  :trigger STRING|FUNCTION
    If a string, this is the yasnippet trigger keyword used to
    trigger the target snippet.
    If a function, this function will be run in the context of
    the buffer to insert a file template into. It is given no
    arguments and must insert text into the current buffer
    manually.
    If omitted, `file-templates-default-trigger' is used.
  :mode SYMBOL
    What mode to get the yasnippet snippet from. If omitted,
    either PRED (if it's a major-mode symbol) or the mode of the
    buffer is used.
  :project BOOL
    If non-nil, ignore this template if this buffer isn't in a
    project.
  :ignore BOOL
    If non-nil, don't expand any template for this file and don't
    test any other file template rule against this buffer.
\(fn PRED &key WHEN TRIGGER MODE PROJECT IGNORE)"
  (declare (indent defun))
  (file-templates--set pred plist))

(cl-defun file-templates--expand
    (pred &key project mode trigger ignore _when)
  "Auto insert a yasnippet snippet into current file.
See `file-templates-set' for information about PRED,
PROJECT, MODE, TRIGGER, IGNORE and _WHEN arguments."
  (when (and pred (not ignore))
    (when (if project (project-p) t)
      (unless mode
        (setq mode (if (symbolp pred) pred major-mode)))
      (unless mode
        (user-error "Couldn't determine mode for %s file template"
                    pred))
      (unless trigger
        (setq trigger file-templates-default-trigger))
      (if (functionp trigger)
          (funcall trigger)
        (require 'yasnippet)
        (unless yas-minor-mode
          (yas-minor-mode-on))
        (when yas-minor-mode
          (yas-expand-snippet
           (yas-lookup-snippet trigger mode)))))))

(defun file-templates-p (rule)
  "Return non-nil if the RULE apply to the current buffer."
  (let ((pred (car rule))
        (plist (cdr rule)))
    (and (cond
          ((and (stringp pred)
                buffer-file-name)
           (string-match-p pred buffer-file-name))
          ((symbolp pred)
           (eq major-mode pred)))
         (or (not (plist-member plist :when))
             (funcall (plist-get plist :when)
                      buffer-file-name))
         rule)))

(defun file-templates-debug ()
  "Output the file template rule for current buffer.
Test the current buffer and outputs the file template rule most
appropriate for it. This is used for testing."
  (interactive)
  (message
   "Found %s"
   (cl-find-if
    #'file-templates-p
    file-templates-alist)))

#+end_src

* Distraction Free /distraction-free/
:PROPERTIES:
:header-args:    :noweb-ref distraction-free
:END:
setup olivetti to have a distraction free editing mode
#+begin_src emacs-lisp :noweb-ref distraction-free
  ;; Distraction-free screen
  (use-package  olivetti
    :config
    (setq olivetti-body-width .67)
    (defun distraction-free ()
      "Distraction-free writing environment"
      (interactive)
      (if (equal olivetti-mode nil)
	  (progn
	    (window-configuration-to-register 1)
	    (delete-other-windows)
	    (text-scale-increase 2)
	    (olivetti-mode t))
	(progn
	  (jump-to-register 1)
	  (olivetti-mode 0)
	  (text-scale-decrease 2))))
    :bind "<f9>"  #'distraction-free)

  #+end_src

* Coding Settings
:PROPERTIES:
:ID:                     7b76837f-f324-4bfa-a3b6-eaf47bb06ad3
:END:
I mostly use Clojure and Clojurescript, so they're setup inheriting from LISP setup
** Code IDE Setup
:PROPERTIES:
:header-args:         :noweb-ref code-ide
:ID:                     b33e2c0c-2928-4951-982d-f58ebac42a71
:END:
*** setup comint
#+begin_src emacs-lisp :noweb-ref code-ide
  (setup comint
        (setq ansi-color-for-comint-mode t)
        (setq comint-buffer-maximum-size 4096)
        (setq comint-prompt-read-only t))

  (unless *is-termux?*
       (setup compile
            (add-hook 'compilation-filter #'ansi-color-compilation-filter)
            (:option compilation-always-kill t
                     compilation-ask-about-save nil
                     compilation-scroll-output 'first-error)
            (defmacro compile-add-error-syntax (name regexp file line &optional col level)
              "Register new compilation error syntax.

          Add NAME symbol to `compilation-error-regexp-alist', and then add
          REGEXP FILE LINE and optional COL LEVEL info to
          `compilation-error-regexp-alist-alist'."
              (declare (indent 1))
              `(progn (add-to-list 'compilation-error-regexp-alist ',name)
                      (add-to-list 'compilation-error-regexp-alist-alist
                                   '(,name ,regexp ,file ,line ,col ,level))))
            (compile-add-error-syntax kaocha-tap
                                      "^not ok.*(\\([^:]*\\):\\([0-9]*\\))$"
                                      (1 "src/%s" "test/%s") 2)
            (compile-add-error-syntax kaocha-fail
                                      ".*FAIL in.*(\\([^:]*\\):\\([0-9]*\\))$"
                                      (1 "src/%s" "test/%s") 2)
            (compile-add-error-syntax clojure-reflection-warning
                                      "^Reflection warning,[[:space:]]*\\([^:]+\\):\\([0-9]+\\):\\([0-9]+\\).*$"
                                      (1 "src/%s" "test/%s") 2 3)
            (compile-add-error-syntax clojure-syntax-error
                                      "^Syntax error macroexpanding at (\\([^:]+\\):\\([0-9]+\\):\\([0-9]+\\)).$"
                                      (1 "src/%s" "test/%s") 2 3)
            (compile-add-error-syntax lua-stacktrace
                                      "\\(?:^[[:space:]]+\\([^
          :]+\\):\\([[:digit:]]+\\):[[:space:]]+in.+$\\)"
                                      1 2)
            (compile-add-error-syntax fennel-compile-error
                                      "\\(?:^Compile error in[[:space:]]+\\([^:]+\\):\\([[:digit:]]+\\)$\\)"
                                      1 2)
            ))

#+end_src
*** setup subword, eldoc
Set basic subword mode and eldoc setting for prog-mode
#+begin_src emacs-lisp :noweb-ref code-ide
(setup (:require subword)
    (global-subword-mode 1)
    (:hide-mode))

(setup (:require eldoc)
    (setq eldoc-echo-area-use-multiline-p nil)
    (setq eldoc-idle-delay 0.1)
    (:with-mode prog-mode
      (:hook turn-on-eldoc-mode))
    (:hook-into clojure-mode-hook
		cider-repl-mode-hook
		elisp-mode-hook
		lisp-interactive-mode-hook)
    (:hide-mode))

#+end_src
** Parentheses
Configure the mode that highlights matching delimiters or parentheses. I consider this of utmost importance when working with languages such as elisp.

Summary of what these do:

- Activate the mode upon startup.
- Show the matching delimiter/parenthesis if on screen, else show nothing. It is possible to highlight the expression enclosed by the delimiters, by using either mixed or expression. The latter always highlights the entire balanced expression, while the former will only do so if the matching delimiter is off screen.
- show-paren-when-point-in-periphery lets you highlight parentheses even if the point is in their vicinity. This means the beginning or end of the line, with space in between. I used that for a long while and it server me well. Now that I have a better understanding of Elisp, I disable it.
- Do not highlight a match when the point is on the inside of the parenthesis.
#+begin_src emacs-lisp :noweb-ref code-paren
;;; Parentheses (show-paren-mode)
(setup paren
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  ;;(setq show-paren-context-when-offscreen 'child-frame) ; Emacs 29
  (add-hook 'after-init-hook #'show-paren-mode))

;; matching braces
;; (use-package paren
;;   :straight nil
;;   :hook (prog-mode . show-paren-mode)
;;   :custom
;;     (set-face-attribute 'show-paren-match-expression nil :background "#363e4a")
;; )
#+end_src
*** setup smartparens
  Setup smartparens and rainbow delimiters
#+begin_src emacs-lisp :noweb-ref code-paren

(setup (:require elec-pair)
    (electric-pair-mode 1))


    ;; dimm parenthesis
    ;; (setup (:pkg paren-face)
    ;;   (:hook-into emacs-lisp-mode
    ;;       ielm-mode sly-repl-mode
    ;;       lisp-mode
    ;;       lisp-interaction-mode
    ;;       clojure-mode))

;; C-c @ C-d or C-s hide or show blocks
     (setup hideshow
      (defun +hs-cycle (&optional level)
        (interactive "p")
        (let (message-log-max
          (inhibit-message t))
      (if (= level 1)
          (pcase last-command
            ('+hs-cycle
             (hs-hide-level 1)
             (setq this-command 'hs-cycle-children))
            ('hs-cycle-children
             ;; TODO: Fix this case. `hs-show-block' needs to be
             ;; called twice to open all folds of the parent
             ;; block.
             (save-excursion (hs-show-block))
             (hs-show-block)
             (setq this-command 'hs-cycle-subtree))
            ('hs-cycle-subtree
             (hs-hide-block))
            (_
             (if (not (hs-already-hidden-p))
             (hs-hide-block)
           (hs-hide-level 1)
           (setq this-command 'hs-cycle-children))))
        (hs-hide-level level)
        (setq this-command 'hs-hide-level))))

      (defun +hs-global-cycle ()
        (interactive)
        (pcase last-command
      ('+hs-global-cycle
       (save-excursion (hs-show-all))
       (setq this-command 'hs-global-show))
      (_ (hs-hide-all))))
      (:with-mode hs-minor-mode
        (:hook-into prog-mode)
        (:bind "C-<tab>"   #'+hs-cycle
           "C-S-<tab>" #'+hs-global-cycle)))

    (setup (:pkg rainbow-delimiters)
      ;;(setq rainbow-delimiters-max-face-count 2)
      (:hook-into emacs-lisp-mode-hook
          eval-expression-minibuffer-setup-hook
          ielm-mode-hook
          lisp-interaction-mode-hook
          lisp-mode-hook
          sly-mrepl-mode-hook
          clojure-mode-hook)
  ;;    (:hide-mode)
      )

 (use-package smartparens
  :hook ((common-lisp-modes-mode . smartparens-strict-mode)
         (eval-expression-minibuffer-setup . minibuffer-enable-sp))
  :bind ( :map common-lisp-modes-mode-map
          (";" . sp-comment))
  :custom
  (sp-highlight-pair-overlay nil)
  (sp-highlight-wrap-overlay nil)
  (sp-highlight-wrap-tag-overlay nil)
  (sp-echo-match-when-invisible nil)
  :config
  (add-to-list 'sp-lisp-modes 'lisp-data-mode t)
  (require 'smartparens-config)
  (sp-use-paredit-bindings)
  ;; needs to be set manually, because :bind section runs before :config
  (define-key smartparens-mode-map (kbd "M-r") 'sp-rewrap-sexp)
  (defun minibuffer-enable-sp ()
    "Enable `smartparens-strict-mode' during `eval-expression'."
    (setq-local comment-start ";")
    (sp-local-pair 'minibuffer-pairs "'" nil :actions nil)
    (sp-local-pair 'minibuffer-pairs "`" nil :actions nil)
    (sp-update-local-pairs 'minibuffer-pairs)
    (smartparens-strict-mode 1)))
#+end_src
*** setup flycheck & flymake
#+begin_src emacs-lisp :noweb-ref code-ide
(use-package flymake
  :straight nil
  :custom
  (flymake-fringe-indicator-position 'right-fringe))

(use-package flycheck
  :defer 1
  :custom
  (flycheck-indication-mode 'right-fringe)
  (flycheck-display-errors-delay 86400 "86400 seconds is 1 day")
  (flycheck-emacs-lisp-load-path 'inherit)
  :config
  (flycheck-define-error-level 'error
    :severity 100
    :compilation-level 2
    :overlay-category 'flycheck-error-overlay
    :fringe-bitmap flymake-error-bitmap
    :fringe-face 'flycheck-fringe-error
    :error-list-face 'flycheck-error-list-error)
  (flycheck-define-error-level 'warning
    :severity 10
    :compilation-level 1
    :overlay-category 'flycheck-warning-overlay
    :fringe-bitmap flymake-warning-bitmap
    :fringe-face 'flycheck-fringe-warning
    :error-list-face 'flycheck-error-list-warning)
  (flycheck-define-error-level 'info
    :severity -10
    :compilation-level 0
    :overlay-category 'flycheck-info-overlay
    :fringe-bitmap flymake-note-bitmap
    :fringe-face 'flycheck-fringe-info
    :error-list-face 'flycheck-error-list-info)
  (define-advice flycheck-mode-line-status-text (:override (&optional status))
    "Get a text describing STATUS for use in the mode line.
STATUS defaults to `flycheck-last-status-change' if omitted or
nil."
    (concat " " flycheck-mode-line-prefix ":"
            (pcase (or status flycheck-last-status-change)
              (`not-checked "-/-")
              (`no-checker "-")
              (`running "*/*")
              (`errored "!")
              (`finished
               (let-alist (flycheck-count-errors flycheck-current-errors)
                 (format "%s/%s" (or .error 0) (or .warning 0))))
              (`interrupted ".")
              (`suspicious "?"))))
  (define-advice flycheck-may-use-echo-area-p (:override ())
    nil)
  :commands (global-flycheck-mode)
  :init
  (setq-default
   flycheck-emacs-lisp-load-path 'inherit
   flycheck-check-syntax-automatically
   '(save idle-change mode-enabled)
   flycheck-global-modes '(not org-mode))
  :config
  (global-flycheck-mode +1))

;; See lisp/dash-functional.el for more information. Here we simply
;; make sure that our mock is loaded instead of upstream.
(eval-when-compile
  (let ((dir (expand-file-name "lisp" *emacs-config/* )))
    (delete dir load-path)
    (add-to-list 'load-path dir)))

#+end_src
** LISP IDE
#+begin_src emacs-lisp :noweb-ref lisp-ide
 (use-package common-lisp-modes
  :delight
  :straight nil
  :bind ( :map common-lisp-modes-mode-map
          ("M-q" . common-lisp-modes-indent-or-fill-sexp))
  :preface
  (define-minor-mode common-lisp-modes-mode
    "Mode for enabling all modes that are common for lisps.
For reference, this is not a common-lisp modes mode, but a common
lisp-modes mode.
\\<common-lisp-modes-mode-map>"
    :lighter " clmm"
    :keymap (make-sparse-keymap))
  (defun common-lisp-modes-indent-or-fill-sexp ()
    "Indent s-expression or fill string/comment."
    (interactive)
    (let ((ppss (syntax-ppss)))
      (if (or (nth 3 ppss)
              (nth 4 ppss))
          (fill-paragraph)
        (save-excursion
          (mark-sexp)
          (indent-region (point) (mark))))))
  (provide 'common-lisp-modes))

#+end_src
** Emacs Lisp
:PROPERTIES:
:ID:                     177c09d9-4bc3-4fd8-8fa1-de4580519c38
:END:
ielm setup
#+begin_src emacs-lisp :noweb-ref code-elisp
  (setup (:require pulse)
    (defgroup +pulse nil
      "Extra customisations for `pulse'."
      :group 'pulse
      :prefix "+pulse-")

    (defcustom +pulse-location-commands '(scroll-up-command
                                          scroll-down-command
                                          recenter-top-bottom
                                          other-window
                                          switch-to-buffer
                                          redraw-frame)
      "Commands to pulse the current line after.
  Good for finding location."
      :type '(repeat function))

    (defcustom +pulse-location-function '+pulse-line-current-window
      "What function to call after `+pulse-location-commands'."
      :type 'function)

    ;; XXX: this doesn't work yet.  I only want to pulse the line in the
    ;; active window, so when I have the same buffer viewed in multiple
    ;; windows I can still see where my cursor is.  To see the issue, C-x
    ;; 2 then C-x o a few times.
    (defun +pulse-line-current-window (&rest _)
      "Pulse the current line, but only if this window is active."
      (pulse-momentary-highlight-one-line
       (window-point (selected-window))))

    (defun +pulse--advice-remove (symbol where function &optional props)
      "Remove advice SYMBOL from FUNCTION.
  This uses the same args as `advice-add' for easy toggling.
  WHERE and PROPS are discarded."
      (ignore where props)
      (advice-remove symbol function))

    (define-minor-mode +pulse-location-mode
      "After moving locations, pulse where we are."
      :global t
      :keymap nil
      (dolist (command +pulse-location-commands)
        (funcall
         (if +pulse-location-mode 'advice-add '+pulse--advice-remove)
         command :after +pulse-location-function)))
    (:option pulse-flag nil
             pulse-delay 0.5
             pulse-iterations 1)
    (dolist (command '(+ace-window-or-switch-buffer
                       pop-mark pop-globl-mark))
      (add-to-list '+pulse-location-commands command))
    (+ensure-after-init #'+pulse-location-mode))

  (setup elisp-mode
    (defun +elisp-eval-region-or-buffer ()
      (interactive)
      (if (region-active-p)
          (eval-region (region-beginning) (region-end))
        (+eval-region@pulse (lambda (_ _) (eval-buffer)) (point-min) (point-max))))

    (defun +eval-region@pulse (advised beg end &rest args)
      "ADVICE to pulse an eval'd region."
      (apply advised beg end args)
      (pulse-momentary-highlight-region beg end))

    (:option eval-expression-print-length nil
             eval-expression-print-level nil)
    (:with-map (emacs-lisp-mode-map lisp-interaction-mode-map)
      (:bind "C-c C-c" #'eval-defun
             "C-c C-k" #'+elisp-eval-region-or-buffer
             "C-c C-z" #'ielm )
    (advice-add #'eval-region :around #'+eval-region@pulse)))

  (setup (:pkg elisp-slime-nav)
    (:load-after ielm
      (:hook-into emacs-lisp-mode ielm-mode)
      (:hide-mode)))

  (setup (:pkg ielm)
    (:load-after comint
      (:with-map ielm-map
        (:bind
         [up] comint-previous-input
         [down] comint-next-input))))

  (setup (:pkg macrostep)
    (:with-map macrostep-keymap
      (:bind
       [tab] macrostep-next-macro
       [backtab] macrostep-prev-macro
       "c" macrostep-collapse
       "e" macrostep-expand
       "q" macrostep-collapse-all))
    (:hide-mode))

;; Evaluation Result Overlay
;; (setup (:pkg eros)
;;   (:hook-into emacs-lisp-mode eros-mode))
#+end_src
** Common LISP
:PROPERTIES:
:ID:                     91288bc3-f9f3-4b78-bd8d-5077decdeef0
:END:
SLY setup
#+begin_src emacs-lisp :noweb-ref code-common-lisp
 (use-package lisp-mode
  :straight nil
  :hook ((lisp-mode lisp-data-mode) . common-lisp-modes-mode))

(use-package inf-lisp
  :straight nil
  :hook (inferior-lisp-mode . common-lisp-modes-mode)
  :custom
  (inferior-lisp-program (cond ((executable-find "sbcl") "sbcl")
                               ((executable-find "ecl") "ecl"))))


  (defvar mf/cl-implementations
  '((sbcl ("sbcl"))
    ;;    (sbcl-renderdoc ("sbcl-renderdoc.sh"))
    ))

  (defun mf/sly-ask ()
      (interactive)
      (let ((current-prefix-arg '-))
        (sly nil nil t)))

    (setup (:pkg sly)
      (:when-loaded
        (sly-setup '(sly-fancy))
        (:require 'sly-autoloads))
      (setq sly-command-switch-to-existing-lisp 'always)
      (setq sly-complete-symbol-function 'sly-flex-completions)
      (setq sly-enable-evaluate-in-emacs t)
      (setq sly-kill-without-query-p t)
      (setq sly-lisp-implementations mf/cl-implementations)
      (setq sly-mrepl-history-file-name (save-in-etc-file! "sly-repl-history"))
      (setq sly-mrepl-pop-sylvester nil)
      (setq sly-mrepl-prevent-duplicate-history 'move)
      (setq sly-net-coding-system 'utf-8-unix)
      (:with-map sly-mrepl-mode-map
        (:bind
         [S-return] newline-and-indent
         [up] sly-mrepl-previous-input-or-button
       [down] sly-mrepl-next-input-or-button))
      (:with-map sly-inspector-mode-map
        (:bind
         [return] push-button
         [M-return] sly-mrepl-copy-part-to-repl
         "gb" sly-inspector-pop
         "h" sly-inspector-history
         "i" sly-inspector-describe-inspectee
         "p" sly-button-pretty-print))
      (:hide-mode))

 (use-package sly
  :after inf-lisp
  :hook (sly-mrepl-mode . common-lisp-modes-mode)
  :config
  (sly-symbol-completion-mode -1))

  (setup lisp-mode
    (:load-after sly
      (define-local-keys lisp-mode-map
        "'" '(sly :wk "sly")
        ";" `(mf/sly-ask :wk "sly (ask)"))
      (define-local-keys lisp-mode-map
        :infix "c"
        "" '(:ignore t :wk "compile")
        "c" '(sly-compile-file :wk "compile file")
        "C" '(sly-compile-and-load-file :wk "compile/load file")
        "f" '(sly-compile-defun :wk "compile top-level form")
        "l" '(sly-load-file :wk "load file")
        "n" '(sly-remove-notes :wk "remove notes")
        "r" '(sly-compile-region :wk "compile region"))
      (define-local-keys lisp-mode-map
        :infix "e"
        "" '(:ignore t :wk "evaluate")
        "b" '(sly-eval-buffer :wk "buffer")
        "e" '(sly-eval-last-expression :wk "last expression")
        "f" '(sly-eval-defun :wk "function")
        "F" '(sly-undefine-function :wk "undefine function")
        "r" '(sly-eval-region :wk "region"))
      (define-local-keys lisp-mode-map
        :infix "g"
        "" '(:ignore t :wk "go")
        "b" '(sly-pop-find-definition-stack :wk "back")
        "d" '(sly-edit-definition :wk "definition")
        "D" '(sly-edit-definition-other-window :wk "definition (other window)")
        "n" '(sly-next-note :wk "next note")
        "N" '(sly-previous-note :wk "previous note")
        "s" '(sly-stickers-next-sticker :wk "next sticker")
        "S" '(sly-stickers-prev-sticker :wk "previous sticker"))
      (define-local-keys lisp-mode-map
        :infix "h"
        "" '(:ignore t :wk "help")
        "<" '(sly-who-calls :wk "who calls")
        ">" '(sly-calls-who :wk "calls who")
        "~" '(hyperspec-lookup-format :wk "lookup format directive")
        "#" '(hyperspec-lookup-reader-macro :wk "lookup reader macro")
        "a" '(sly-apropos :wk "apropos")
        "b" '(sly-who-binds :wk "who binds")
        "d" '(sly-disassemble-symbol :wk "disassemble symbol")
        "h" '(sly-describe-symbol :wk "describe symbol")
        "H" '(sly-hyperspec-lookup :wk "hyperspec lookup")
        "m" '(sly-who-macroexpands :wk "who macro-expands")
        "p" '(sly-apropos-package :wk "apropos package")
        "r" '(sly-who-references :wk "who references")
        "s" '(sly-who-specializes :wk "who specializes")
        "S" '(sly-who-sets :wk "who sets"))
      (define-local-keys lisp-mode-map
        :infix "r"
        "" '(:ignore t :wk "repl")
        "c" '(sly-mrepl-clear-repl :wk "clear")
        "q" '(sly-quit-lisp :wk "quit")
        "r" '(sly-restart-inferior-lisp :wk "restart")
        "s" '(sly-mrepl-sync :wk "sync"))
      (define-local-keys lisp-mode-map
        :infix "s"
        "" '(:ignore t :wk "stickers")
        "b" '(sly-stickers-toggle-break-on-stickers :wk "toggle break")
        "c" '(sly-stickers-clear-defun-stickers :wk "clear function")
        "C" '(sly-stickers-clear-buffer-stickers :wk "clear buffer")
        "f" '(sly-stickers-fetch :wk "fetch")
        "r" '(sly-stickers-replay :wk "replay")
        "s" '(sly-stickers-dwim :wk "add/remove"))
      (define-local-keys lisp-mode-map
        :infix "t"
        "" '(:ignore t :wk "trace")
        "t" '(sly-toggle-trace-fdefinition :wk "toggle")
        "T" '(sly-toggle-fancy-trace :wk "toggle (fancy)")
        "u" '(sly-untrace-all :wk "untrace all"))))

   (use-package racket-mode
  :hook ((racket-mode racket-repl-mode) . common-lisp-modes-mode))

#+end_src
** Clojure
:PROPERTIES:
:ID:                     0c4cf23b-280e-4fbc-ae81-e091f8f8bc8d
:END:
Editing Clojure / Clojurescript code is best done using a REPL, which is provided with the cider package.
Cider has a lot of options to customise, and here are the ones I think are most critical.
Source comes from: [[https://stackoverflow.com/a/31080940]]
#+begin_src elisp :noweb-ref code-clojure
(use-package clojure-mode
  :hook ((clojure-mode
          clojurec-mode
          clojurescript-mode)
         . clojure-mode-setup)
  :mode (rx "/.edn" eos)
  :bind ("<M-return>" . 'clerk-show)
  :config
  (defvar org-babel-default-header-args:clojure '((:results . "silent")))'
  (defun org-babel-execute:clojure (body params)
    "Evaluate a block of Clojure code with Babel."
    (lisp-eval-string body))
  (defun clojure-set-compile-command ()
    (let ((project-dir (clojure-project-dir)))
      (cond ((and (file-exists-p (expand-file-name "project.clj" project-dir))
                  (executable-find "lein"))
             (setq-local compile-command "lein "))
            ((and (file-exists-p (expand-file-name "deps.edn" project-dir))
                  (executable-find "clojure"))
             (setq-local compile-command "clojure ")))))
  (defun clojure-mode-setup ()
    "Setup Clojure buffer."
    (common-lisp-modes-mode)
    (clojure-set-compile-command)
    (flycheck-mode))
   (defun clerk-show ()
	(interactive)
	(save-buffer)
	(let
	    ((filename
	      (buffer-file-name)))
	  (when filename
	    (cider-interactive-eval
	     (concat "(nextjournal.clerk/show! \"" filename "\")"))))))

(use-package cider
  :delight " cider"
  :hook (((cider-repl-mode cider-mode) . eldoc-mode)
         (cider-repl-mode . common-lisp-modes-mode))
  :bind ( :map cider-repl-mode-map
          ("C-c C-S-o" . cider-repl-clear-buffer))
  :custom-face
  (cider-result-overlay-face ((t (:box (:line-width -1 :color "grey50")))))
  (cider-error-highlight-face ((t (:inherit flymake-error))))
  (cider-warning-highlight-face ((t (:inherit flymake-warning))))
  :custom
  (nrepl-log-messages nil)
  (cider-repl-display-help-banner nil)
  (cider-repl-tab-command #'indent-for-tab-command)
  (nrepl-hide-special-buffers t)
  (cider-test-show-report-on-success t)
  (cider-allow-jack-in-without-project t)
  (cider-use-fringe-indicators nil)
  (cider-font-lock-dynamically '(macro var deprecated))
  (cider-save-file-on-load nil)
  (cider-inspector-fill-frame nil)
  (cider-auto-select-error-buffer t)
  (cider-eval-spinner t)
  (nrepl-use-ssh-fallback-for-remote-hosts t)
  (cider-enrich-classpath t))

  (use-package clj-refactor
  :delight clj-refactor-mode
  :hook ((clj-refactor-mode . yas-minor-mode)
         (cider-mode . clj-refactor-mode))
  :custom
  (cljr-suppress-no-project-warning t)
  (cljr-suppress-middleware-warnings t)
  (cljr-warn-on-eval nil))

  (setup (:pkg async))
  ;;(setup (:pkg ob-async))
  ;;(setup (:pkg ob-clojurescript))
  ;;(setup (:pkg ob-babel-eval-in-repl))

  (setup (:pkg flycheck-clj-kondo)
    :only-if (executable-find "clj-kondo"))

  ;;(setup (:pkg eval-in-repl))

#+end_src


**** clj templates
:PROPERTIES:
:ID:                     330e9ad1-9bd0-4386-ac8d-0a678ebb1626
:END:
Insertion templates can be used to speed up project setups. This is code of my own creation, so use at your own risk. The template files are in ~.emacs.d/templates/lib.org~.

***** slurp
:PROPERTIES:
:ID:                     0828d7f4-cd5d-4c67-96ca-3d258df3de6c
:END:
#+begin_src elisp
(defun slurp (file)
  (with-temp-buffer
    (insert-file-contents file)
    (buffer-substring-no-properties
     (point-min)
     (point-max))))

#+end_src

***** template-reader
:PROPERTIES:
:ID:                     b3a54fa3-459b-4042-98e0-cdb2a87ed925
:END:
#+begin_src elisp
(defun template-reader (file replace)
  (let ((lines (split-string (slurp file) "\n")))
    (->> lines
         (mapcar (lambda (x) (replace-regexp-in-string "_str_" replace x)))
         (mapcar (lambda (x) (concat x "\n")))
         (-concat)
         (apply 'concat))))

#+end_src

***** clj-org-templates
:PROPERTIES:
:ID:                     7d6c4f18-4510-4ebc-951d-94c4233407a5
:END:
I use org mode and literate programming ideas to build my clj/cljs projects. So, it is helpful to have skeletons that take .org template files that tangle into a nice clojure project setup. Currently I only have one template, but the idea is to be able to have a few which you just bind to different keys as needed. The idea is demonstrated with 'Project' and 'Library'.

#+begin_src elisp :tangle no
(define-skeleton cljc-lib-skeleton
  "Inserts a .org template with user's project name input.
   Use in empty file and save to desired project directory.
   Tangle will create project structure on save."
  ""
  (template-reader "~/.config/emacs/templates/lib.org" (skeleton-read "Library name: ")))

(define-skeleton cljc-project-skeleton
  "Inserts a .org template with user's project name input.
   Use in empty file and save to desired project directory.
   Tangle will create project structure on save."
  ""
  (template-reader "~/.emacs.d/templates/lib.org" (skeleton-read "Project name: ")))

;;(global-set-key (kbd "C-S-L") 'cljc-lib-skeleton)
;;(global-set-key (kbd "C-S-P") 'cljc-project-skeleton)

#+end_src
** Fennel
:properties:
:header-args: :noweb-ref code-fennel
:ID:                     a8e738f4-2a6a-4fe4-8efe-9cedd4aaedd3
:end:
Setup of Fennel and Lua

#+begin_src emacs-lisp

(use-package lua-mode
  :hook (lua-mode . flycheck-mode)
  :custom
  (lua-indent-level 2)
  :config
  (defvar org-babel-default-header-args:lua '((:results . "silent")))
  (defun org-babel-execute:lua (body _)
    "Evaluate a block of Lua code with Babel."
    (lua-get-create-process)
    (lua-send-string body)))


(use-package fennel-mode
  :straight (:host nil :repo "https://git.sr.ht/~technomancy/fennel-mode")
  :hook ((fennel-mode fennel-repl-mode) . common-lisp-modes-mode)
  :bind ( :map fennel-mode-map
          ("C-c C-k" . eval-each-sexp)
          ("M-." . xref-find-definitions)
          ("M-," . xref-pop-marker-stack))
  :config
  (dolist (sym '(global local var))
    (put sym 'fennel-indent-function 1))
  (defvar org-babel-default-header-args:fennel '((:results . "silent")))
  (defun org-babel-execute:fennel (body _params)
    "Evaluate a block of Fennel code with Babel."
    (save-window-excursion
      (unless (bufferp fennel-repl--buffer)
        (fennel-repl nil))
      (let ((inferior-lisp-buffer fennel-repl--buffer))
        (lisp-eval-string body))))
  :init
  (defun eval-each-sexp ()
    "Evaluate each s-expression in the buffer consequentially.
If prefix ARG specified, call `fennel-reload' function.  If
double prefix ARG specified call `fennel-reload' function and ask
for the module name."
    (interactive)
    (save-excursion
      (save-restriction
        (goto-char (point-min))
        (while (save-excursion
                 (search-forward-regexp "[^[:space:]]." nil t))
          (forward-sexp)
          (when (and (not (nth 4 (syntax-ppss)))
                     (looking-back "." 1))
            (lisp-eval-last-sexp)))))
    (when fennel-mode-switch-to-repl-after-reload
      (switch-to-lisp t))))

  (setup (:pkg ssh-config-mode)
  (:file-match (rx "/.ssh/config" eos)
               (rx "/ssh" (? "d") "_config" eos))
  (:with-mode ssh-known-hosts-mode
    (:file-match (rx "/knownhosts" eos)))
  (:with-mode ssh-authorized-keys-mode
    (:file-match (rx "/authorized_keys" (? "2") eos))))
#+end_src
** Statistics
:PROPERTIES:
:ID:                     8384410a-5ec8-43e5-a0bc-fdecdfe79daa
:END:
Emacs Speaks Statistics
#+begin_src emacs-lisp :noweb-ref ess
  (setup (:pkg ess)
    ;;(:require ess-r-mode)
    (setq ess-ask-for-ess-directory nil)
    (setq ess-local-process-name "R")
    (setq-default inferior-R-program-name "/usr/local/bin/R")
    (setq ess-eval-visibly 'nowait)
    (setq comint-input-ring-size 1000)
    (setq ess-indent-level 4)
    (setq ess-arg-function-offset 4)
    (setq ess-else-offset 4)

    ;; Autocomplete
    (:require auto-complete-config)
    (ac-config-default)
    (setq ess-use-auto-complete t)

    ;; Read pdfs outside emacs
    (:require openwith)
    (openwith-mode t)
    (setq openwith-associations '(("\\.pdf\\'" "open" (file))))
	;;;; create a new frame for each help instance
    (setq ess-help-own-frame t)
    (setq ess-offset-continued 'straight
	  ess-use-flymake 1
	  ess-nuke-trailing-whitespace-p t
	  ess-style 'DEFAULT
	  ess-history-directory (expand-file-name "ess-history/" *xdg-cache/*))
    ;; Make the arrow keys refer to previous commands
    (defun my-ess-mode-hook ()
      (local-set-key '[up] 'comint-previous-input)
      (local-set-key '[down] 'comint-next-input)
      (local-set-key '[C-x \t] 'comint-dynamic-complete-filename))

      (add-hook 'inferior-ess-mode-hook 'my-ess-mode-hook))

 (defhydra hydra-polymode ()
  "Polymode Hydra"
  ("j" polymode-next-chunk-same-type "Next chunk, same type" :column "Movement")
  ("k" polymode-previous-chunk-same-type "Previous chunk, same type" :column "Movement")
  ("i" polymode-insert-new-chunk "Insert new chunk" :column "Insert")
  ("I" jth/insert-image "Insert image from file" :column "Insert")
  ("c" polymode-mark-or-extend-chunk "Mark chunk" :column "Chunk")
  ("u" polymode-insert-new-chunk-code-only "Insert chunk (code only)" :column "Insert")
  ("U" polymode-insert-new-chunk-output-only "Insert chunk (output only)" :column "Insert")
  ("p" polymode-insert-new-plot "Insert plot" :column "Insert")
  ("o" polymode-insert-yaml "Insert YAML" :column "Insert")
  ("d" polymode-kill-chunk "Kill chunk" :column "Chunk")
  ("m" my/add-pipe "Add pipe" :column "Insert")
  ("e" polymode-export "Export" :column "Export")
  ("E" polymode-set-exporter "Set exporter" :column "Export")
  ("w" polymode-weave "Weave" :column "Export")
  ("W" polymode-set-weaver "Set weaver" :column "Export")
  ("$" polymode-show-process-buffer "Show process buffer" :column "Evaluation")
  ("," polymode-eval-region-or-chunk "Eval chunk" :column "Evaluation")
  ("N" polymode-eval-buffer "Eval buffer" :column "Evaluation")
  ("1" polymode-eval-buffer-from-beg-to-point "Eval to here" :column "Evaluation")
  ("0" polymode-eval-buffer-from-point-to-end "Eval to end" :column "Evaluation"))
#+end_src


* Tangling config noweb
** Header & disclaimer <disclaimer>
:PROPERTIES:
:header-args: :noweb-ref disclaimer
:END:

#+begin_src emacs-lisp
;; Copyright (C) 2001-2022 Gas
;; Timestamp: <>
;; Author: Gas <gas@tuatara.red>
;; Version: 1.0
;; Package-Version: 0.7
;; Created: Sometime during the Covid-19 lockdown
;; Keywords: configuration, emacs
;; URL: https://github.com/frap/emacs
;; Package-Requires: ((emacs "27.2"))

;; This file is not part of GNU Emacs.

;;; Commentary:
;; This file maybe automatically tangled from config.org.
;; Hand edits will be overwritten!
;; Je t'ai prévenu putain!

#+end_src
** Emacs PATH config and constants
:PROPERTIES:
:header-args: :tangle lisp/config-path.el :noweb yes
:END:
#+begin_src emacs-lisp
;;; config-path.el --- Path constants -*- lexical-binding: t -*-

<<disclaimer>>
;;
;; This module defines path constants used across other modules.
;;
;;; Code:
<<constants>>

<<path-config>>

(provide 'config-path)
;;; config-path.el ends here
#+end_src
** Keyboard
:PROPERTIES:
:header-args: :tangle lisp/init-kbd.el :noweb yes
:ID:       53f268fc-1d6f-4fe4-a047-945da3ceb14c
:END:
Setup keyboard

#+begin_src emacs-lisp
;;; init-kbd.el --- Setup Keyboard -*- lexical-binding: t -*-

<<disclaimer>>
;;
;; This module sets up keyboard
;;
;;; Code:

(require 'init-elpa)
;;(require 'init-env)
<<mac-keys>>

(provide 'init-kbd)
;;; init-kbd.el ends here
#+end_src
** Sanity Defaults
:PROPERTIES:
:header-args: :tangle lisp/init-sanity.el :noweb yes
:ID:       ec18e2f5-2fad-4939-8c18-c5b7154bb002
:END:

"Setup" of Emacs to some sort of sanity

#+begin_src emacs-lisp
;;; init-sanity.el --- Sanity -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<sanity>>

(provide 'init-sanity)
;;; init-sanity.el ends here
#+end_src

** Emacs Startup enhancements and GC
:PROPERTIES:
:header-args: :tangle lisp/init-startup.el :noweb yes
:ID:       4ec8d416-737b-4443-b7d9-a7141e810a70
:END:

Setup auto-compile, no littering and GMCH

#+begin_src emacs-lisp
;;; init-startup.el --- Emacs Startup -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(with-message! "Emacs Startup enhancements"

<<emacs-startup>>

);;end-of with-message!
(provide 'init-startup)
;;; init-startup.el ends here
#+end_src
** Emacs Builtins

Setup Emacs builtins

#+begin_src emacs-lisp :tangle no
;;; enfer-pkg-builtin.el --- Builtins -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:
(setup auto-fill
       (:with-feature simple
		      (:with-mode (text-mode org-mode)
				  (:hook turn-on-auto-fill))
		      (:with-mode prog-mode
				  (:hook (fn (setq-local comment-auto-fill-only-comments t)
					     (auto-fill-mode 1))))
		      (:hide-mode auto-fill-function)))


(setup (:require goto-addr)
       (:with-mode prog-mode
		   (:hook goto-address-prog-mode))
       (:with-mode text-mode
		   (:hook goto-address-mode)))

(setup (:require help-mode)
       (setq help-window-select t))

(setup (:require url)
       (setq url-cookie-file (save-in-etc-file! "url-cookies")))

(provide 'enfer-pkg-builtin)
;;; enfer-pkg-builtin.el ends here
#+end_src
** Emacs UI Appearance
:PROPERTIES:
:header-args: :tangle lisp/init-ui.el :noweb yes
:END:

Setup UI

#+begin_src emacs-lisp
;;; init-ui.el --- UI Setup -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<appearance>>

<<fonts>>

<<modus>>

<<highlights>>

(provide 'init-ui)
;;; init-ui.el ends here
#+end_src
** Buffers
:PROPERTIES:
:header-args: :tangle lisp/init-buffer.el :noweb yes
:END:

Setup the Emacs buffer

#+begin_src emacs-lisp
;;; init-buffer.el --- Buffer Setup -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(require 'config-path)
(require 'init-kbd)

<<buffers>>

(provide 'init-buffer)
;;; init-buffer.el ends here
#+end_src

*** lib-buffer
:PROPERTIES:
:header-args: :tangle lisp/lib-buffer.el :noweb yes
:END:

Autoloads for buffers
#+begin_src emacs-lisp
;;; lib-buffer.el --- Utilities for working with Buffers -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

;;;###autoload
(defun buffer-content (buffer-or-name)
  "Return content of BUFFER-OR-NAME.
  Resulting string is full of properties. Consider using
  `substring-no-properties':
    (substring-no-properties (buffer-content BUFFER-OR-NAME))"
    (with-current-buffer buffer-or-name
      (buffer-substring (point-min)
                        (point-max))))

;;;###autoload
(defun buffer-lines (buffer-or-name)
  "Return lines of BUFFER-OR-NAME.
  Each line is a string with properties. Trailing newline character
  is not present."
  (buffer-lines-map buffer-or-name #'identity))

;;;###autoload
(defun buffer-lines-map (buffer-or-name fn)
  "Call FN on each line of BUFFER-OR-NAME and return resulting list.
  As opposed to `buffer-lines-each', this function accumulates
  result.
  Each line is a string with properties. Trailing newline character
  is not present."
  (declare (indent 1))
  (with-current-buffer buffer-or-name
    (goto-char (point-min))
    (let ((result))
      (while (not (eobp))
        (setq
         result
         (cons
          (funcall fn (buffer-substring
                       (line-beginning-position)
                       (line-end-position)))
          result))
        (forward-line))
      (reverse result))))

;;;###autoload
(defun buffer-lines-each (buffer-or-name fn)
  "Call FN on each line of BUFFER-OR-NAME.
  As opposed to `buffer-lines-map', this function does not
  accumulate any result and should used for side-effects.
  Each line is a string with properties. Trailing newline character
  is not present."
  (declare (indent 1))
  (with-current-buffer buffer-or-name
    (goto-char (point-min))
    (while (not (eobp))
      (funcall fn (buffer-substring
                   (line-beginning-position)
                   (line-end-position)))
      (forward-line))))

;;;###autoload
(defun buffer-lines-each-t (buffer-or-name fn)
  "Call FN on each line of BUFFER-OR-NAME and replace it by result.
  Each line is a string with properties. Trailing newline character
  is not present."
    (declare (indent 1))
    (with-current-buffer buffer-or-name
      (goto-char (point-min))
      (let (l0 l1 s)
        (while (not (eobp))
          (setq l0 (line-beginning-position))
          (setq l1 (line-end-position))
          (setq s (buffer-substring l0 l1))
          (replace-region-contents l0 l1 (lambda () (funcall fn s)))
          (forward-line)))))

;;;###autoload
(defun buffer-generate (name &optional unique inhibit-buffer-hooks)
    "Create and return a buffer with a name based on NAME.
  Unless UNIQUE, choose the buffer’s name using
  ‘generate-new-buffer-name’. Otherwise if buffer with NAME already
  exists, recreate it.
  See ‘get-buffer-create’ for the meaning of INHIBIT-BUFFER-HOOKS."
    (when unique
      (when-let ((buffer (get-buffer name)))
        (kill-buffer buffer)))
    (generate-new-buffer name inhibit-buffer-hooks))

(provide 'lib-buffer)
;;; lib-buffer.el ends here

#+end_src
** Emacs Completion Frameworks
:PROPERTIES:
:header-args: :tangle lisp/init-selection.el :noweb yes
:ID:       364ebd72-5f4a-4c3d-9883-836916245ef8
:END:

Setup embark, vertico and consult


#+begin_src emacs-lisp
  ;;; init-selection.el --- Completion -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:


  <<pkg-completion>>

  (provide 'init-selection)
   ;;; init-selection.el ends here
#+end_src
** Emacs Windows
:PROPERTIES:
:header-args: :tangle lisp/init-window.el :noweb yes
:ID:       dff15b7b-84eb-4992-b32f-716a3b47c36a
:END:

windose

#+begin_src emacs-lisp
;;; init-window.el --- Windose -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<windose>>

(provide 'init-window)
;;; init-window.el ends here
#+end_src
** Projects
:PROPERTIES:
:header-args: :tangle lisp/init-project.el :noweb yes
:END:
Setup projects

#+begin_src emacs-lisp
;;; init-project.el --- Projects -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(require 'lib-eval)
(require 'config-path)
(require 'init-vcs)
(require 'init-kbd)
(require 'project)

<<projet>>

(provide 'init-project)
;;; init-project.el ends here
#+end_src
** VCS
:PROPERTIES:
:header-args: :tangle lisp/init-vcs.el :noweb yes
:END:

Setup Magit & Git

#+begin_src emacs-lisp
;;; init-vcs.el --- Magit  -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

;;(require 'lib-hook)
(require 'config-path)
(require 'init-elpa)

<<vcs>>

(provide 'init-vcs)
;;; init-vcs.el ends here
#+end_src
** Notes tangle
:PROPERTIES:
:header-args: :tangle lisp/init-notes.el :noweb yes
:END:
Setup org-mode for Note taking

#+begin_src emacs-lisp
;;; init-notes.el --- Org Notetaking Workflow -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:
(require 'config-path)
(require 'init-elpa)
(require 'init-env)

(require 'config-orgmode)

(defconst *notes/*
  (file-name-as-directory (expand-file-name "~/org")))

<<org-defaults>>

<<org-agenda>>

(provide 'init-notes)
;;; init-notes.el ends here
#+end_src

** Coding
Setup Coding languages

*** Basic IDE
:PROPERTIES:
:ID:                     bbc17bb5-e026-4a01-83c7-19a4d1924c96
:END:
Setup the basic Coding IDE

*** Coding IDE Setup
:properties:
:header-args: :tangle lisp/init-ide.el :noweb yes
:end:
Setup of parens and basic coding setup - aka prog mode, also C setup
#+begin_src emacs-lisp
;;; init-ide.el --- Code IDE -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<code-ide>>

<<code-paren>>

<<code-c>>

(provide 'init-ide)
;;; init-ide.el ends here
#+end_src

*** LISP setup
:properties:
:header-args: :tangle lisp/init-lisp.el :noweb yes
:ID:       e285fd8e-e55c-4b82-bc3a-e42634c4b6b2
:end:
LISP Common setup here
#+begin_src emacs-lisp
  ;;; init-lisp.el --- Code LISP -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<lisp-ide>>

  (provide 'init-lisp)
   ;;; init-lisp.el ends here
#+end_src

*** Eval lib
:PROPERTIES:
:header-args: :tangle lisp/lib-eval.el :noweb yes
:ID:       2aad25fa-9a36-4484-b2a6-4397d836773c
:END:
Smartparens setup here
#+begin_src emacs-lisp
;;; lib-eval.el --- Eval utilities -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:
(defmacro eval-with-default-dir (dir &rest body)
  "Invoke in DIR the BODY."
  (declare (debug t) (indent 1))
  `(let ((default-directory ,dir))
     ,@body))

(cl-flet ((always-yes (&rest _) t))
  (defun eval-no-confirm (fun &rest args)
    "Apply FUN to ARGS, skipping user confirmations."
    (cl-letf (((symbol-function 'y-or-n-p) #'always-yes)
              ((symbol-function 'yes-or-no-p) #'always-yes))
      (apply fun args))))

(provide 'lib-eval)
;;; lib-eval.el ends here
#+end_src
*** Emacs-lisp setup
:PROPERTIES:
:header-args: :tangle lisp/init-elisp.el :noweb yes
:ID:       c07e92e9-c358-4938-977c-b6aa393c7277
:END:
#+begin_src emacs-lisp
;;; init-elisp.el --- Emacs LISP -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<code-elisp>>

(provide 'init-elisp)
;;; init-elisp.el ends here
#+end_src
*** Common LISP setup
:PROPERTIES:
:header-args: :tangle lisp/init-clisp.el :noweb yes
:ID:       7c6c8865-ce5d-4b09-ac24-81cff979efb1
:END:
#+begin_src emacs-lisp
;;; init-clisp.el --- Common-LISP -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<code-common-lisp>>

(provide 'init-clisp)
;;; init-clisp.el ends here
#+end_src
*** Clojure setup
:PROPERTIES:
:header-args: :tangle lisp/init-clojure.el :noweb yes
:ID:       7f8725fd-d78e-4f0d-9599-566cf5173112
:END:
#+begin_src emacs-lisp
;;; init-clojure.el --- Clojure -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<code-clojure>>

(provide 'init-clojure)
;;; init-clojure.el ends here
#+end_src
*** Fennel/LUA setup
:PROPERTIES:
:header-args: :tangle lisp/init-fennel.el :noweb yes
:ID:       afda404b-1889-4438-9efd-40a0aff2218d
:END:
#+begin_src emacs-lisp
;;; init-fennel.el --- Fennel LUA  -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<code-fennel>>

(provide 'init-fennel)
;;; init-fennel.el ends here
#+end_src
*** ESS setup
:Properties:
:header-args: :tangle lisp/init-ess.el :noweb yes
:ID:       a04b95ad-e2ca-4aa3-8f4a-301f6986cda8
:END:
Emacs Speaks Statisitcs setup here
#+begin_src emacs-lisp
;;; init-ess.el --- Code ESS -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

<<ess>>

(provide 'init-ess)
;;; init-ess.el ends here
#+end_src

**** Eval lib
:PROPERTIES:
:header-args: :tangle lisp/lib-eval.el :noweb yes
:ID:       5b4b0991-3552-42c0-b352-64de8428927a
:END:
Smartparens setup here
#+begin_src emacs-lisp
;;; lib-eval.el --- Eval utilities -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:
(defmacro eval-with-default-dir (dir &rest body)
  "Invoke in DIR the BODY."
  (declare (debug t) (indent 1))
  `(let ((default-directory ,dir))
     ,@body))

(cl-flet ((always-yes (&rest _) t))
  (defun eval-no-confirm (fun &rest args)
    "Apply FUN to ARGS, skipping user confirmations."
    (cl-letf (((symbol-function 'y-or-n-p) #'always-yes)
              ((symbol-function 'yes-or-no-p) #'always-yes))
      (apply fun args))))

(provide 'lib-eval)
;;; lib-eval.el ends here
#+end_src

*** Utility packages
:PROPERTIES:
:header-args: :tangle lisp/init-utils.el :noweb yes
:ID:       502d74d1-022e-4f86-a512-00cc0f156769
:END:

Setup utility packages
#+begin_src emacs-lisp
  ;;; init-utils.el --- Utilities -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-utils>>

  (provide 'init-utils)
  ;;; init-utils.el ends here
#+end_src

** Communications
:PROPERTIES:
:header-args: :tangle lisp/init-telega.el :noweb yes
:ID:                     2b35cb3e-c354-4899-96f6-d16d8097f7ac
:END:

*** Telega setup

#+begin_src emacs-lisp
  ;;; init-telega.el --- personal configuration -*- lexical-binding: t -*-
(require 'init-elpa)
(require 'init-kbd)

(use-package telega
  :straight (telega
             :type git
             :host github
             :repo "zevlg/telega.el"
             :branch "releases"
             :files (:defaults "contrib" "etc" "server" "Makefile"))
  :defer t
  :hook ((telega-chat-mode . ui-reset-line-spacing)
         (telega-chat-mode . editor-disable-electric-pair))
  :general
  (leader-def
    "t" '(:keymap telega-prefix-map))
  :init
  (when elpa-bootstrap-p
    (require 'telega-server)
    (require 'lib-nix)
    (let ((exec-path (cons telega-directory exec-path))
          (default-directory telega--lib-directory))
      (unless (executable-find "telega-server")
        (nix-shell-command
         :message-intro "building telega-server..."
         :message-error "Failed to build telega-server"
         :deps '("pkg-config" "tdlib")
         :command (concat
                   (or (executable-find "gmake")
                       "make")
                   " "
                   "LIBS_PREFIX="
                   (expand-file-name telega-server-libs-prefix) " "
                   "INSTALL_PREFIX="
                   (expand-file-name telega-directory) " "
                   "server-reinstall"))))))
#+end_src


*** Compatibility Utilities
:PROPERTIES:
:header-args: :tangle lisp/lib-compat.el :noweb yes
:ID:       3cae4486-262c-4e62-bb92-645abbe5ddc6
:END:

#+begin_src emacs-lisp
  ;;; lib-compat.el --- Compatibility utilities  -*- lexical-binding: t -*-
    <<disclaimer>>
    ;;; Code:

  ;;;###autoload
  (defun cl--plist-remove (plist member)
    "Remove MEMBER from PLIST.
  `telega' needs this function."
    (cond
     ((null plist) nil)
     ((null member) plist)
     ((eq plist member) (cddr plist))
     (t `(,(car plist) ,(cadr plist)
          ,@(cl--plist-remove (cddr plist) member)))))

    ;;; SYSTEM-DEPENDENT SETTINGS
    ;; at home
    (eval-and-compile
      (when (memq system-type '(gnu gnu/linux darwin))
        <<linux-specific>>
        ))

    ;; at work
    (eval-and-compile
      (when (memq system-type '(ms-dos windows-nt))
        <<windows-specific>>
        ))

  (provide 'lib-compat)
  ;;; lib-compat.el ends here
#+end_src
*** Ease of editing
:PROPERTIES:
:header-args: :tangle no
:ID:                     de45708b-cfcc-4add-a59b-8cbc64b4f85e
:END:

#+begin_src emacs-lisp :noweb-ref functions
  (defun enfer/find-config ()
    "Find `config.org'."
    (interactive)
    (find-file (locate-user-emacs-file "config.org")))
#+end_src

Bind it to =C-z i= because =C-z C-c= is taken for capture.

#+begin_src emacs-lisp :noweb-ref bindings
;;(define-key acdw/leader (kbd "i") #'acdw/find-config)
#+end_src

*** Ease of reloading
:PROPERTIES:
:header-args: :tangle no
:ID:                     510ef849-87e9-4def-abb8-a28f040752a4
:END:

#+begin_src emacs-lisp :noweb-ref functions
  (defun acdw/reload ()
    "Tangle and reload Emacs configuration."
    (interactive)
    (let ((config (locate-user-emacs-file "config.org")))
      ;; tangle
      (with-current-buffer (find-file-noselect config)
        (message "Tangling config.org...")
        (let ((prog-mode-hook nil)
              (inhibit-redisplay t)
              (inhibit-message t))
          (add-to-list 'load-path (locate-user-emacs-file
                                   "straight/build/org/"))
          (require 'org)
          (org-babel-tangle)))
      (message "Tangling config.org... Done.")
      ;; load init files
      (load (locate-user-emacs-file "early-init.el"))
      (load (locate-user-emacs-file "init.el"))
      ;;(load (locate-user-emacs-file "config.el"))
))
#+end_src

#+begin_src emacs-lisp :noweb-ref bindings
  (define-key acdw/leader (kbd "C-M-r") #'acdw/reload)
#+end_src

** Libraries & Config
*** String
:PROPERTIES:
:header-args: :tangle lisp/lib-string.el :noweb yes
:ID:       c636d0e2-9f57-4e6b-bb90-12cf537f603f
:END:
#+begin_src emacs-lisp
;;; lib-string.el --- String Utilities -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(require 'init-elpa)
(require 's)

;;;###autoload
(defun string-match-1 (regexp val)
  "Get the first group from REGEXP match of the VAL.
  VAL can be either a string or a region (beg . end) of the
  buffer."
  (string-match-n 1 regexp val))

;;;###autoload
(defun string-match-n (n regexp val)
  "Get the Nth group from REGEXP match of the VAL.
  VAL can be either a string or a region (beg . end) of the
  buffer."
  (let ((s (if (stringp val)
               val
             (buffer-substring (car val) (cdr val)))))
    (string-match regexp s)
    (match-string n s)))

;;;###autoload
(defun string-join-g (strs sep)
  "Join a list of STRS using SEP."
  (pcase strs
    (`nil "")
    (`(,str) str)
    (_ (mapconcat #'identity strs sep))))

;;;###autoload
(defun string-chop-prefix-regexp (prefix s)
  "Remove PREFIX regexp if it is at the start of S."
  (s-chop-prefix (car (s-match prefix s)) s))

;;;###autoload
(defun string-chop-suffix-regexp (suffix s)
  "Remove SUFFIX regexp if it is at the end of S."
  (s-chop-suffix (car (s-match suffix s)) s))

(defvar string-http-url-regexp
  "\\(https?://.*\\)"
  "HTTP(s) URL regexp.")

(defvar string-uuid-regexp
  (concat
   "\\("
   "[a-zA-Z0-9]\\{8\\}"
   "-"
   "[a-zA-Z0-9]\\{4\\}"
   "-"
   "[a-zA-Z0-9]\\{4\\}"
   "-"
   "[a-zA-Z0-9]\\{4\\}"
   "-"
   "[a-zA-Z0-9]\\{12\\}"
   "\\)")
  "UUID regexp.")

(defun string-from (value)
  "Convert VALUE to string."
  (cond
   ((stringp value) value)
   ((numberp value) (number-to-string value))
   ((symbolp value) (symbol-name value))
   (t (user-error
       "Unsupported type of \"%s\"" value))))

(cl-defun string-table (&key data
                             pad-type
                             pad-str
                             sep
                             row-start
                             row-end)
  "Format DATA as a table.
  DATA is list of lists. Each column is aligned by padding with
  PAD-STR either on left or right depending on value of PAD-TYPE.
  Each row begins with ROW-START and ends with ROW-END. Each value
  in row is separated by SEP."
  (let* ((widths (seq-reduce
                  (lambda (r v)
                    (seq-map-indexed
                     (lambda (a i)
                       (max
                        (length (string-from a))
                        (or (nth i r)
                            0)))
                     v))
                  data
                  nil))
         (pad-fn (pcase (or pad-type 'left)
                   (`left #'s-pad-left)
                   (`right #'s-pad-right)))
         (pad-str (or pad-str " "))
         (row-start (or row-start ""))
         (row-end (or row-end ""))
         (sep (or sep " ")))
    (seq-reduce
     (lambda (r v)
       (concat
        r
        row-start
        (string-join
         (seq-map-indexed
          (lambda (a i)
            (funcall pad-fn
                     (nth i widths)
                     pad-str
                     (string-from a)))
          v)
         sep)
        row-end
        "\n"))
     data
     "")))

(provide 'lib-string)
;;; lib-string.el ends here
#+end_src
*** orgmode config
:PROPERTIES:
:header-args: :tangle lisp/config-orgmode.el :noweb yes
:ID:       7df49a2c-aad7-472a-a186-c8db756aeb44
:END:
#+begin_src emacs-lisp
;;; config-orgmode.el --- Org-mode Directory -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:
(require 'config-path)

(defconst *notes/*
  (file-name-as-directory (expand-file-name "~/org")))

(provide 'config-orgmode)
;;; config-orgmode.el ends here
#+end_src
*** function lib
:PROPERTIES:
:header-args: :tangle lisp/lib-fun.el :noweb yes
:ID:       70df19e8-852a-472f-8d78-d24d1d45dd06
:END:
#+begin_src emacs-lisp
;;; lib-fun.el --- Extra function -*- lexical-binding: t -*-
<<disclaimer>>
;; Utilities to build functions.
;;
;;; Code:

;;;###autoload
(defun fun-unquote (exp)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

;;;###autoload
(defun fun-collect-while (fn filter &rest args)
  "Repeat FN and collect it's results until `C-g` is used.
Repeat cycle stops when `C-g` is used or FILTER returns nil.
If FILTER is nil, it does not affect repeat cycle.
If FILTER returns nil, the computed value is not added to result.
ARGS are passed to FN."
  (let (result
        value
        (continue t)
        (inhibit-quit t))
    (with-local-quit
      (while continue
        (setq value (apply fn args))
        (if (and filter
                 (null (funcall filter value)))
            (setq continue nil)
          (setq result (cons value result)))))
    (setq quit-flag nil)
    (seq-reverse result)))

;;;###autoload
(defun fun-repeat-while (fn filter &rest args)
  "Repeat FN and return the first unfiltered result.
Repeat cycle stops when `C-g` is used or FILTER returns nil.
ARGS are passed to FN."
  (let (value
        (continue t)
        (inhibit-quit t))
    (with-local-quit
      (while continue
        (setq value (apply fn args))
        (when (null (funcall filter value))
          (setq continue nil))))
    (setq quit-flag nil)
    (when (null continue)
      value)))

;;;###autoload
(defun fun-noop (&rest _)
  "Do nothing.
Useful for temporarily disabling a function.")

(provide 'lib-fun)
;;; lib-fun.el ends here
#+end_src
*** VCS
:PROPERTIES:
:header-args: :tangle lisp/lib-vcs.el :noweb yes
:ID:       05d0ed58-40b0-49a0-829b-7436db557594
:END:
#+begin_src emacs-lisp
;;; lib-vcs.el --- Libaray -*- lexical-binding: t -*-
<<disclaimer>>
;;; Code:

(require 'init-kbd)



(defvar vcs-url-github-issue-regexp
  (format "\\(%s/\\(%s\\)/\\(%s\\)/\\(%s\\)/\\(%s\\)\\).*"
          "https://github\\.com"
          "[-\\.[:alnum:]]+"
          "[-\\.[:alnum:]]+"
          "[[:alpha:]]+"
          "[[:alnum:]]+")
  "GitHub issue/pull URL regexp.
- 1st group is whole URL.
- 2nd group is owner.
- 3rd group is repository name.
- 4th group is type of the object - issue/pull/miliestone/commit.
- 5th group is the number of the object.")

(defvar vcs-url-github-project-regexp
  (format "\\(%s/\\(%s\\)/\\(%s\\)/?\\)"
          "https://github\\.com"
          "[-\\.[:alnum:]]+"
          "[-\\.[:alnum:]]+")
  "GitHub project URL regexp.
- 1st group is whole URL.
- 2nd group is owner.
- 3rd group is repository name.")

(defvar vcs-url-known-github-users '("frap"
                                     "agasson")
  "List of 'known' GitHub users.")



;;;###autoload
(defun vcs-url-format-github-issue (owner repo type number)
  "Format GitHub issue.
Depending on the TYPE format can be one of the following:
- OWNER/REPO#NUMBER if TYPE is not milestone;
- OWNER/REPOmNUMBER otherwise.
In case OWNER is a member of `vcs-url-known-github-users', then OWNER
part of format is omitted."
  (concat
   (if (seq-contains-p vcs-url-known-github-users owner)
       repo
     (concat owner "/" repo))
   (if (string-equal type "milestone")
       "m"
     "#")
   (if (string-equal type "commit")
       (substring number 0 (min 7 (length number)))
     number)))

;;;###autoload
(defun vcs-url-format-github-project (owner repo)
  "Format GitHub REPO.
In case OWNER is a member of `vcs-url-known-github-users', then OWNER
part of format is omitted."
  (concat
   (if (seq-contains-p vcs-url-known-github-users owner)
       repo
     (concat owner "/" repo))))

(provide 'lib-vcs)
  ;;; lib-vcs.el ends here
#+end_src

*** File Templates aka YASnippett
:PROPERTIES:
:header-args: :tangle lisp/init-file-templates.el :noweb yes
:ID:       68ae83b4-14d3-4eb7-9c99-fd05cb6d9053
:END:
#+begin_src emacs-lisp
;;; init-file-templates.el --- File templates support -*- lexical-binding: t; -*-
<<disclaimer>>
;; Commentary:
;;
;; This module configures yasnippet.
;;
;;; Code:

(require 'init-project)

<<templates>>

(provide 'init-file-templates)
;;; init-file-templates.el ends here
#+end_src

*** Dash-functional fixup
:PROPERTIES:
:header-args: :tangle lisp/dash-functional.el :noweb yes
:ID:       5c50f26c-4d6f-4030-a94f-c2c5c0729585
:END:
#+begin_src emacs-lisp
  ;;; dash-functional.el --- Mocking dash-functional -*- lexical-binding: t; -*-
  <<disclaimer>>
  ;;; Commentary:
;;
;; Unfortunately, dash-functional is obsolete. And instead of talking
;; to popular libraries, they simply put a warning inside this
;; package, meaning that people treating warnings as errors have no
;; way to load this module (even transitively).
;;
;; Thanks, folks! I really appreciate it.
;;
;; So this module is a fake to avoid byte compilation error.
;;
;;; Code:

(require 'dash)

(provide 'dash-functional)
;;; dash-functional.el ends here
#+end_src

** License
:PROPERTIES:
:header-args: :tangle LICENSE
:ID:       544ee924-beef-403c-b654-6fc255528de9
:END:

Copyright © 2021 Gas <gas@somewhere.red>

This work is free.  You can redistribute it and/or modify it under the
terms of the Do What the Fuck You Want To Public License, Version 2,
as published by Gas.  See the =LICENSE= file, tangled from the
following source block, for details.

#+begin_src text
  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE

  Version 2, December 2004

  Copyright (C) 2001-2021 Gas <gas@somewhere.red>

  Everyone is permitted to copy and distribute verbatim or modified copies of
  this license document, and changing it is allowed as long as the name is changed.

  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE

  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. You just DO WHAT THE FUCK YOU WANT TO.
#+end_src


* No tangle

**** Vulpea Setup
#+begin_src emacs-lisp :tangle no 
;;; lib-vulpea.el --- Vulpea utilities -*- lexical-binding: t; -*-
<<disclaimer>>
(require 'init-elpa)

(require 'config-orgmode)
(require 'lib-directory)
(require 'lib-litnotes)

(require 'vulpea)
(require 'org-roam)
(require 'org-roam-db)
(require 'org-roam-dailies)

(defun vulpea-buffer-p ()
  "Return non-nil if the currently visited buffer is a note."
  (and buffer-file-name
       (eq major-mode 'org-mode)
       (string-suffix-p "org" buffer-file-name)
       (string-prefix-p
        (expand-file-name (file-name-as-directory vulpea-directory))
        (file-name-directory buffer-file-name))))



(defun vulpea-project-p ()
  "Return non-nil if current buffer has any todo entry.
TODO entries marked as done are ignored, meaning the this
function returns nil if current buffer contains only completed
tasks. The only exception is headings tagged as REFILE."
  (org-element-map
      (org-element-parse-buffer 'headline)
      'headline
    (lambda (h)
      (or (eq 'todo (org-element-property :todo-type h))
          (seq-contains-p (org-element-property :tags h)
                          "REFILE")))
    nil 'first-match))

;;;###autoload
(defun vulpea-project-files ()
  "Return a list of note files containing 'projet' tag." ;
  (seq-uniq
   (seq-map
    #'car
    (org-roam-db-query
     [:select [nodes:file]
      :from tags
      :left-join nodes
      :on (= tags:node-id nodes:id)
      :where (like tag (quote "%\"projet\"%"))]))))



;;;###autoload
(defun vulpea-insert-handle (note)
  "Hook to be called on NOTE after `vulpea-insert'."
  (when-let* ((title (vulpea-note-title note))
              (tags (vulpea-note-tags note)))
    (when (seq-contains-p tags "people")
      (save-excursion
        (ignore-errors
          (org-back-to-heading)
          (when (eq 'todo (org-element-property
                           :todo-type
                           (org-element-at-point)))
            (org-set-tags
             (seq-uniq
              (cons
               (vulpea--title-to-tag title)
               (org-get-tags nil t))))))))))



;;;###autoload
(defun vulpea-tags-add ()
  "Add a tag to current note."
  (interactive)
  (org-with-point-at 1
    (when (call-interactively #'org-roam-tag-add)
      (vulpea-ensure-filetag))))

;;;###autoload
(defun vulpea-tags-delete ()
  "Delete a tag from current note."
  (interactive)
  (call-interactively #'org-roam-tag-remove))

;;;###autoload
(defun vulpea-ensure-filetag ()
  "Add missing FILETAGS to the current note."
  (let* ((file (buffer-file-name))
         (path-tags
          (when file
            (seq-filter
             (lambda (x) (not (string-empty-p x)))
             (split-string
              (string-remove-prefix
               vulpea-directory
               (file-name-directory file))
              "/"))))
         (original-tags (vulpea-buffer-tags-get))
         (tags (append original-tags path-tags)))

    ;; process people
    (when (seq-contains-p tags "people")
      (let ((tag (vulpea--title-as-tag)))
        (unless (seq-contains-p tags tag)
          (setq tags (cons tag tags)))))

    ;; process litnotes
    (setq tags (litnotes-ensure-filetags tags))

    ;; process projects
    (if (vulpea-project-p)
        (setq tags (cons "projet" tags))
      (setq tags (remove "projet" tags)))

    (setq tags (seq-uniq tags))

    ;; update tags if changed
    (when (or (seq-difference tags original-tags)
              (seq-difference original-tags tags))
      (apply #'vulpea-buffer-tags-set (seq-uniq tags)))))



;;;###autoload
(defun vulpea-alias-add ()
  "Add an alias to current note."
  (interactive)
  (call-interactively #'org-roam-alias-add))

;;;###autoload
(defun vulpea-alias-delete ()
  "Delete an alias from current note."
  (interactive)
  (call-interactively #'org-roam-alias-remove))

;;;###autoload
(defun vulpea-alias-extract ()
  "Extract an alias from current note as a separate note.
Make all the links to this alias point to newly created note."
  (interactive)
  (if-let* ((node (org-roam-node-at-point 'assert))
            (aliases (org-roam-node-aliases node)))
      (let* ((alias (completing-read
                     "Alias: " aliases nil 'require-match))
             (backlinks (seq-map
                         #'org-roam-backlink-source-node
                         (org-roam-backlinks-get node)))
             (id-old (org-roam-node-id node)))
        (org-roam-alias-remove alias)
        (org-roam-db-update-file (org-roam-node-file node))
        (let* ((note (vulpea-create
                      alias
                      "%<%Y%m%d%H%M%S>-${slug}.org"
                      :immediate-finish t
                      :unnarrowed t)))
          (seq-each
           (lambda (node)
             (vulpea-utils-with-file (org-roam-node-file node)
               (goto-char (point-min))
               (let ((link-old
                      (org-link-make-string
                       (concat "id:" id-old)
                       alias))
                     (link-new
                      (vulpea-utils-link-make-string note)))
                 (while (search-forward link-old nil 'noerror)
                   (replace-match link-new))))
             (org-roam-db-update-file (org-roam-node-file node)))
           backlinks)))
    (user-error "Pas d'alias à extraire")))



;;;###autoload
(defun vulpea-setup-buffer (&optional _)
  "Setup current buffer for notes viewing and editing."
  (when (and (not (active-minibuffer-window))
             (vulpea-buffer-p))
    (org-with-point-at 1
      (org-hide-drawer-toggle 'off))
    (setq-local tab-width 1)
    (vulpea-ensure-filetag)))

;;;###autoload
(defun vulpea-pre-save-hook ()
  "Do all the dirty stuff when file is being saved."
  (when (and (not (active-minibuffer-window))
             (vulpea-buffer-p))
    (vulpea-ensure-filetag)))



;;;###autoload
(defun vulpea-dailies-today ()
  "Find a daily note for today."
  (interactive)
  (org-roam-dailies-goto-today))

;;;###autoload
(defun vulpea-dailies-date ()
  "Find a daily note for date specified using calendar."
  (interactive)
  (org-roam-dailies-goto-date))

;;;###autoload
(defun vulpea-dailies-prev ()
  "Find a daily note that comes before current."
  (interactive)
  (org-roam-dailies-goto-previous-note))

;;;###autoload
(defun vulpea-dailies-next ()
  "Find a daily note that comes after current."
  (interactive)
  (org-roam-dailies-goto-next-note))



;;;###autoload
(defun vulpea-db-build ()
  "Update notes database."
  (when (file-directory-p vulpea-directory)
    (org-roam-db-sync)
    (org-roam-update-org-id-locations)))



;;;###autoload
(defun vulpea-subdir-select ()
  "Select notes subdirectory."
  (interactive)
  (let ((dirs (cons
               "."
               (seq-map
                (lambda (p)
                  (string-remove-prefix vulpea-directory p))
                (directory-subdirs vulpea-directory 'recursive)))))
    (completing-read "Subdir: " dirs nil t)))



(defun vulpea--title-as-tag ()
  "Return title of the current note as tag."
  (vulpea--title-to-tag (vulpea-buffer-prop-get "title")))

(defun vulpea--title-to-tag (title)
  "Convert TITLE to tag."
  (concat "@" (s-replace " " "" title)))



;;;###autoload
;; org-check-agenda-file
(defun vulpea-check-agenda-file (&rest _)
  "A noop advice for `org-check-agenda-file'.
Since this function is called from multiple places, it is very
irritating to answer this question every time new note is created.
Also, it doesn't matter if the file in question is present in the
list of `org-agenda-files' or not, since it is built dynamically
via `vulpea-agenda-files-update'.")



;;;###autoload
(defun vulpea-activate-link (start end path _brackets)
  "Activate a link between START and END for PATH."
  (let ((visible-start (or (match-beginning 3)
                           (match-beginning 2)))
        (visible-end (or (match-end 3) (match-end 2))))
    (when-let* ((uuid-p (string-match-p string-uuid-regexp path))
                (note (vulpea-db-get-by-id path))
                (tags (vulpea-note-tags note))
                (icon (cond
                       ((seq-contains-p tags litnotes-tag)
                        (litnotes-content-display
                         (litnotes-entry-content
                          (litnotes-entry note))
                         :height 0.8 :v-adjust 0.04))
                       ((seq-contains-p tags "people")
                        (concat
                         (all-the-icons-material
                          "person" :height 0.8 :v-adjust 0.04)
                         "\t"))
                       ((seq-contains-p tags "grape")
                        (concat "🍇" "\t"))
                       ((seq-contains-p tags "cellar")
                        (concat "🍷" "\t"))
                       ((seq-contains-p tags "aroma")
                        (concat
                         (all-the-icons-material
                          "local_florist" :height 0.8 :v-adjust 0.04)
                         "\t"))))
                (desc (buffer-substring visible-start visible-end))
                (desc (concat icon desc))
                (desc (s-truncate (- end start) desc))
                (l (length desc))
                (hidden `(invisible
                          ,(or (org-link-get-parameter "id" :display)
                               'org-link))))
      (remove-text-properties start visible-start hidden)
      (remove-text-properties visible-end end hidden)
      (add-text-properties (+ start l) end hidden)
      (put-text-property start end 'display desc))))



(provide 'lib-vulpea)
;;; lib-vulpea.el ends here
#+end_src
**** Directory Utilities /tangle no/
#+begin_src emacs-lisp :tangle no
;;; lib-directory.el --- Directory utilities -*- lexical-binding: t; -*-
<<disclaimer>>
;;; Commentary:
;;
;; Various utilities for files and directories.
;;
;;; Code:

(defun directory-subdirs (directory &optional rec)
  "Return subdirs or files of DIRECTORY.
If REC is non-nil then do recursive search."
  (let ((res
         (seq-map
          #'file-name-as-directory
          (seq-remove
           (lambda (file)
             (or (string-match "\\`\\."
                               (file-name-nondirectory file))
                 (string-match "\\`#.*#\\'"
                               (file-name-nondirectory file))
                 (string-match "~\\'"
                               (file-name-nondirectory file))
                 (not (file-directory-p file))))
           (directory-files directory t)))))
    (if rec
        (apply
         #'append
         (seq-map (lambda (p) (cons p (directory-subdirs p)))
                  res))
      res)))

(provide 'lib-directory)
;;; lib-directory.el ends here
#+end_src
**** Literature Notes /tangle no/
:PROPERTIES:
:header-args: :tangle no  :noweb yes
:ID:                     7b61e449-59c1-4bf8-a3b4-464f9d9b4306
:END:
#+begin_src emacs-lisp
;;; lib-litnotes.el --- Utilities for working with litnotes -*- lexical-binding: t; -*-
<<disclaimer>>
;;; Commentary:
;;
;; This module provides various utilities for viewing and managing
;; litnotes.
;;
;;; Code:

(require 'vulpea)
(require 'lister)
(require 'lister-highlight)
(require 'all-the-icons)



(defconst litnotes-tag "litnotes"
  "Tag of all them litnotes.")



(defface litnotes-group-title-face
  '((t (:inherit org-roam-header-line)))
  "Face for displaying group title."
  :group 'litnotes)

(defface litnotes-group-counter-face
  '((t (:inherit font-lock-comment-face)))
  "Face for displaying group counter."
  :group 'litnotes)

(defface litnotes-entry-title-face
  '((t (:inherit org-document-title)))
  "Face for displaying entry title."
  :group 'litnotes)

(defface litnotes-entry-authors-face
  '((t (:inherit font-lock-comment-face)))
  "Face for displaying entry authors."
  :group 'litnotes)



(defvar litnotes-status-values '("ongoing" "new" "done" "dropped")
  "List with all valid values of status.")

(defun litnotes-status-compare (a b)
  "Compare status A with status B."
  (< (seq-position litnotes-status-values a)
     (seq-position litnotes-status-values b)))

(defun litnotes-status-display (status &rest icon-args)
  "Display STATUS.
ICON-ARGS are properties that are passed to `all-the-icons'
functions. You may use it to pass :height and :v-adjust."
  (let ((icon-fn (pcase status
                   (`"ongoing" #'all-the-icons-faicon)
                   (`"new" #'all-the-icons-faicon)
                   (`"done" #'all-the-icons-faicon)
                   (`"dropped" #'all-the-icons-faicon)))
        (icon-name (pcase status
                     (`"ongoing" "spinner")
                     (`"new" "inbox")
                     (`"done" "check")
                     (`"dropped" "times"))))
    (if (featurep 'all-the-icons)
        (concat
         (apply icon-fn icon-name icon-args)
         ;; this way we align everything horizontally
         "\t"
         status)
      "")))

(defconst litnotes-status-tag-prefix "status/"
  "Prefix of the status tag.")

(defun litnotes-status-to-tag (status)
  "Return a tag representing STATUS."
  (concat litnotes-status-tag-prefix status))

(defun litnotes-status-from-tag (tag)
  "Return a status representing as TAG."
  (string-remove-prefix litnotes-status-tag-prefix tag))

(defun litnotes-status-tag-p (tag)
  "Return non-nil when TAG represents a status."
  (string-prefix-p litnotes-status-tag-prefix tag))

(defun litnotes-status-read (&optional old-status)
  "Read a status excluding OLD-STATUS."
  (completing-read
   "Status: "
   (-remove-item old-status litnotes-status-values)))



(defvar litnotes-content-types '("book"
                                 "article"
                                 "video"
                                 "course"
                                 "game")
  "List with all valid content types.")

(defun litnotes-content-compare (a b)
  "Compare content A with content B."
  (< (seq-position litnotes-content-types a)
     (seq-position litnotes-content-types b)))

(defun litnotes-content-display (content &rest icon-args)
  "Display CONTENT.
ICON-ARGS are properties that are passed to `all-the-icons'
functions. You may use it to pass :height and :v-adjust."
  (let ((icon-fn (pcase content
                   (`"book" #'all-the-icons-material)
                   (`"article" #'all-the-icons-material)
                   (`"video" #'all-the-icons-material)
                   (`"game" #'all-the-icons-material)
                   (`"course" #'all-the-icons-material)))
        (icon-name (pcase content
                     (`"book" "local_library")
                     (`"article" "insert_drive_file")
                     (`"video" "videocam")
                     (`"game" "videogame_asset")
                     (`"course" "school"))))
    (if (featurep 'all-the-icons)
        (concat
         (apply icon-fn icon-name icon-args)
         ;; this way we align everything horizontally
         "\t")
      "")))

(defconst litnotes-content-tag-prefix "content/"
  "Prefix of the content tag.")

(defun litnotes-content-to-tag (content)
  "Return a tag representing CONTENT."
  (concat litnotes-content-tag-prefix content))

(defun litnotes-content-from-tag (tag)
  "Return a content representing as TAG."
  (string-remove-prefix litnotes-content-tag-prefix tag))

(defun litnotes-content-tag-p (tag)
  "Return non-nil when TAG represents a content."
  (string-prefix-p litnotes-content-tag-prefix tag))



(cl-defstruct litnotes-entry
  note
  title
  status
  content
  authors)

(defun litnotes-entry (note)
  "Create a `litnotes-entry' from NOTE."
  (make-litnotes-entry
   :note note
   :title (vulpea-note-title note)
   :status (litnotes-status-from-tag
            (seq-find
             #'litnotes-status-tag-p
             (vulpea-note-tags note)))
   :content (string-remove-prefix
             "content/"
             (seq-find
              (lambda (x)
                (string-prefix-p "content/" x))
              (vulpea-note-tags note)))
   :authors (vulpea-note-meta-get-list note "authors" 'note)))

(defun litnotes-entry-compare (a b)
  "Compare entries A and B by title."
  (string< (litnotes-entry-title a)
           (litnotes-entry-title b)))

(defun litnotes-entry-visit (entry &optional other-window)
  "Visit a litnote ENTRY possible in OTHER-WINDOW."
  (org-roam-node-visit
   (org-roam-node-from-id
    (vulpea-note-id (litnotes-entry-note entry)))
   other-window))



(defun litnotes-entries ()
  "Fetch a list of `litnotes-entry' entries."
  (seq-map
   #'litnotes-entry
   (seq-remove
    #'vulpea-note-primary-title
    (vulpea-db-query
     (lambda (x)
       (seq-contains-p (vulpea-note-tags x)
                       litnotes-tag))))))



(defvar-local litnotes-buffer-data nil
  "Associative list of all litnotes grouped by status.")

;;;###autoload
(define-derived-mode litnotes-mode
  lister-mode "litnotes"
  "Major mode for browsing litnotes."
  (lister-setup (current-buffer) #'litnotes-buffer-mapper))

(defconst litnotes-mode-map
  (let ((map (make-sparse-keymap)))
    ;; inherit standard key bindings:
    (set-keymap-parent map lister-mode-map)
    (define-key map "\t"          #'litnotes-buffer-expand)
    (define-key map (kbd "<RET>") #'litnotes-buffer-visit)
    (define-key map (kbd "g")     #'litnotes-buffer-refresh)
    (define-key map (kbd "s")     #'litnotes-buffer-set-status)
    map)
  "Key map for `litnotes-mode'.")

;;;###autoload
(defun litnotes ()
  "Display a list of litnotes."
  (interactive)
  (let* ((name "*litnotes*")
         (buffer (buffer-generate name 'unique)))
    (with-current-buffer buffer
      (litnotes-mode)
      (setq litnotes-buffer-data (litnotes-buffer-data))
      (setq-local tab-width 4)
      (lister-highlight-mode 1)
      (lister-insert-sequence
       buffer (point) litnotes-status-values)
      (lister-goto buffer :first)
      (litnotes-buffer-expand-sublist buffer (point)))
    (switch-to-buffer buffer)))

(defun litnotes-buffer-data ()
  "Get data for litnotes buffer."
  (seq-sort-by
   #'car
   #'litnotes-status-compare
   (seq-group-by #'litnotes-entry-status
                 (seq-sort
                  #'litnotes-entry-compare
                  (litnotes-entries)))))

(defun litnotes-buffer-mapper (data)
  "DATA mapper for `litnotes-mode'."
  (if (stringp data)
      (concat
       (propertize
        (litnotes-status-display data)
        'face 'litnotes-group-title-face)
       " "
       (propertize
        (concat "("
                (number-to-string
                 (length (cdr (assoc data litnotes-buffer-data))))
                ")")
        'face 'litnotes-group-counter-face))
    (concat
     (litnotes-content-display
      (litnotes-entry-content data))
     (propertize
      (litnotes-entry-title data)
      'face 'litnotes-entry-title-face)
     (when (litnotes-entry-authors data)
       (concat
        " by "
        (string-join
         (seq-map
          (lambda (note)
            (propertize
             (vulpea-note-title note)
             'face 'litnotes-entry-authors-face))
          (litnotes-entry-authors data))
         ", "))))))

(defun litnotes-buffer-groups-refresh (buffer)
  "Refresh groups in litnotes BUFFER."
  (lister-walk-all
   buffer
   (lambda (data)
     (lister-replace buffer (point) data))
   #'stringp))

(defun litnotes-buffer-refresh ()
  "Refresh litnotes buffer."
  (interactive)
  (let ((pos (point)))
    (litnotes)
    (goto-char pos)))

(defun litnotes-buffer-expand (buffer pos)
  "Perform expansion on item at POS in litnotes BUFFER."
  (interactive (list (current-buffer) (point)))
  (let ((item (lister-get-data buffer pos)))
    (cond
     ((litnotes-entry-p item)
      (litnotes-entry-visit item 'other-window))

     ((ignore-errors (lister-sublist-below-p buffer pos))
      (lister-remove-sublist-below buffer pos))

     (t (litnotes-buffer-expand-sublist buffer pos)))))

(defun litnotes-buffer-expand-sublist (buffer pos)
  "Expand litnotes in the current list.
BUFFER must be a valid lister buffer populated with litnotes
items. POS can be an integer or the symbol `:point'."
  (interactive (list (current-buffer) (point)))
  (let* ((position
          (pcase pos
            ((and (pred integerp) pos) pos)
            (:point (with-current-buffer buffer (point)))
            (_ (error "Valeur invalide pour POS: %s" pos))))
         (item (lister-get-data buffer position))
         (sublist (cdr (assoc item litnotes-buffer-data))))
    (if sublist
        (with-temp-message "Insertion des résultats d'expansion..."
          (lister-insert-sublist-below buffer position sublist))
      (user-error "Aucune extension trouvée"))))

(defun litnotes-buffer-visit (buffer pos)
  "Visit a litnote at POS from BUFFER."
  (interactive (list (current-buffer) (point)))
  (let* ((item (lister-get-data buffer pos)))
    (if (litnotes-entry-p item)
        (litnotes-entry-visit item)
      (user-error "Not a litnote"))))

(defun litnotes-buffer-set-status ()
  "Set status of a litnote at point."
  (interactive)
  (let* ((buffer (current-buffer))
         (pos (point))
         (item (lister-get-data buffer pos)))
    (if (litnotes-entry-p item)
        (let* ((old-status (litnotes-entry-status item))
               (status (litnotes-status-read old-status))
               (note (litnotes-entry-note item))
               (file (vulpea-note-path note)))
          (vulpea-utils-with-file file
            (litnotes-status-set status))
          (setf (litnotes-entry-status item) status)
          (setq litnotes-buffer-data
                (litnotes-buffer-data-change-group
                 item old-status status))
          (litnotes-buffer-change-group buffer pos item status)
          (litnotes-buffer-groups-refresh buffer))
      (user-error "Not a litnote"))))

(defun litnotes-buffer-change-group (buffer pos item new-group)
  "Move ITEM at POS to NEW-GROUP in litnotes BUFFER."
  ;; basically, remove whatever is in point
  (lister-remove buffer pos)

  ;; add to new group if it's expanded
  (lister-walk-all
   buffer
   (lambda (_)
     (let ((pos (point)))
       (when (ignore-errors
               (lister-sublist-below-p buffer pos))
         (let* ((next-item (lister-end-of-lines buffer pos))
                (next-level (lister-get-level-at buffer next-item)))
           (lister-insert
            buffer
            next-item
            item
            next-level)))))
   (lambda (data)
     (and (stringp data)
          (string-equal new-group data)))))

(defun litnotes-buffer-data-change-group (item old-group new-group)
  "Move ITEM from OLD-GROUP to NEW-GROUP in cached data."
  (seq-map
   (lambda (kvs)
     (cond
      ((string-equal old-group (car kvs))
       (cons (car kvs)
             (seq-remove
              (lambda (x)
                (string-equal
                 (vulpea-note-id (litnotes-entry-note x))
                 (vulpea-note-id (litnotes-entry-note item))))
              (cdr kvs))))
      ((string-equal new-group (car kvs))
       (cons (car kvs)
             (cons item (cdr kvs))))
      (t kvs)))
   litnotes-buffer-data))

;; TODO: add filtering
;; TODO: add other groupings



;;;###autoload
(defun litnotes-ensure-filetags (tags)
  "Ensure that TAGS contain the right set of tags."
  (when (seq-contains-p tags litnotes-tag)
    (unless (seq-find #'litnotes-status-tag-p tags)
      (setq tags (cons (litnotes-status-to-tag "new") tags)))
    (unless (seq-find #'litnotes-content-tag-p tags)
      (setq tags (cons
                  (litnotes-content-to-tag
                   (completing-read
                    "Content:"
                    litnotes-content-types))
                  tags))))
  tags)



;;;###autoload
(defun litnotes-status-set (&optional status)
  "Change STATUS tag of the current litnote."
  (interactive)
  (when-let*
      ((file (buffer-file-name (buffer-base-buffer)))
       (id (vulpea-db-get-id-by-file file))
       (tags (vulpea-buffer-tags-get))
       (old-status (litnotes-status-from-tag
                    (seq-find #'litnotes-status-tag-p tags)))
       (status (or status (litnotes-status-read old-status)))
       (new-tags (litnotes-tags-set-status tags status)))
    (vulpea-buffer-prop-set-list "filetags" new-tags)
    (org-time-stamp-format (current-time) 'interactive)
    (unless (vulpea-meta-get id "added")
      (vulpea-meta-set
       id "added"
       (litnotes-format-time (current-time) t 'inactive)
       'append))
    (pcase status
      (`"ongoing"
       (vulpea-meta-remove id "completed")
       (vulpea-meta-remove id "dropped")
       (vulpea-meta-set
        id "started"
        (litnotes-format-time (current-time) 'with-hm 'inactive)
        'append))
      (`"done"
       (vulpea-meta-remove id "dropped")
       (vulpea-meta-set
        id "completed"
        (litnotes-format-time (current-time) 'with-hm 'inactive)
        'append))
      (`"dropped"
       (vulpea-meta-remove id "completed")
       (vulpea-meta-set
        id "dropped"
        (litnotes-format-time (current-time) 'with-hm 'inactive)
        'append)))
    (org-roam-db-update-file file)
    (save-buffer)))



(defun litnotes-tags-set-status (tags status)
  "Add STATUS to TAGS and return result.
STATUS is converted into proper tag, an any other status tag is
removed from TAGS."
  (cons
   (litnotes-status-to-tag status)
   (seq-remove
    #'litnotes-status-tag-p
    tags)))



(defun litnotes-format-time (time &optional with-hm inactive extra)
  "Format a date stamp for the date given by the internal TIME.
See `format-time-string' for the format of TIME.
WITH-HM means use the stamp format that includes the time of the
day.
INACTIVE means use square brackets instead of angular ones, so
that the stamp will not contribute to the agenda.
EXTRA is unknown thing."
  (let ((fmt (funcall (if with-hm 'cdr 'car)
                      org-time-stamp-formats)))
    (when inactive
      (setq fmt (concat "[" (substring fmt 1 -1) "]")))
    (when (listp extra)
      (setq extra (car extra))
      (if (and (stringp extra)
               (string-match "\\([0-9]+\\):\\([0-9]+\\)" extra))
          (setq extra (format
                       "-%02d:%02d"
                       (string-to-number (match-string 1 extra))
                       (string-to-number (match-string 2 extra))))
        (setq extra nil)))
    (when extra
      (setq fmt (concat (substring fmt 0 -1)
                        extra
                        (substring fmt -1))))
    (concat (format-time-string fmt time))))



(provide 'lib-litnotes)
;;; lib-litnotes.el ends here
#+end_src
**** Vulpea Refile /tangle no/
:PROPERTIES:
:header-args: :tangle no :noweb yes
:END:
#+begin_src emacs-lisp
;;; lib-vulpea-refile.el --- Note refiling utilities -*- lexical-binding: t; -*-
<<disclaimer>>
;;; Commentary:
;;
;; This module provides utilities for refiling vulpea notes.
;;
;;; Code:

(require 'org)

(defvar vulpea-refile-ignored-tags '("JOURNAL" "REFILE")
  "List of tags to ignore during refile.")

;;;###autoload
(defun vulpea-refile-verify-target ()
  "Exclude todo keywords with a done state from refile targets."
  (let ((tags-at (org-get-tags)))
    (and
     ;; doesn't have done keyword
     (not (member (nth 2 (org-heading-components)) org-done-keywords))

     ;; doesn't have blacklisted tag
     (or (null tags-at)
         (cl-member-if-not
          (lambda (x)
            (member (if (listp x) (car x) x)
                    vulpea-refile-ignored-tags))
          tags-at)))))

(provide 'lib-vulpea-refile)
;;; lib-vulpea-refile.el ends here
#+end_src
**** Vulpea Capture /tangel no/
:PROPERTIES:
:header-args: :tangle no :noweb yes
:END:
#+begin_src emacs-lisp
;;; lib-vulpea-capture.el --- Capturing tasks and notes -*- lexical-binding: t; -*-
<<disclaimer>>
;;; Commentary:
;;
;; Various utilities for capturing tasks and notes.
;;
;;; Code:

(require 'init-env)
(require 'config-orgmode)
(require 'lib-fun)

;; external dependencies
(require 'vulpea)
(require 'org)
(require 'org-capture)
(require 'org-roam)
(require 'org-cliplink)

(defvar vulpea-capture-inbox-file
  "inbox.org"   ;; (format "inbox-%s.org" *hostname*)
  "The path to the inbox file.
It is relative to `vulpea-directory', unless it is absolute.")

;;;###autoload
(defun vulpea-capture-setup ()
  "Wire all bits for capturing."
  (dolist (var '(vulpea-capture-inbox-file))
    (set var (expand-file-name (symbol-value var) vulpea-directory)))
  (unless org-default-notes-file
    (setq org-default-notes-file vulpea-capture-inbox-file))
  (setq
   org-capture-templates
   '(("t" "Tâches" plain (file+headline vulpea-capture-inbox-file "Boîte de Réception")
      "** TODO %?\n%U\n" :clock-in t :clock-resume t)

     ("m" "Reunion" entry
      (function vulpea-capture-meeting-target)
      (function vulpea-capture-meeting-template)
      :clock-in t
      :clock-resume t))
   org-roam-capture-templates
   '(("d" "default" plain "%?"
      :if-new (file+head
               "%(vulpea-subdir-select)/%<%Y%m%d%H%M%S>-${slug}.org"
               "#+title: ${title}\n\n")
      :unnarrowed t))
   org-roam-dailies-capture-templates
   `(("d" "default" entry
      "* %<%H:%M>\n\n%?"
      :if-new (file+head
               ,(expand-file-name "%<%Y-%m-%d>.org"
                                  org-roam-dailies-directory)
               ,(string-join '("#+title: %<%A, %d %B %Y>"
                               "#+filetags: journal"
                               "\n")
                             "\n"))))))

;;;###autoload
(defun vulpea-capture-task ()
  "Capture a task."
  (interactive)
  (org-capture nil "t"))

(defun vulpea-capture-meeting ()
  "Capture a meeting."
  (interactive)
  (org-capture nil "m"))

(defun vulpea-capture-projet ()
  "Capture a projet."
  (interactive)
  (org-capture nil "p"))

(defun vulpea-capture-meeting-target ()
  "Return a target for a meeting capture."
  (let ((person (org-capture-get :meeting-person)))
    ;; unfortunately, I could not find a way to reuse
    ;; `org-capture-set-target-location'
    (if (vulpea-note-id person)
        (let ((path (vulpea-note-path person))
              (headline "Reuniones"))
          (set-buffer (org-capture-target-buffer path))
          ;; Org expects the target file to be in Org mode, otherwise
          ;; it throws an error. However, the default notes files
          ;; should work out of the box. In this case, we switch it to
          ;; Org mode.
          (unless (derived-mode-p 'org-mode)
            (org-display-warning
             (format
              "Capture requirement: switching buffer %S to Org mode"
              (current-buffer)))
            (org-mode))
          (org-capture-put-target-region-and-position)
          (widen)
          (goto-char (point-min))
          (if (re-search-forward
               (format org-complex-heading-regexp-format
                       (regexp-quote headline))
               nil t)
              (beginning-of-line)
            (goto-char (point-max))
            (unless (bolp) (insert "\n"))
            (insert "* " headline "\n")
            (beginning-of-line 0)))
      (let ((path vulpea-capture-inbox-file))
        (set-buffer (org-capture-target-buffer path))
        (org-capture-put-target-region-and-position)
        (widen)))))

(defun vulpea-capture-meeting-template ()
  "Return a template for a meeting capture."
  (let ((person (vulpea-select-from
                 "Person"
                 (vulpea-db-query-by-tags-every '("people")))))
    (org-capture-put :meeting-person person)
    (if (vulpea-note-id person)
        "* RÉUNION [%<%Y-%m-%d %a>] :REFILE:RÉUNION:\n%U\n\n%?"
      (concat "* RÉUNION avec "
              (vulpea-note-title person)
              " on [%<%Y-%m-%d %a>] :RÉUNION:\n%U\n\n%?"))))

;;;###autoload
(defun vulpea-capture-article ()
  "Capture an article using `vulpea-capture-article-template'.
User is asked to provide an URL, title and authors of the article
being captured.
Title is inferred from URL, but user may edit it.
Stored under roam-directory/litnotes
Authors can be created on the fly. See
`vulpea-capture-person-template' for more information."
  (interactive)
  (when-let*
      ((url (read-string "URL: "))
       (title (org-cliplink-retrieve-title-synchronously url))
       (title (read-string "Title: " title))
       (people (fun-collect-while
                (lambda ()
                  (let ((person
                         (vulpea-select-from
                          "Person"
                          (vulpea-db-query-by-tags-every '("people")))))
                    (if (vulpea-note-id person)
                        person
                      (vulpea-create
                       (vulpea-note-title person)
                       "people/%<%Y%m%d%H%M%S>-${slug}.org"
                       :immediate-finish t))))
                nil))
       (note (vulpea-crea
              title
              "litnotes/%<%Y%m%d%H%M%S>-${slug}.org"
              :tags '("litnotes" "content/article")
              :properties (list (cons "ROAM_REFS" url))
              :immediate-finish t)))
    (vulpea-meta-set note "authors" people t)
    (find-file (vulpea-note-path note))
    (litnotes-status-set "new")
    (save-buffer)))

(defun vulpea-capture-journal ()
  "Capture a journal entry.
By default it uses current date to find a daily. With
\\[universal-argument] user may select the date."
  (interactive)
  (cond
   ((equal current-prefix-arg '(4))     ; select date
    (org-roam-dailies-capture-date))
   (t
    (org-roam-dailies-capture-today))))

(provide 'lib-vulpea-capture)
;;; lib-vulpea-capture.el ends here
#+end_src
**** Vulpea Agenda
:PROPERTIES:
:header-args: :tangle no :noweb yes
:END:
#+begin_src emacs-lisp
   ;;; lib-vulpea-agenda.el --- Utilities for building agenda -*- lexical-binding: t; -*-
   ;;; Commentary:
   ;;
   ;; This module provides various utilities for building agenda buffer.
   ;;
   ;;; Code:

   (require 'init-elpa)
   (require 'lib-vulpea)
   (require 'lib-compat)

   (require 'org)
   (require 'org-habit)
   (require 'vulpea)

   

   (defvar vulpea-agenda-hide-scheduled-and-waiting-next-tasks t
     "Non-nil means to hide scheduled and waiting tasks.
   Affects the following commands:
   - `vulpea-agenda-cmd-focus'
   - `vulpea-agenda-cmd-waiting'")

   (defvar vulpea-agenda-main-buffer-name "*agenda:main*"
     "Name of the main agenda buffer.")

   

    ;;;###autoload
   (defhydra dw/org-roam-jump-menu (:hint nil)
        "
  ^Dailies^        ^Capture^       ^Jump^                  ^^^^^^^^-------------------------------------------------
  _t_: today       _T_: today       _m_: current month
  _r_: tomorrow    _R_: tomorrow    _e_: current year
  _y_: yesterday   _Y_: yesterday   ^ ^
  _d_: date        ^ ^              ^ ^
                              "
        ("t" org-roam-dailies-goto-today)
        ("r" org-roam-dailies-goto-tomorrow)
        ("y" org-roam-dailies-goto-yesterday)
        ("d" org-roam-dailies-goto-date)
        ("T" org-roam-dailies-capture-today)
        ("R" org-roam-dailies-capture-tomorrow)
        ("Y" org-roam-dailies-capture-yesterday)
        ("m" dw/org-roam-goto-month)
        ("e" dw/org-roam-goto-year)
        ("c" nil "cancel"))
      )

 
   ;;;###autoload
   (defun vulpea-agenda-main ()
     "Show main `org-agenda' view."
     (interactive)
     (org-agenda nil " "))

   ;;;###autoload
   (defun vulpea-agenda-person ()
     "Show main `org-agenda' view."
     (interactive)
     (let* ((person (vulpea-select-from
                     "Person"
                     (vulpea-db-query-by-tags-some '("people"))))
            (node (org-roam-node-from-id (vulpea-note-id person)))
            (names (cons (org-roam-node-title node)
                         (org-roam-node-aliases node)))
            (tags (seq-map #'vulpea--title-to-tag names))
            (query (string-join tags "|")))
       (let ((org-agenda-overriding-arguments (list t query)))
         (org-agenda nil "M"))))

   

   ;;;###autoload
   (defun vulpea-agenda-files-update (&rest _)
     "Update the value of `org-agenda-files'."
     (setq org-agenda-files (vulpea-project-files)))

   
   ;; Commands

   ;;;###autoload
   (defconst vulpea-agenda-cmd-refile
     '(tags
       "REFILE"
       ((org-agenda-overriding-header "Tâches à la Representer")
        (org-tags-match-list-sublevels nil))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-today
     '(agenda
       ""
       ((org-agenda-overriding-header "Calendrier d'aujourd'hui:")
        (org-agenda-span 'day)
        (org-agenda-log-mode-items '(clock state))
        (org-agenda-skip-deadline-prewarning-if-scheduled t)
        (org-agenda-sorting-strategy '(habit-down
                                       time-up
                                       category-keep
                                       todo-state-down
                                       priority-down)))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-eisen
     '(agenda
       ""
        ((org-agenda-overriding-header "Calendrier d'Eisenhower:")
                      (org-agenda-show-log t)
                      (org-agenda-log-mode-items '(clock state))
                      (org-agenda-span 5)
                      (org-agenda-start-on-weekday t)
                      ;;            (org-agenda-ndays 5)
                      (org-agenda-start-day "-1d")
                      (org-deadline-warning-days 30))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-focus
     '(tags-todo
       "FOCUS"
       ((org-agenda-overriding-header
         (concat "Pour se concentrer sur"
                 (if vulpea-agenda-hide-scheduled-and-waiting-next-tasks
                     ""
                   " (y compris les tâches ATTENDRE et PROGRAMMÉES)")))
        (org-agenda-skip-function 'vulpea-agenda-skip-habits)
        (org-tags-match-list-sublevels t)
        (org-agenda-todo-ignore-scheduled
         vulpea-agenda-hide-scheduled-and-waiting-next-tasks)
        (org-agenda-todo-ignore-deadlines
         vulpea-agenda-hide-scheduled-and-waiting-next-tasks)
        (org-agenda-todo-ignore-with-date
         vulpea-agenda-hide-scheduled-and-waiting-next-tasks)
        (org-agenda-tags-todo-honor-ignore-options t)
        (org-agenda-sorting-strategy
         '(todo-state-down priority-down effort-up category-keep)))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-stuck-projects
     '(tags-todo
       "PROJET-ANNULÉ-ENATTENTE/!"
       ((org-agenda-overriding-header "Projets Bloqués")
        (org-agenda-skip-function 'vulpea-agenda-skip-non-stuck-projects)
        (org-agenda-sorting-strategy
         '(todo-state-down priority-down effort-up category-keep)))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-projects
     '(tags-todo
       "PROJET-ENATTENTE"
       ((org-agenda-overriding-header (concat "Projets"))
        (org-tags-match-list-sublevels t)
        (org-agenda-skip-function 'vulpea-agenda-skip-non-projects)
        (org-agenda-tags-todo-honor-ignore-options t)
        (org-agenda-sorting-strategy
         '(todo-state-down priority-down effort-up category-keep)))))

   ;;;###autoload
   (defconst vulpea-agenda-cmd-waiting
     '(tags-todo
       "-ANNULÉ+ATTENDRE-READING-FOCUS|+ENATTENTE/!"
       ((org-agenda-overriding-header
         (concat "Tâches en attente et reportées"
                 (if
                  vulpea-agenda-hide-scheduled-and-waiting-next-tasks ""
" (y compris les tâches ATTENDRE et PROGRAMMÉES)")))
        (org-agenda-skip-function 'vulpea-agenda-skip-non-tasks)
        (org-tags-match-list-sublevels nil)
        ;;(org-agenda-todo-ignore-scheduled vulpea-agenda-hide-scheduled-and-waiting-next-tasks)
        (org-agenda-todo-ignore-deadlines
         vulpea-agenda-hide-scheduled-and-waiting-next-tasks))))

   ;;;###autoload
   (defconst vulpea-agenda-eisen-imp-y-urg
    '(tags-todo
      "+important+urgent/!"
         ((org-agenda-overriding-header "Tâches importantes et urgentes")
          (org-tags-match-list-sublevels nil))))

   ;;;###autoload
   (defconst vulpea-agenda-eisen-imp
    '(tags-todo
      "+important-urgent"
      ((org-agenda-overriding-header "Tâches importantes mais non urgentes")
       (org-tags-match-list-sublevels nil))))


   ;;;###autoload
   (defconst vulpea-agenda-eisen-urg
    '(tags-todo
      "-important+urgent"
      ((org-agenda-overriding-header "Tâches urgentes mais sans importance")
       (org-tags-match-list-sublevels nil))))

   ;;;###autoload
    (defconst vulpea-agenda-eisen-alltodos
     ' (tags-todo
        "-important-urgent/!TODO"
        ((org-agenda-overriding-header "Tâches non importantes ni urgentes")
         (org-agenda-category-filter-preset '("-Habitudes"))
        ;; (org-tags-match-list-sublevels nil)
)))
   
   ;; Utilities to build agenda commands -- skip

   ;;;###autoload
   (defun vulpea-agenda-skip-habits ()
     "Skip tasks that are habits."
     (save-restriction
       (widen)
       (let ((subtree-end (save-excursion (org-end-of-subtree t))))
         (cond
          ((org-is-habit-p)
           subtree-end)
          (t
           nil)))))

   ;;;###autoload
   (defun vulpea-agenda-skip-non-projects ()
     "Skip trees that are not projects."
     (if (save-excursion (vulpea-agenda-skip-non-stuck-projects))
         (save-restriction
           (widen)
           (let ((subtree-end (save-excursion (org-end-of-subtree t))))
             (cond
              ((vulpea-agenda-project-p)
               nil)
              ((and (vulpea-agenda-project-subtree-p)
                    (not (vulpea-agenda-task-p)))
               nil)
              (t
               subtree-end))))
       (save-excursion (org-end-of-subtree t))))

   ;;;###autoload
   (defun vulpea-agenda-skip-non-tasks ()
     "Show non-project tasks.
   Skip project and sub-project tasks, habits, and project related
   tasks."
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion
                              (or (outline-next-heading)
                                  (point-max)))))
         (cond
          ((vulpea-agenda-task-p)
           nil)
          (t
           next-headline)))))

   ;;;###autoload
   (defun vulpea-agenda-skip-non-stuck-projects ()
     "Skip trees that are not stuck projects."
     (save-restriction
       (widen)
       (let ((next-headline (save-excursion
                              (or (outline-next-heading)
                                  (point-max)))))
         (if (vulpea-agenda-project-p)
             (let* ((subtree-end (save-excursion
                                   (org-end-of-subtree t)))
                    (has-next ))
               (save-excursion
                 (forward-line 1)
                 (while (and (not has-next)
                             (< (point) subtree-end)
                             (re-search-forward "^\\*+ TODO "
                                                subtree-end t))
                   (unless (member "ATTENDRE" (org-get-tags))
                     (setq has-next t))))
               (if has-next
                   next-headline
                 nil)) ; a stuck project, has subtasks but no next task
           next-headline))))

   
   ;; Utilities to build agenda commands -- predicates

   ;;;###autoload
   (defun vulpea-agenda-project-p ()
     "Return non-nil if the heading at point is a project.
   Basically, it's any item with some todo keyword and tagged as
   PROJECT."
     (let* ((comps (org-heading-components))
            (todo (nth 2 comps))
            (tags (split-string (or (nth 5 comps) "") ":")))
       (and (member todo org-todo-keywords-1)
            (member "PROJET" tags))))

   ;;;###autoload
   (defun vulpea-agenda-project-subtree-p ()
     "Any task with a todo keyword that is in a project subtree.
   Callers of this function already widen the buffer view."
     (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                 (point))))
       (save-excursion
         (vulpea-agenda-find-project-task)
         (if (equal (point) task)
             nil
           t))))

   ;;;###autoload
   (defun vulpea-agenda-task-p ()
     "Any task with a todo keyword and no subtask."
     (save-restriction
       (widen)
       (let ((has-subtask)
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (is-a-task (member (nth 2 (org-heading-components))
                                org-todo-keywords-1)))
         (save-excursion
           (forward-line 1)
           (while (and (not has-subtask)
                       (< (point) subtree-end)
                       (re-search-forward "^\\*+ " subtree-end t))
             (when (member (org-get-todo-state) org-todo-keywords-1)
               (setq has-subtask t))))
         (and is-a-task (not has-subtask)))))

   
   ;; Utilities to build agenda commands -- search

   ;;;###autoload
   (defun vulpea-agenda-find-project-task ()
     "Move point to the parent (project) task if any."
     (save-restriction
       (widen)
       (let ((parent-task (save-excursion
                            (org-back-to-heading 'invisible-ok)
                            (point))))
         (while (org-up-heading-safe)
           (when (member (nth 2 (org-heading-components))
                         org-todo-keywords-1)
             (setq parent-task (point))))
         (goto-char parent-task)
         parent-task)))

   

   ;;;###autoload
   (defun vulpea-agenda-category (&optional len)
     "Get category of item at point for agenda.
   Category is defined by one of the following items:
   - CATEGORY property
   - TITLE keyword
   - TITLE property
   - filename without directory and extension
   When LEN is a number, resulting string is padded right with
   spaces and then truncated with ... on the right if result is
   longer than LEN.
   Usage example:
     (setq org-agenda-prefix-format
           '((agenda . \" %(vulpea-agenda-category) %?-12t %12s\")))
   Refer to `org-agenda-prefix-format' for more information."
     (let* ((file-name (when buffer-file-name
                         (file-name-sans-extension
                          (file-name-nondirectory buffer-file-name))))
            (title (vulpea-buffer-prop-get "title"))
            (category (org-get-category))
            (result
             (or (if (and
                      title
                      (string-equal category file-name))
                     title
                   category)
                 "")))
       (if (numberp len)
           (s-truncate len (s-pad-right len " " result))
         result)))

   

   (provide 'lib-vulpea-agenda)
   ;;; lib-vulpea-agenda.el ends here
#+end_src
**** Vulpea org ID
:PROPERTIES:
:header-args: :tangle no :noweb yes
:END:
#+begin_src emacs-lisp
;;; lib-vulpea-id.el --- ID utilities -*- lexical-binding: t; -*-
<<disclaimer>>
;;; Commentary:
;;
;; Various ID utilities.
;;
;; Automatic ID generation is controlled by `vulpea-id-auto-targets'.
;; It can be configured from init.el file, or from .dir-locals.el file
;; (for example ,to disable automatic generation):
;;
;;   ((org-mode . ((vulpea-id-auto-targets . nil))))
;;
;;; Code:

(require 'org-id)

(defvar vulpea-id-auto-targets '(file headings)
  "Targets for automatic ID assignment.
Each element of this list can be one of the following:
- file - to automatically set ID on the file level;
- headings - to automatically set ID for each heading in the file.
Empty list means no id assignment is needed.")

;;;###autoload
(defun vulpea-id-auto-assign ()
  "Add ID property to the current file.
Targets are defined by `vulpea-id-auto-targets'."
  (when (and vulpea-id-auto-targets
             (derived-mode-p 'org-mode)
             (eq buffer-read-only nil))
    (save-excursion
      (widen)
      (goto-char (point-min))
      (when (seq-contains-p vulpea-id-auto-targets 'file)
        (org-id-get-create))
      (when (seq-contains-p vulpea-id-auto-targets 'headings)
        (org-map-entries #'org-id-get-create)))))

(provide 'lib-vulpea-id)
;;; lib-vulpea-id.el ends here
#+end_src

*** Setup Pkg manager
:properties:
:header-args: :tangle lisp/init-setup.el :noweb yes
:end:

#+begin_src emacs-lisp
;;; init-setup.el --- Initialise Emacs Pkg Manager Setup -*- lexical-binding: t -*-
<<disclaimer>>
;;
;;; Code:

(require 'config-path)

;;;============================================================================
;;; Custom setup.el local macros
;;;============================================================================

<<setup-setup>>

(provide 'init-setup)
;;; init-setup.el ends here
#+end_src
** line number stuff not tangled
#+begin_src elisp :tangle no

;; enable line-numbers
(column-number-mode)

;; Enable line numbers for some modes
(dolist (mode '(text-mode-hook
                prog-mode-hook
                conf-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 1))))

;; Override some modes which derive from the above
(dolist (mode '(org-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src

** Setup if exists Executable
ripgrep and gist
#+begin_src emacs-lisp :noweb-ref rg-gist-link-hint
(setup (:pkg rg)
       (:when-loaded
	(setq rg-group-result t)
	(setq rg-ignore-case 'smart)))

(setup (:pkg gist)
       (setq gist-view-gist t)
       (:hide-mode))

(setup (:pkg link-hint)
       (:require link-hint))

#+end_src
