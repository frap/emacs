#+TITLE: Literate Roam Clojure Emacs Config
#+AUTHOR: gas
#+STARTUP: overview
#+PROPERTY: header-args :cache yes :results output :mkdirp yes :async
#+AUTO_TANGLE: yes

* About me

#+begin_src emacs-lisp :noweb-ref user-settings
  (defconst IS-WORK (string-match "810989" (getenv "USER")))
  (if IS-WORK
      (setq
       user-full-name "Gas 810989"
       user-mail-address "gas_gasson@bnz.co.nz")
    (setq
     user-full-name "Andrés Gasson"
     user-mail-address "gas@tuatara.red"
     github-account-name "frap"))
#+end_src

** Where I am

#+begin_src emacs-lisp :noweb-ref user-settings
  (setq calendar-location-name "Wellington, NZ"
        calendar-latitude -41.28
        calendar-longitude 174.78)
#+end_src

** Auth-sources

Here feels like as good a place as any to setup =auth-sources=.

#+begin_src emacs-lisp :noweb-ref user-settings
  (setq-default auth-sources '("~/.local/state/authinfo.gpg")
                auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src
* Startup Performance

** Garbage Collection & File handlers
:PROPERTIES:
:header-args: :noweb-ref garbage-filehandler
:END:
Make startup faster by reducing the frequency of garbage collection and then use a hook to measure Emacs startup time.


#+begin_src emacs-lisp
;; Garbage collection slows down startup time, so we maximise the threshold for
;; it to run, and we will later reset it.
(setq gc-cons-threshold most-positive-fixnum)

;; file-name-handler-alist is consulted on various I/O functions such as
;; REQUIRE, slowing down startup time, so we set it to NIL, and establish a hook
;; to restore when Emacs is finished starting.
(unless (or (daemonp) noninteractive)
  (let ((file-name-handler-alist/old file-name-handler-alist))
    (setq file-name-handler-alist nil)
    (add-hook 'emacs-startup-hook
              (lambda ()
                (let ((value (delete-dups
                              (append file-name-handler-alist
                                      file-name-handler-alist/old))))
                  (setq file-name-handler-alist value))))))

(unless (daemonp)
  (advice-add #'tty-run-terminal-initialization :override #'ignore)
  (add-hook 'window-setup-hook
            (lambda ()
              (advice-remove #'tty-run-terminal-initialization #'ignore)
              (tty-run-terminal-initialization (selected-frame) nil t))))

  ;; Profile emacs startup
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "*** Emacs chargé en %s secondes avec %d ramasse-miettes."
                       (emacs-init-time "%.2f")
                       gcs-done)))

#+end_src
** Initial frame setup
:PROPERTIES:
:header-args: :noweb-ref early-init-frame
:END:

I tangle this section to =early-init.el=, since that's evaluated
before GUI set-up.  Which, in turn, means Emacs will skip the "flash
of unstyled content" thing.

*** Tool bar

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist
               '(tool-bar-lines . 0))

  (tool-bar-mode -1)
#+end_src

*** Menu bar

#+begin_src emacs-lisp
  ;;(add-to-list 'default-frame-alist
  ;;             '(menu-bar-lines . 0))

 ;; (menu-bar-mode -1)
#+end_src

*** Scroll bars

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist
               '(vertical-scroll-bars . nil)
                 '(horizontal-scroll-bars . nil))

    (scroll-bar-mode -1)
    (horizontal-scroll-bar-mode -1)
#+end_src

*** Resizing

I don't want the frame to resize when I change fonts and stuff, and I
want it to resize by pixels -- we /are/ using a GUI, after all.

#+begin_src emacs-lisp
  (setq-default frame-inhibit-implied-resize t
                frame-resize-pixelwise t)
  (setq truncate-partial-width-windows nil)
#+end_src

*** Miscellaneous
setting dome default settings on early-init
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Iosevka Slab 12"))
  (blink-cursor-mode 0)
  (column-number-mode 1)
  (display-time-mode 0)
  (fringe-mode '(4 . 0))
  (tooltip-mode 0)
  (window-divider-mode 1)
#+end_src
** Directories
:PROPERTIES:
:header-args: :noweb-ref early-directories
:END:
Need to setup some constants and try to keep state in a "clean" directory structure
#+begin_src emacs-lisp
;; For the rest of the Emacs configuration, set this directory to something
;; inside the standard cache directory, so we do not pollute our emacs.d
;; directory with files that we would then have to ignore with Git.
(setq user-emacs-directory
      (expand-file-name "emacs/" (or (getenv "XDG_CACHE_HOME") "~/.cache/")))

;; Add our custom lisp modules to the Emacs load path so they can be discovered.
(push (expand-file-name "lisp/" (file-name-directory user-init-file)) load-path)

;; For the list of native compilation ELN cache directories, delete all but the
;; last element, which is always assumed to be the system path, and then cons a
;; new path in our cache directory to the front. This effectively removes the
;; entry for the original ~/.emacs.d/eln-cache/ and any others that are
;; unwanted.
(setq native-comp-eln-load-path
      (cons (expand-file-name "eln-cache/" user-emacs-directory)
            (last native-comp-eln-load-path)))


#+end_src

** Straight Package Management
:PROPERTIES:
:header-args: :noweb-ref early-straight
:END:
Use Straight for package Management. Also use setup.el for easy config of packages.
#+begin_src emacs-lisp
  ;; Pre-configure the package manager settings before it is loaded.
  (setq package-enable-at-startup nil)
  (setq package-quickstart nil)
  (setq straight-check-for-modifications '(check-on-save find-when-checking))

  ;; Bootstrap the straight.el package manager if it is not already installed,
  ;; then unconditionally load it. We use this rather than Emacs' built-in package
  ;; manager.
    (unless (featurep 'straight)
      ;; Bootstrap straight.el
      (defvar bootstrap-version)
      (let ((bootstrap-file
             (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
            (bootstrap-version 5))
        (unless (file-exists-p bootstrap-file)
          (with-current-buffer
              (url-retrieve-synchronously
               "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
               'silent 'inhibit-cookies)
            (goto-char (point-max))
            (eval-print-last-sexp)))
        (load bootstrap-file nil 'nomessage)))

    ;; Additional post-setup of straight.el.
    (require 'straight-x)
    (defalias 'straight-ಠ_ಠ-mode nil)
  #+end_src
** Emacs Package Manager Setup
:PROPERTIES:
:header-args: :noweb-ref setup-pkgmgr
:END:
Using [[https://www.emacswiki.org/emacs/SetupEl][setup.el]] by pkal to manage packages as alternative to use-package
#+begin_src emacs-lisp
  (straight-use-package '(setup :type git :host nil :repo "https://git.sr.ht/~pkal/setup"))
  (require 'setup)

  ;; Uncomment this for debugging purposes
  (defun dw/log-require (&rest args)
    (with-current-buffer (get-buffer-create "*require-log*")
      (insert (format "%s\n"
                      (file-name-nondirectory (car args))))))
  (add-to-list 'after-load-functions #'dw/log-require)
  ;; added from  https://github.com/daviwil/dotfiles/blob/master/Emacs.org#org-mode

  (defmacro define-setup-macro (name signature &rest body)
    "Shorthand for 'setup-define'. NAME is the name of the local macro. SIGNATURE
                is used as the argument list for FN. If BODY starts with a string, use this as
                the value for :documentation. Any following keywords are passed as OPTS to
                'setup-define'."
    (declare (debug defun))
    (let (opts)
      (when (stringp (car body))
        (setq opts (nconc (list :documentation (pop body)) opts)))
      (while (keywordp (car body))
        (let ((prop (pop body))
              (val `',(pop body)))
          (setq opts (nconc (list prop val) opts))))
      `(setup-define ,name
         (cl-function (lambda ,signature ,@body))
         ,@opts)))

  #+end_src
*** Setup local macros
  :PROPERTIES:
:header-args: :noweb-ref setup-macros
:END:
 local-macros for setup.el
 #+begin_src emacs-lisp
    (define-setup-macro :pkg (recipe)
       "Install RECIPE with 'straight-use-package'. This macro can be used as HEAD,
                 and will replace itself with the first RECIPE's package."
       :repeatable t
       :shorthand (lambda (sexp)
                    (let ((recipe (cadr sexp)))
                      (if (consp recipe)
                          (car recipe)
                        recipe)))
       `(straight-use-package ',recipe))

  (setup-define :pkg-when
  (lambda (recipe condition)
    `(if ,condition
         (straight-use-package ',recipe)
       ,(setup-quit)))
  :documentation
  "Install RECIPE with `straight-use-package' when CONDITION is met.
If CONDITION is false, stop evaluating the body.  This macro can
be used as HEAD, and will replace itself with the RECIPE's
package.  This macro is not repeatable."
  :repeatable nil
  :indent 1
  :shorthand (lambda (sexp)
               (let ((recipe (cadr sexp)))
                 (if (consp recipe) (car recipe) recipe))))

 (define-setup-macro :hide-mode (&optional mode)
       "Hide the mode-line lighter of the current mode. Alternatively, MODE can be
             specified manually, and override the current mode."
       :after-loaded t
       (let ((mode (or mode (setup-get 'mode))))
         `(progn
            (setq minor-mode-alist
                  (remq (assq ',(intern (format "%s-mode" mode)) minor-mode-alist)
                        minor-mode-alist))
            (setq minor-mode-alist
                  (remq (assq ',mode minor-mode-alist)
                        minor-mode-alist)))))

     (define-setup-macro :load-after (features &rest body)
       "Load the current feature after FEATURES."
       :indent 1
       (let ((body `(progn
                      (require ',(setup-get 'feature))
                      ,@body)))
         (dolist (feature (nreverse (ensure-list features)))
           (setq body `(with-eval-after-load ',feature ,body)))
         body))

     (define-setup-macro :disable ()
       "Unconditionally abort the evaluation of the current body."
       (setup-quit))

     (define-setup-macro :delay (seconds)
       "Require the current FEATURE after SECONDS of idle time."
       :indent 1
       `(run-with-idle-timer ,seconds nil #'require ',(setup-get 'feature) nil t))

     (define-setup-macro :with-idle-delay (seconds &rest body)
       "Evaluate BODY after SECONDS of idle time."
       :indent 1
       `(run-with-idle-timer ,seconds nil (lambda () ,@body)))

     (define-setup-macro :advise (symbol where arglist &rest body)
       "Add a piece of advice on a function. See 'advice-add' for more details."
       :after-loaded t
       :debug '(sexp sexp function-form)
       :indent 3
       (let ((name (gensym "setup-advice-")))
         `(progn
            (defun ,name ,arglist ,@body)
            (advice-add ',symbol ,where #',name))))

    (setup-define :needs
     (lambda (executable)
       `(unless (executable-find ,executable)
          ,(setup-quit)))
   :documentation "If EXECUTABLE is not in the path, stop here."
   :repeatable 1)


#+end_src
Sometimes it's good to clean up unused repositories if I've removed packages from my configuration.  Use =straight-remove-unused-repos= for this purpose.
** Emacs Startup Setup
:PROPERTIES:
:header-args: :noweb-ref emacs-startup
:END:
Show startup time
#+begin_src emacs-lisp
(setup show-startup-time
  (:with-hook emacs-startup-hook
    (:hook enfer/show-startup-time)))
#+end_src
*** Garbage collection automatic
Configure grabage collection
#+begin_src emacs-lisp
(setup (:pkg gcmh)
  (setq gcmh-auto-idle-delay-factor 10)
  (setq gcmh-high-cons-threshold (* 128 1024 1024))
  (setq gcmh-idle-delay 'auto)
  (gcmh-mode 1)
  (:hide-mode))
#+end_src

*** MAC specific
#+begin_src emacs-lisp
  ;;(cua-mode 1)
  ;; path stuff for macOS
  (if IS-MAC
      (setup (:pkg exec-path-from-shell)
        ;;(dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE" "NIX_SSL_CERT_FILE" "HOMEBREW_PREFIX"))
        ;;  (add-to-list 'exec-path-from-shell-variables var))
        (exec-path-from-shell-initialize)
        ;;(add-to-list 'exec-path (expand-file-name "/bin" (getenv  "HOMEBREW_PREFIX")))
        ))
#+end_src
*** Auto compile and Benchmarking
#+begin_src emacs-lisp

(setup (:pkg benchmark-init)
  (:disable) ; Disabled when not benchmarking.
  (define-advice define-obsolete-function-alias (:filter-args (ll))
    (let ((obsolete-name (pop ll))
          (current-name (pop ll))
          (when (if ll (pop ll) "1"))
          (docstring (if ll (pop ll) nil)))
      (list obsolete-name current-name when docstring)))
  (:require benchmark-init-modes)
  (:global-bind
   "<M-f2>" #'benchmark-init/show-durations-tabulated
   "<M-f3>" #'benchmark-init/show-durations-tree)
  (:with-hook after-init-hook
    (:hook benchmark-init/deactivate)))

(setup (:pkg auto-compile)
  (auto-compile-on-load-mode 1)
  (auto-compile-on-save-mode 1)
  (:hide-mode)
  (:hide-mode auto-compile-on-load))
#+end_src
*** Keep Emacs Directory clean
Use no-littering to automatically set common paths to the new user-emacs-directory
#+begin_src emacs-lisp
(setup (:pkg no-littering)
  (require 'no-littering))

#+end_src

* Emacs Sane defaults
Set Up Good Defaults. Taken from [[https://github.com/mfiano/dotfiles/blob/master/.emacs.d/lisp/mf-settings.el][mifano's emacs setup]]

Some constants that I use.
#+begin_src emacs-lisp :noweb-ref constants
(require 'subr-x)
;;; Initialise Constants
(defconst NATIVECOMP (if (fboundp 'native-comp-available-p) (native-comp-available-p)))
(defconst IS-MAC     (eq system-type 'darwin))
(defconst IS-LINUX   (eq system-type 'gnu/linux))
(defconst IS-TERMUX
  (string-suffix-p "Android" (string-trim (shell-command-to-string "uname -a"))))
#+end_src

* Emacs Packages
** Utility Functions & macros

These have been sucked from [[https://github.com/mfiano/dotfiles/blob/master/.emacs.d/lisp/mf-util.el][mifano]]

*** Macros
:PROPERTIES:
:header-args: :noweb-ref macros
:END:
#+begin_src emacs-lisp

  (defmacro fn (&rest body)
    `(lambda () ,@body))

  (defmacro fn! (&rest body)
    `(lambda () (interactive) ,@body))

  (defmacro quiet! (&rest forms)
  `(cond
    (noninteractive
     (let ((old-fn (symbol-function 'write-region)))
       (cl-letf ((standard-output (lambda (&rest _)))
                 ((symbol-function 'load-file)
                  (lambda (file) (load file nil t)))
                 ((symbol-function 'message) (lambda (&rest _)))
                 ((symbol-function 'write-region)
                  (lambda (start end filename &optional append visit lockname
                                 mustbenew)
                    (unless visit (setq visit 'no-message))
                    (funcall old-fn start end filename append visit lockname
                             mustbenew))))
         ,@forms)))
    ((or debug-on-error debug-on-quit)
     ,@forms)
    ((let ((inhibit-message t)
           (save-silently t))
       (prog1 ,@forms (message ""))))))

 #+end_src
*** Variables
:PROPERTIES:
:header-args: :noweb-ref variables
:END:
#+begin_src emacs-lisp
(defvar enfer/ignored-directories
  `(,user-emacs-directory
    "eln-cache"))

(defvar enfer/ignored-suffixes
  '(".7z" ".bz2" ".db" ".dll" ".dmg" ".elc" ".exe" ".fasl" ".gz" ".iso" ".jar"
    ".o" ".pyc" ".rar" ".so" ".sql" ".sqlite" ".tar" ".tgz" ".xz" ".zip"))
#+end_src
*** Functions
:PROPERTIES:
:header-args: :noweb-ref functions
:END:
#+begin_src emacs-lisp
 (defun enfer/show-startup-time ()
      (message "Heure de démarrage d'Emacs: %.2fs (%d GCs)"
               (float-time (time-subtract after-init-time before-init-time))
               gcs-done))

  (defun enfer/etc-file (file-name)
    (expand-file-name (format "etc/%s" file-name) user-emacs-directory))

  (defun enfer/cache-dir-p (path)
    (string-prefix-p (getenv "XDG_CACHE_HOME") (expand-file-name path)))

   (defun mf/smarter-move-beginning-of-line (arg)
      (interactive "^p")
      (setq arg (or arg 1))
      (when (/= arg 1)
        (let ((line-move-visual nil))
          (forward-line (1- arg))))
      (let ((orig-point (point)))
        (back-to-indentation)
        (when (= orig-point (point))
          (move-beginning-of-line 1))))

    (defun mf/yank-primary-selection ()
      (interactive)
      (let ((primary (or (gui-get-primary-selection) (gui-get-selection))))
        (when primary
          (push-mark (point))
          (insert-for-yank primary))))

    (defun mf/delete-file (filename)
      (interactive "f")
      (when (and filename (file-exists-p filename))
        (let ((buffer (find-buffer-visiting filename)))
          (when buffer
            (kill-buffer buffer)))
        (delete-file filename)))

    (defun mf/rename-file ()
      (interactive)
      (let ((name (buffer-name))
            (filename (buffer-file-name)))
        (if (not (and filename (file-exists-p filename)))
            (error "Buffer '%s' n'a ​​pas de fichier associé!" name)
          (let* ((dir (file-name-directory filename))
                 (new-name (read-file-name "Nouveau nom de fichier: " dir)))
            (cond ((get-buffer new-name)
                   (error "Un Buffer nommé '%s' existe déjà!" new-name))
                  (t
                   (let ((dir (file-name-directory new-name)))
                     (when (and (not (file-exists-p dir))
                                (yes-or-no-p (format "Créer le répertoire '%s'?"
                                                     dir)))
                       (make-directory dir t)))
                   (rename-file filename new-name 1)
                   (rename-buffer new-name)
                   (set-visited-file-name new-name)
                   (set-buffer-modified-p nil)
                   (when (fboundp 'recentf-add-file)
                     (recentf-add-file new-name)
                     (recentf-remove-if-non-kept filename))
                   (message "Fichier '%s' renommé avec succès en '%s'" name
                            (file-name-nondirectory new-name))))))))
#+end_src
** Setup if exists Executable
ripgrep and gist
#+begin_src emacs-lisp :noweb-ref pkg-utils
  (setup (:pkg rg)
    (:when-loaded
      (setq rg-group-result t)
      (setq rg-ignore-case 'smart)))

  (setup (:pkg gist)
  (setq gist-view-gist t)
  (:hide-mode))

(setup (:pkg link-hint)
  (:require link-hint))
#+end_src
** Emacs UI Appearance
:PROPERTIES:
:header-args: :noweb-ref pkg-ui
:END:
*** Menu and Tool bars
#+begin_src elisp
(menu-bar-mode -1)            ; Disable the menu bar
(unless IS-TERMUX
  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room
  (menu-bar-mode 1))

;; Set up the visible bell
(setq visible-bell t)
#+end_src
*** Fonts & Emojis

On Linux, I have a custom build of Iosevka that I like.

#+begin_src emacs-lisp :noweb-ref pkg-ui
  (setup (:pkg all-the-icons)
    (:load-after marginalia
      (:pkg all-the-icons-completion)
      (all-the-icons-completion-mode 1)
      (:with-mode marginalia-mode
        (:hook all-the-icons-completion-marginalia-setup)))
    (:load-after dired
      (:pkg all-the-icons-dired)
      (:with-mode dired-mode
        (:hook all-the-icons-dired-mode))))

  (setup (:pkg emojify)
    (setq emojify-emoji-styles '(unicode))
    (global-emojify-mode 1))

  (setup (:pkg unicode-fonts)
    (unicode-fonts-setup))

  ;; Set the font face based on platform
  (pcase system-type
    ((or 'gnu/linux 'windows-nt 'cygwin)
     (set-face-attribute 'default nil
                         :font "JetBrains Mono"
                         :weight 'light
                         ;;   :height (dw/system-settings-get 'emacs/default-face-size)
                         ))
    ('darwin (set-face-attribute 'default nil :font "Fira Mono" :height 150)))

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil
                      :font "JetBrains Mono"
                      :weight 'light
                      ;;    :height (dw/system-settings-get 'emacs/fixed-face-size)
                      )

  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil
                      ;; :font "Cantarell"
                      :font "Iosevka Aile"
                      ;;  :height (dw/system-settings-get 'emacs/variable-face-size)
                      :weight 'light)

  (setup (:pkg default-text-scale)
    (:bind
     "M--" default-text-scale-decrease
     "M-+" default-text-scale-increase
     "M-=" default-text-scale-reset)
    (default-text-scale-mode 1))

  (setup (:pkg dimmer)
    (setq dimmer-fraction 0.3)
    (dimmer-mode 1))
#+end_src

*** Frame titles, sizes and mouse setup

#+begin_src emacs-lisp
  (setq-default frame-title-format
                (concat invocation-name "@" (system-name)
                        ": %b %+%+ %f"))

  (unless IS-TERMUX
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
    (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
    (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
    (setq scroll-step 1) ;; keyboard scroll one line at a time
    (setq use-dialog-box nil)) ;; Disable dialog boxes since they weren't working in Mac OSX

  (unless IS-TERMUX
    (set-frame-parameter (selected-frame) 'alpha '(90 . 90))
    (add-to-list 'default-frame-alist '(alpha . (90 . 90)))
    (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
    (add-to-list 'default-frame-alist '(fullscreen . maximized)))
#+end_src

*** Themes & Modeline

#+begin_src emacs-lisp
  (setup (:pkg spacegray-theme))
  (setup (:pkg doom-themes)
    (setq doom-themes-enable-bold t)
    (setq doom-themes-enable-italic t)
    (doom-themes-org-config))

  (unless IS-TERMUX
    (load-theme 'doom-palenight t)
    (doom-themes-visual-bell-config))

  ;; Mode-line
  ;;Basic Customisation
  (setq display-time-format "%l:%M %p %b %y"
        display-time-default-load-average nil)

  ;; Doom Modeline

  (setup (:pkg minions)
    (:hook-into doom-modeline-mode))

  (setup (:pkg doom-modeline)
   ;; (setq doom-modeline-bar-width 4)
    (setq doom-modeline-buffer-encoding nil)
    (setq doom-modeline-buffer-file-name-style 'relative-from-project)
    (setq doom-modeline-height 30)
    (setq doom-modeline-major-mode-icon t)
    (setq doom-modeline-minor-modes t)
    (:with-hook window-setup-hook
      (:hook (fn (set-face-attribute
                  'mode-line nil :family "Iosevka Slab" :height 130))))
    (:hook-into window-setup)
    (:option doom-modeline-height 15
             doom-modeline-bar-width 6
             doom-modeline-lsp t
             doom-modeline-github nil
             doom-modeline-mu4e nil
             doom-modeline-irc t
             doom-modeline-minor-modes t
             doom-modeline-persp-name nil
             doom-modeline-buffer-file-name-style 'truncate-except-project
             doom-modeline-major-mode-icon nil)
    (custom-set-faces '(mode-line ((t (:height 0.85))))
                      '(mode-line-inactive ((t (:height 0.85))))))


#+end_src
*** Don't show default modeline

Wait until my *fancy* modeline is loaded -- from [[https://github.com/KaratasFurkan/.emacs.d#remove-redundant-ui][Furkan Karataş]].

#+begin_src emacs-lisp
  (setq-default mode-line-format nil)
#+end_src
*** highlights and diff
setup diff and highlights
#+begin_src emacs-lisp
  (setup (:pkg highlight-numbers)
    (:hook-into prog-mode)
    (:hide-mode))

  (setup (:pkg hl-fill-column)
    (:require hl-fill-column)
    (:hook-into prog-mode text-mode conf-mode))

  (setup (:pkg hl-line)
    (global-hl-line-mode 1))

  (setup (:pkg hl-todo)
    (global-hl-todo-mode 1))

(setup (:pkg diff-hl)
  (global-diff-hl-mode 1)
  (:with-mode dired-mode
    (:hook diff-hl-dired-mode))
  (:load-after magit
    (:with-hook magit-pre-refresh-hook
      (:hook diff-hl-magit-pre-refresh))
    (:with-hook magit-post-refresh-hook
      (:hook diff-hl-magit-post-refresh))))
#+end_src
*** Fringes
:PROPERTIES:
:header-args: :noweb-ref settings
:END:

I have grown to love Emacs's little fringes on the side of the
windows.  In fact, I love them so much that I really went overboard
and have made a custom fringe bitmap.

**** Indicate empty lines after the end of the buffer

#+begin_src emacs-lisp
  (setq-default indicate-empty-lines t)
#+end_src

**** Indicate the boundaries of the buffer

#+begin_src emacs-lisp
  (setq-default indicate-buffer-boundaries 'right)
#+end_src

**** Indicate continuation lines, but only on the left fringe

#+begin_src emacs-lisp
  (setq-default visual-line-fringe-indicators '(left-curly-arrow nil))
#+end_src

**** Customise fringe bitmaps

***** Curly arrows (continuation lines)

#+begin_src emacs-lisp
  (define-fringe-bitmap 'left-curly-arrow
    [#b11000000
     #b01100000
     #b00110000
     #b00011000])

  (define-fringe-bitmap 'right-curly-arrow
    [#b00011000
     #b00110000
     #b01100000
     #b11000000])
#+end_src

***** Arrows (truncation lines)

#+begin_src emacs-lisp
  (define-fringe-bitmap 'left-arrow
    [#b00000000
     #b01010100
     #b01010100
     #b00000000])

  (define-fringe-bitmap 'right-arrow
    [#b00000000
     #b00101010
     #b00101010
     #b00000000])
#+end_src

*** Emacs *Help* functions

 Help and which functions

#+begin_src emacs-lisp :noweb-ref pkg-ui

  (setup (:pkg helpful)
  (:when-loaded
    (:global-bind
     "C-h f" helpful-callable
     "C-h v" helpful-variable
     "C-h k" helpful-key)
    (:load-after link-hint
        (:bind
         "o" link-hint-open-link-at-point)
      (setq helpful-switch-buffer-function
            (lambda (x)
              (if (eq major-mode 'helpful-mode)
                  (switch-to-buffer x)
                (pop-to-buffer x)))))))

  (setup (:pkg which-key)
   (which-key-mode 1)
   (setq which-key-add-column-padding 2)
   (setq which-key-idle-delay 0.5)
   (setq which-key-idle-secondary-delay 0.1)
   (setq which-key-max-display-columns nil)
   (setq which-key-min-display-lines 6)
   (setq which-key-replacement-alist
         '((("left") . ("🡸"))
           (("right") . ("🡺"))
           (("up") . ("🡹"))
           (("down") . ("🡻"))
           (("delete") . ("DEL"))
           (("\\`DEL\\'") . ("BKSP"))
           (("RET") . ("⏎"))
           (("next") . ("PgDn"))
           (("prior") . ("PgUp"))))
   (setq which-key-sort-order 'which-key-key-order-alpha)
   (setq which-key-sort-uppercase-first nil)
   (which-key-setup-minibuffer)
   (:with-hook which-key-init-buffer-hook
     (:hook (fn (setq line-spacing 4))))
   (:hide-mode))
#+end_src

*** Navigation
setup Marginalia for navigation
#+begin_src emacs-lisp
  (setup (:pkg marginalia)
    (:load-after vertico
      (marginalia-mode 1)))

#+end_src
keychords with hydra
#+begin_src emacs-lisp
  (setup (:pkg hydra)
    (require 'hydra))
#+end_src
*** Completion
Emacs completion parlava
#+begin_src emacs-lisp :noweb-ref pkg-ompletion
  (setup (:pkg company)
    (global-company-mode 1)
    (company-tng-mode 1)
    (setq company-backends (remove 'company-dabbrev company-backends))
    (setq company-idle-delay nil)
    (setq company-minimum-prefix-length 2)
    (setq company-selection-wrap-around t)
    (setq company-tooltip-align-annotations t)
    (:with-map company-active-map
      (:bind
       [tab] company-select-next
       [backtab] company-select-previous))
    (:hide-mode))

  (setup (:pkg consult)
    (setq consult-async-min-input 2)
    (setq consult-preview-key (kbd "M-."))
    (setq xref-show-definitions-function #'consult-xref)
    (setq xref-show-xrefs-function #'consult-xref)
    (advice-add #'completing-read-multiple
                :override #'consult-completing-read-multiple)
    (:load-after projectile
      (setq consult-project-root-function #'projectile-project-root))
    (:load-after vertico
      (setq completion-in-region-function
            (lambda (&rest args)
              (apply (if vertico-mode
                         #'consult-completion-in-region
                       #'completion--in-region)
                     args)))))

  (setup (:pkg embark)
    (:load-after which-key
      (defun embark-which-key-indicator ()
        (lambda (&optional keymap targets prefix)
          (if (null keymap)
              (which-key--hide-popup-ignore-command)
            (which-key--show-keymap
             (if (eq (plist-get (car targets) :type) 'embark-become)
                 "Become"
               (format "Act on %s '%s'%s"
                       (plist-get (car targets) :type)
                       (embark--truncate-target (plist-get (car targets) :target))
                       (if (cdr targets) "…" "")))
             (if prefix
                 (pcase (lookup-key keymap prefix 'accept-default)
                   ((and (pred keymapp) km) km)
                   (_ (key-binding prefix 'accept-default)))
               keymap)
             nil nil t (lambda (binding)
                         (not (string-suffix-p "-argument" (cdr binding))))))))
      (setq prefix-help-command #'embark-prefix-help-command)
      (setq embark-indicators '(embark-which-key-indicator
                                embark-highlight-indicator
                                embark-isearch-highlight-indicator))
      (:advise embark-completing-read-prompter :around (fn &rest args)
        (when-let ((win (get-buffer-window which-key--buffer 'visible)))
          (quit-window 'kill-buffer win)
          (let ((embark-indicators (delq #'embark-which-key-indicator
                                         embark-indicators)))
            (apply fn args))))
      (:global "C-," embark-act)))

  (setup (:pkg embark-consult)
    (:load-after (embark consult)
      (:with-mode embark-collect-mode
        (:hook consult-preview-at-point-mode))))

  (setup (:pkg orderless)
    (setq completion-category-defaults nil)
    (setq completion-category-overrides '((file (styles partial-completion))))
    (setq completion-styles '(orderless)))

  (setup (:pkg (vertico :files (:defaults "extensions/*")))
    (:also-load vertico-repeat)
    (setq vertico-count 15)
    (setq vertico-resize t)
    (vertico-mode 1)
    (:with-hook minibuffer-setup-hook
      (:hook vertico-repeat-save)))

#+end_src
*** Window Setup

#+begin_src emacs-lisp :noweb-ref pkg-window
  (setup (:pkg ace-window)
    (setq aw-background t)
    (setq aw-scope 'frame)
    (ace-window-display-mode 1)
    (:hide-mode))

  (setup (:pkg shackle)
  (setq shackle-rules
        `((compilation-mode
           :select t :align right :size 0.33)
          (magit-status-mode
           :select t :align right :size 0.5)
          ((help-mode helpful-mode)
           :select t :align right :size 0.4)
          ((sly-xref-mode "\\*\\(sly-mrepl\\|ielm\\)")
           :regexp t :noselect t :align below :size 0.24)))
  (shackle-mode 1))

(setup (:pkg windmove)
  (windmove-default-keybindings))

(setup (:pkg winner)
  (winner-mode 1))
  (setq-default window-divider-default-places 'right-only ; only right
                window-divider-default-bottom-width 2
                window-divider-default-right-width 2)
#+end_src

#+begin_src emacs-lisp :noweb-ref modes
  (window-divider-mode +1)
#+end_src

**** Splitting windows sensibly

This is extremely fiddly and I'd love another option.
- [[https://www.emacswiki.org/emacs/ToggleWindowSplit][ToggleWindowSplit, EmacsWiki]]

#+begin_src emacs-lisp
  (setq-default split-width-threshold 100
                split-height-threshold 50)
#+end_src
*** Project Setup
setup of git and projectile
#+begin_src emacs-lisp :noweb-ref pkg-project

(setup (:pkg git-timemachine)
    (:bind
     "[" git-timemachine-show-previous-revision
     "]" git-timemachine-show-next-revision
     "b" git-timemachine-blame))

(setup (:pkg magit)
  (setq git-commit-summary-max-length 120)
  (setq magit-commit-show-diff nil)
  (setq magit-delete-by-moving-to-trash nil)
  (setq magit-display-buffer-function
        #'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-log-auto-more t)
  (setq magit-log-margin-show-committer-date t)
  (setq magit-revert-buffers 'silent)
  (setq magit-save-repository-buffers 'dontask)
  (setq magit-wip-after-apply-mode t)
  (setq magit-wip-after-save-mode t)
  (setq magit-wip-before-change-mode t)
  (setq transient-values
        '((magit-log:magit-log-mode "--graph" "--color" "--decorate"))))

(setup magit-wip
  (:load-after magit
    (magit-wip-mode 1)
    (:hide-mode)))

(setup (:pkg magit-todos)
  (:load-after magit
    (magit-todos-mode 1)))

(setup (:pkg persp-projectile)
  (:load-after (perspective projectile)))

(setup (:pkg perspective)
  (setq persp-modestring-short t)
  (setq persp-show-modestring t)
  (setq persp-sort 'name)
  (setq persp-state-default-file (enfer/etc-file "perspectives"))
  (setq persp-switch-wrap nil)
  (persp-mode 1)
  (:global
   "M-1" (fn! (persp-switch-by-number 1))
   "M-2" (fn! (persp-switch-by-number 2))
   "M-3" (fn! (persp-switch-by-number 3))
   "M-4" (fn! (persp-switch-by-number 4))
   "M-5" (fn! (persp-switch-by-number 5))
   "M-6" (fn! (persp-switch-by-number 6))
   "M-7" (fn! (persp-switch-by-number 7))
   "M-8" (fn! (persp-switch-by-number 8))
   "M-9" (fn! (persp-switch-by-number 9))))

(setup (:pkg projectile)
  (setq projectile-cache-file (enfer/etc-file "projectile.cache"))
  (setq projectile-kill-buffers-filter 'kill-only-files)
  (setq projectile-known-projects-file (enfer/etc-file "projectile-bookmarks"))
  (projectile-mode 1)
  (setq projectile-find-dir-includes-top-level t)
  (setf projectile-globally-ignored-directories
        (delete-dups (append projectile-globally-ignored-directories
                             enfer/ignored-directories)))
  (setq projectile-globally-ignored-file-suffixes enfer/ignored-suffixes)
  (:with-idle-delay 15 (quiet! (projectile-cleanup-known-projects)))
  (:hide-mode))
#+end_src
*** Uniquify buffers

The default way Emacs makes buffer names unique is really ugly and,
dare I say it, stupid.  Instead, I want them to be uniquified by their
filesystem paths.

#+begin_src emacs-lisp :noweb-ref requires
  (require 'uniquify)
#+end_src

#+begin_src emacs-lisp :noweb-ref settings
  (setq-default uniquify-buffer-name-style 'forward
                uniquify-separator "/"
                uniquify-after-kill-buffer-p t
                uniquify-ignore-buffers-re "^\\*")
#+end_src

** Emacs as an Editor
:PROPERTIES:
:header-args: :noweb-ref pkg-editor
:END:
Setup undo , whitespace, expand, indenataion and avy
#+begin_src emacs-lisp
      (setup (:pkg aggressive-indent)
        (:hook-into prog-mode)
        (:hide-mode))

      (setup (:pkg avy)
        (setq avy-all-windows nil)
        (setq avy-background t)
        (setq avy-keys (nconc (number-sequence ?a ?z)
                              (number-sequence ?A ?Z)
                              (number-sequence ?1 ?9)))
        (setq avy-style 'pre))

      (setup (:pkg hungry-delete)
      (:load-after smartparens
        (setq hungry-delete-join-reluctantly t)
        (global-hungry-delete-mode 1)
        (:hook-into smartparens-enabled)
        (:hide-mode)))


  (setup (:pkg expand-region)
    (:require expand-region)
    )

    (setup (:pkg undo-fu undo-fu-session)
      (:with-map (prog-mode-map text-mode-map)
          (:bind
           "u" undo-fu-only-undo
           "C-r" undo-fu-only-redo))
      (setq undo-fu-session-incompatible-files
            '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'"))
      (global-undo-fu-session-mode 1))

    (setup (:pkg whitespace-cleanup-mode)
      (global-whitespace-cleanup-mode 1)
      (:with-hook before-save-hook
        (:hook delete-trailing-whitespace))
      (:hide-mode))
#+end_src

** Note Taking
:PROPERTIES:
:header-args: :noweb-ref pkg-org
:END:
#+BEGIN_SRC elisp :noweb-ref pkg-org

    (defvar enfer/dir-notes
      (file-name-as-directory (expand-file-name "~/org")))

    ;; Turn on indentation and auto-fill mode for Org files
    (defun frap/org-mode-setup ()
      (org-indent-mode)   ;; turn on org indent
      (variable-pitch-mode 1) ;; turn on variable-pitch
      (auto-fill-mode 0)   ;; turn off auto-fill
      (visual-line-mode 1) ;; turn on visual-line-mode
      )

    (setup (:pkg org)
      (:also-load org-tempo)
     ;; (:hook frap/org-mode-setup)
      (:global "C-c a"   org-agenda)
      (:bind "C-c c"  org-capture
             "C-c l"   org-link)
      (setq org-ellipsis " …"
            org-directory enfer/dir-notes
            ;;org-adapt-indentation nil ; don't indent things
            org-capture-bookmark nil
            org-cycle-separator-lines 2
            org-catch-invisible-edits 'show-and-error;'smart ; let's try this
            org-edit-src-content-indentation 2
            org-export-coding-system 'utf-8-unix
            org-export-headline-levels 8
            org-export-with-section-numbers nil
            org-export-with-smart-quotes t
            org-export-with-sub-superscripts t
            org-export-with-toc t
            org-fontify-quote-and-verse-blocks t
            org-fontify-whole-heading-line t
            org-hide-block-startup nil
            org-hide-emphasis-markers t
            org-html-coding-system 'utf-8-unix
            org-html-todo-kwd-class-prefix "keyword "
            org-id-link-to-org-use-id 'create-if-interactive
            org-id-locations-file (expand-file-name ".orgids" enfer/dir-notes)
            org-outline-path-complete-in-steps nil
            org-pretty-entities t
            org-return-follows-link t
            org-src-tab-acts-natively t
            org-src-fontify-natively t
            org-src-preserve-indentation nil
            org-startup-folded 'content
            org-startup-indented t ;; must have
            org-startup-with-inline-images t
            ;; Use the special C-a, C-e and C-k definitions for Org, which enable some special behavior in headings.
            org-special-ctrl-a/e t
            org-special-ctrl-k t)

      (setq org-modules
            '(org-crypt
              org-habit
              org-bookmark
              org-eshell
              ;;org-irc
              ))

      (setq org-refile-targets '((nil :maxlevel . 3)
                                 (org-agenda-files :maxlevel . 3))
            org-refile-use-outline-path t)

      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
         (clojure . t)
         (shell . t)
         (python . t)
         ;;(ledger . t)
         ))

      (with-no-warnings
        (custom-declare-face '+org-todo-active  '((t (:inherit (bold font-lock-constant-face org-todo)))) "")
        (custom-declare-face '+org-todo-project '((t (:inherit (bold font-lock-doc-face org-todo)))) "")
        (custom-declare-face '+org-todo-onhold  '((t (:inherit (bold warning org-todo)))) "")
        (custom-declare-face '+org-todo-cancel  '((t (:inherit (bold error org-todo)))) ""))

      (setq org-todo-keywords
            '((sequence
               "TODO(t)"  ; A task that needs doing & is ready to do
               "PROJ(p)"  ; A project, which usually contains other tasks
               "SUIV(s)"  ; A task that is in progress
               "ATTE(w)"  ; Something external is holding up this task
               "SUSP(h)"  ; This task is paused/on hold because of me
               "|"
               "FINI(d)"  ; Task successfully completed
               "KILL(k)") ; Task was cancelled, aborted or is no longer applicable
              (sequence
               "[ ](T)"   ; A task that needs doing
               "[-](S)"   ; Task is in progress
               "[?](W)"   ; Task is being held up or paused
               "|"
               "[X](D)")  ; Task was completed
              (sequence
               "|"
               "OKAY(o)"
               "YES(y)"
               "NO(n)"))
            org-todo-keyword-faces
            '(("[-]"   . +org-todo-active)
              ("SUIV" . +org-todo-active)
              ("[?]"  . +org-todo-onhold)
              ("ATTE" . +org-todo-onhold)
              ("SUSP" . +org-todo-onhold)
              ("PROJ" . +org-todo-project)
              ("NO"   . +org-todo-cancel)
              ("KILL" . +org-todo-cancel)))
      (setq org-fancy-priorities-list '("⚡" "⬆" "⬇" "☕"))
      (setq  org-capture-templates
             '(("x" "Note" entry
                (file+olp+datetree "journal.org")
                "**** [ ] %U %?" :prepend t :kill-buffer t)
               ("t" "Tâches" entry
                (file+headline "todo.org" "Boîte de réception")
                "* [ ] %?\n%i" :prepend t :kill-buffer t)))
      ;;  (setq org-capture-templates
      ;;        `(("i" "inbox" entry (file ,(concat gas/org-agenda-directory "inbox.org"))
      ;;          "* TODO %?")
      ;;         ("e" "email" entry (file+headline ,(concat gas/org-agenda-directory "emails.org") "Emails")
      ;;              "* TODO [#A] Reply: %a :@maison:@bureau:"
      ;;               :immediate-finish t)
      ;;          ("c" "org-protocol-capture" entry (file ,(concat gas/org-agenda-directory "inbox.org"))
      ;;               "* TODO [[%:link][%:description]]\n\n %i"
      ;;               :immediate-finish t)
      ;;          ("w" "Weekly Review" entry (file+olp+datetree ,(concat gas/org-agenda-directory "reviews.org"))
      ;;           (file ,(concat gas/org-agenda-directory "templates/weekly_review.org")))
      ;;           ))


      (push '("conf-unix" . conf-unix) org-src-lang-modes)
      (:load-after hl-fill-column
        (:hook (fn (auto-fill-mode 0)
                   (hl-fill-column-mode 0)
                   (visual-line-mode 1)
                   (variable-pitch-mode 1)))))
    ;;   (require 'org)
    ;;   (add-to-list 'org-modules 'org-tempo)
    ;;   (setq org-startup-folded nil
    ;;         org-hide-emphasis-markers nil
    ;;         org-edit-src-content-indentation 0
    ;;         org-confirm-babel-evaluate nil
    ;;         org-support-shift-select 'always)

    ;;   (add-hook 'org-mode-hook 'show-paren-mode)

#+END_SRC

*** Fonts, Bullets & Links
Use bullet characters instead of asterisks, plus set the header font sizes to something more palatable.  A fair amount of inspiration has been taken from [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][this blog post]].

#+begin_src emacs-lisp
   (setup (:require org-indent)
         (:load-after org
           (org-indent-mode 1)
           (:hide-mode)))

   (setup (:pkg org-appear)
         (:load-after org
           (setq org-appear-autolinks t)
           (setq org-appear-autoemphasis t)
           (setq org-appear-autoentities t)
           (setq org-appear-autokeywords t)
           (:hook-into org-mode)))

   (unless IS-TERMUX
     (setup (:pkg org-superstar)
       (:load-after org
         (:option org-superstar-remove-leading-stars t
                  org-superstar-headline-bullets-list '("◉" "○" "●" "○" "●" "○" "●"))
         (:hook-into org-mode)))

         ;; Replace list hyphen with dot
         ;; (font-lock-add-keywords 'org-mode
         ;;                         '(("^ *\\([-]\\) "
         ;;                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

         (setup org-faces
           (:load-after org
             (dolist (face-cons '((org-document-title . 1.75)
                                (org-level-1 . 1.5)
                                (org-level-2 . 1.25)
                                (org-level-3 . 1.12)
                                (org-level-4 . 1.05)
                                (org-level-5 . 1.0)
                                (org-level-6 . 1.0)
                                (org-level-7 . 1.0)
                                (org-level-8 . 1.0)))
             (cl-destructuring-bind (face . height) face-cons
               (set-face-attribute face
                                   nil
                                   :weight 'bold
                                   :font "Iosevka Aile"
                                   :height height)))))

             ;; Ensure that anything that should be fixed-pitch in Org files appears that way
             (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
             (set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
             (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
             (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
             (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
             (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
             (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
             (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
             (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

             ;; Get rid of the background on column views
             (set-face-attribute 'org-column nil :background nil)
             (set-face-attribute 'org-column-title nil :background nil))


         ;; TODO: Others to consider
         ;; '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
         ;; '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
         ;; '(org-property-value ((t (:inherit fixed-pitch))) t)
         ;; '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
         ;; '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
         ;; '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
         ;; '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))
  (setup (:pkg toc-org)
       (:load-after org
         (:hook-into org-mode)))
#+end_src

*** Block Templates
These templates enable you to type things like =<el= and then hit =Tab= to expand
the template.  More documentation can be found at the Org Mode [[https://orgmode.org/manual/Easy-templates.html][Easy Templates]]
documentation page.

#+begin_src emacs-lisp

  ;; This is needed as of Org 9.2
  (setup org-tempo
    (:load-after org
      (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
      (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
      (add-to-list 'org-structure-template-alist '("li" . "src lisp"))
      (add-to-list 'org-structure-template-alist '("cli" . "src common-lisp"))
      (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
      (add-to-list 'org-structure-template-alist '("cl" . "src clojure"))
      (add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
      (add-to-list 'org-structure-template-alist '("py" . "src python"))
      (add-to-list 'org-structure-template-alist '("go" . "src go"))
      (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
      (add-to-list 'org-structure-template-alist '("json" . "src json"))))

#+end_src
Trying to fix weird org syntax problems. This just lets Org ignore < and > characters as if they were regular words. This is necessary because in Clojure I want to make functions with -> in the name and Org was always insisting on pairing <>. This caused any other paren matching to stop working. It sucked.

*** Org Agenda
org-capture provides a generic and extensible interface to capturing things into org-mode in
different formats
#+begin_src emacs-lisp
  (setup org-agenda
   (:load-after org
    (defconst gas-org-agenda-file (concat org-directory "todo.org"))
    (setq org-agenda-files
          '( "~/org/todo.org" "~/work/work.org.gpg" ;;"~/org/roam/"
             ))
    (setq-default
     org-tag-alist
     (quote (("@errand"     . ?e)
             ("@bureau"    . ?o)
             ("@maison"    . ?h)
             ("important"  . ?i)
             ("urgent"     . ?u)

             (:newline)
             ("ATTENDRE"  . ?w)
             ("SUSPENDUÉ" . ?h)
             ("ANNULÉ"    . ?c)
             ("RÉUNION"   . ?m)
             ("TÉLÉPHONE" . ?p)
             ("french"    . ?f)
             ("spanish"   . ?s))))

    (setq  org-highest-priority ?A
           org-default-priority ?C
           org-lowest-priority  ?D)
    (setq org-agenda-custom-commands
          (quote
           (("N" "Notes" tags "NOTE"
             ((org-agenda-overriding-header "Notes")
              (org-tags-match-list-sublevels t)))
            ("h" "Habitudes" tags-todo "STYLE=\"habit\""
             ((org-agenda-overriding-header "Habitudes")
              (org-agenda-sorting-strategy
               '(todo-state-down priority-down category-keep))))
            ("e" "Eisenhower Matrix"
             ((agenda
               ""
               ((org-agenda-overriding-header "Calendrier Eisenhower:")
                (org-agenda-show-log t)
                (org-agenda-log-mode-items '(clock state))
                (org-agenda-category-filter-preset '("-Habitudes"))
                (org-agenda-span 5)
                (org-agenda-start-on-weekday t)
                ;;            (org-agenda-ndays 5)
                ;;            (org-agenda-start-day "-2d")
                (org-deadline-warning-days 30)))
              (tags-todo  "+important+urgent\!FINI"
                          ((org-agenda-overriding-header "Tâches importantes et urgentes")
                           (org-tags-match-list-sublevels nil)))
              (tags-todo  "+important-urgent"
                          ((org-agenda-overriding-header "Tâches importantes mais non urgentes")
                           (org-tags-match-list-sublevels nil)))
              (tags-todo "-important+urgent"
                         ((org-agenda-overriding-header "Tâches urgentes mais sans importance")
                          (org-tags-match-list-sublevels nil)))
              (tags-todo "-important-urgent/!TODO"
                         ((org-agenda-overriding-header "Tâches non importantes ni urgentes")
                          (org-agenda-category-filter-preset '("-Habitudes"))
                          (org-tags-match-list-sublevels nil)))
              (tags-todo "VALUE"
                         ((org-agenda-overriding-header "Valeurs")
                          (org-tags-match-list-sublevels nil)))
              ))
            (" " "Agenda"
             ((agenda ""
                      ((org-agenda-overriding-header "Calendrier d'aujourd'hui:")
                       (org-agenda-show-log t)
                       (org-agenda-log-mode-items '(clock state))
                       ;;   (org-agenda-span 'day)
                       ;;   (org-agenda-ndays 3)
                       (org-agenda-start-on-weekday nil)
                       (org-agenda-start-day "-d")
                       (org-agenda-todo-ignore-deadlines nil)))
              (tags-todo "+important"
                         ((org-agenda-overriding-header "Tâches Importantes à Venir")
                          (org-tags-match-list-sublevels nil)))
              (tags-todo "-important"
                         ((org-agenda-overriding-header "Tâches de Travail")
                          (org-agenda-category-filter-preset '("-Habitudes"))
                          (org-agenda-sorting-strategy
                           '(todo-state-down priority-down))))
              (tags "REFILE"
                    ((org-agenda-overriding-header "Tâches à la Représenter")
                     (org-tags-match-list-sublevels nil)))))
            )))))
#+end_src
*** Org Roam
#+begin_src emacs-lisp

  (defvar dw/org-roam-project-template
    '("p" "projet" plain "** TODO %?"
      :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                             "#+title: ${title}\n#+category: ${title}\n#+filetags: Projet\n"
                             ("Tasks"))))

  (defun my/org-roam-filter-by-tag (tag-name)
    (lambda (node)
      (member tag-name (org-roam-node-tags node))))

  (defun my/org-roam-list-notes-by-tag (tag-name)
    (mapcar #'org-roam-node-file
            (seq-filter
             (my/org-roam-filter-by-tag tag-name)
             (org-roam-node-list))))

  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (push arg args))
          (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                    '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))

  (defun dw/org-roam-goto-month ()
    (interactive)
    (org-roam-capture- :goto (when (org-roam-node-from-title-or-alias (format-time-string "%Y-%B")) '(4))
                       :node (org-roam-node-create)
                       :templates '(("m" "month" plain "\n* Goals\n\n%?* Summary\n\n"
                                     :if-new (file+head "%<%Y-%B>.org"
                                                        "#+title: %<%Y-%B>\n#+filetags: Projet\n")
                                     :unnarrowed t))))

  (defun dw/org-roam-goto-year ()
    (interactive)
    (org-roam-capture- :goto (when (org-roam-node-from-title-or-alias (format-time-string "%Y")) '(4))
                       :node (org-roam-node-create)
                       :templates '(("y" "year" plain "\n* Goals\n\n%?* Summary\n\n"
                                     :if-new (file+head "%<%Y>.org"
                                                        "#+title: %<%Y>\n#+filetags: Projet\n")
                                     :unnarrowed t))))

  (defun dw/org-roam-capture-task ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Capture the new task, creating the project file if necessary
    (org-roam-capture- :node (org-roam-node-read
                              nil
                              (my/org-roam-filter-by-tag "Projet"))
                       :templates (list dw/org-roam-project-template)))

  (defun my/org-roam-refresh-agenda-list ()
    (interactive)
    (setq org-agenda-files (my/org-roam-list-notes-by-tag "Projet")))

  (defhydra dw/org-roam-jump-menu (:hint nil)
    "
  ^Dailies^        ^Capture^       ^Jump^
  ^^^^^^^^-------------------------------------------------
  _t_: today       _T_: today       _m_: current month
  _r_: tomorrow    _R_: tomorrow    _e_: current year
  _y_: yesterday   _Y_: yesterday   ^ ^
  _d_: date        ^ ^              ^ ^
  "
    ("t" org-roam-dailies-goto-today)
    ("r" org-roam-dailies-goto-tomorrow)
    ("y" org-roam-dailies-goto-yesterday)
    ("d" org-roam-dailies-goto-date)
    ("T" org-roam-dailies-capture-today)
    ("R" org-roam-dailies-capture-tomorrow)
    ("Y" org-roam-dailies-capture-yesterday)
    ("m" dw/org-roam-goto-month)
    ("e" dw/org-roam-goto-year)
    ("c" nil "cancel"))

  (setup (:pkg org-roam)
    (setq org-roam-v2-ack t)
    (setq dw/daily-note-filename "%<%Y-%m-%d>.org"
          dw/daily-note-header "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")

    (:when-loaded
      (org-roam-db-autosync-mode)
      (my/org-roam-refresh-agenda-list))

    (:option
     org-roam-directory "~/org/roam/"
     org-roam-dailies-directory "journal/"
     org-roam-completion-everywhere t
     org-roam-capture-templates
     '(("d" "default" plain "%?"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                           "#+title: ${title}\n")
        :unnarrowed t))
     org-roam-dailies-capture-templates
     `(("d" "default" entry
        "* %?"
        :if-new (file+head ,dw/daily-note-filename
                           ,dw/daily-note-header))
       ("t" "task" entry
        "* TODO %?\n  %U\n  %a\n  %i"
        :if-new (file+head+olp ,dw/daily-note-filename
                               ,dw/daily-note-header
                               ("Tasks"))
        :empty-lines 1)
       ("l" "log entry" entry
        "* %<%I:%M %p> - %?"
        :if-new (file+head+olp ,dw/daily-note-filename
                               ,dw/daily-note-header
                               ("Log")))
       ("j" "journal" entry
        "* %<%I:%M %p> - Journal  :journal:\n\n%?\n\n"
        :if-new (file+head+olp ,dw/daily-note-filename
                               ,dw/daily-note-header
                               ("Log")))
       ("m" "meeting" entry
        "* %<%I:%M %p> - %^{Meeting Title}  :meetings:\n\n%?\n\n"
        :if-new (file+head+olp ,dw/daily-note-filename
                               ,dw/daily-note-header
                               ("Log")))))
    (:global "C-c n l" org-roam-buffer-toggle
             "C-c n f" org-roam-node-find
             "C-c n d" dw/org-roam-jump-menu/body
             "C-c n c" org-roam-dailies-capture-today
             "C-c n t" dw/org-roam-capture-task
             "C-c n g" org-roam-graph)
    (:bind "C-c n i" org-roam-node-insert
           "C-c n I" org-roam-insert-immediate))


#+end_src

*** angle-bracket-hack
#+begin_src elisp
(defun my-angle-bracket-fix ()
  (modify-syntax-entry ?< "w")
  (modify-syntax-entry ?> "w"))

(add-hook 'org-mode-hook 'my-angle-bracket-fix)
#+end_src

** Coding Settings
I mostly use Clojure and Clojurescript, so they're setup inheriting from LISP setup
*** LISP
Setup smartparens and rainbow delimiters
#+begin_src emacs-lisp :noweb-ref code-lisp
  (setup (:pkg rainbow-delimiters)
    (setq rainbow-delimiters-max-face-count 2)
    (:hook-into emacs-lisp-mode-hook
                eval-expression-minibuffer-setup-hook
                ielm-mode-hook
                lisp-interaction-mode-hook
                lisp-mode-hook
                sly-mrepl-mode-hook
                clojure-mode-hook)
    (:hide-mode))

  (setup (:pkg smartparens)
  (:require smartparens)
  (setq sp-cancel-autoskip-on-backward-movement nil)
  (setq sp-highlight-pair-overlay nil)
  (setq sp-highlight-wrap-overlay nil)
  (setq sp-highlight-wrap-tag-overlay nil)
  (setq sp-max-pair-length 2)
  (setq sp-max-prefix-length 32)
  (setq sp-message-width nil)
  (setq sp-navigate-consider-sgml-tags nil)
  (setq sp-navigate-skip-match nil)
  (setq sp-show-pair-from-inside t)
  (sp-pair "'" nil :actions :rem)
  (sp-pair "`" nil :actions :rem)
  (sp-pair "(" nil :unless '(:rem sp-point-before-word-p))
  (:with-hook (emacs-lisp-mode-hook
               eval-expression-minibuffer-setup-hook
               ielm-mode-hook
               lisp-interaction-mode-hook
               lisp-mode-hook
               sly-mrepl-mode-hook
               clojure-mode-hook
               clojurescript-mode-hook
               cider-repl-mode-hook)
    (:hook smartparens-strict-mode))
  (:hide-mode))
#+end_src
*** Emacs Lisp
ielm setup
#+begin_src emacs-lisp :noweb-ref code-elisp
(setup elisp-mode
 ;; (define-local-keys emacs-lisp-mode-map
 ;;   "'" '(ielm :wk "ielm"))
  (:with-mode (emacs-lisp-mode lisp-interaction-mode)
    (:bind
     "C-c C-c" eval-defun))
  (:with-mode emacs-lisp-mode
    (:advise eval-region :around (fn beg end &rest args)
      (let ((pulse-flag t))
        (pulse-momentary-highlight-region beg end))
      (apply fn beg end args))))

(setup (:pkg elisp-slime-nav)
  (:load-after ielm
    (:hook-into emacs-lisp-mode ielm-mode)
    (:hide-mode)))

(setup (:pkg ielm)
  (:load-after comint
    (:with-map ielm-map
      (:bind
       [up] comint-previous-input
       [down] comint-next-input))))

(setup (:pkg macrostep)
    (:with-map macrostep-keymap
      (:bind
       [tab] macrostep-next-macro
       [backtab] macrostep-prev-macro
       "c" macrostep-collapse
       "e" macrostep-expand
       "q" macrostep-collapse-all))
   (:hide-mode))
#+end_src
*** Common LISP
SLY setup
#+begin_src emacs-lisp :noweb-ref code-common-lisp
  (defun mf/sly-ask ()
    (interactive)
    (let ((current-prefix-arg '-))
      (sly nil nil t)))

  (setup (:pkg sly)
    (:when-loaded
      (sly-setup '(sly-fancy)))
    (setq sly-command-switch-to-existing-lisp 'always)
    (setq sly-complete-symbol-function 'sly-flex-completions)
    (setq sly-enable-evaluate-in-emacs t)
    (setq sly-kill-without-query-p t)
    (setq sly-mrepl-history-file-name (enfer/etc-file "sly-repl-history"))
    (setq sly-mrepl-pop-sylvester nil)
    (setq sly-mrepl-prevent-duplicate-history 'move)
    (setq sly-net-coding-system 'utf-8-unix)
    (:hide-mode))

#+end_src
*** Clojure
Editing Clojure / Clojurescript code is best done using a REPL, which is provided with the cider package.
Cider has a lot of options to customise, and here are the ones I think are most critical.
Source comes from: [[https://stackoverflow.com/a/31080940]]
#+BEGIN_SRC elisp :noweb-ref code-clojure

   (setup (:pkg cider)
     (:when-loaded
       (setq nrepl-hide-special-buffers t
             cider-repl-clear-help-banner t
             cider-font-lock-dynamically nil
             cider-popup-stacktraces nil
             cider-repl-popup-stacktraces t
             cider-repl-use-pretty-printing t
             cider-repl-pop-to-buffer-on-connect t
             cider-repl-display-help-banner nil)
       (:with-hook clojure-mode-hook)
       (:hook eldoc-mode)))

   ;; Allow cider-repl to be cleared with shortcut
   ;;(add-hook 'cider-repl-mode-hook
   ;;;          '(lambda () (define-key cider-repl-mode-map (kbd "C-c M-b")
   ;                        'cider-repl-clear-buffer)))

  ;; (add-hook 'cider-mode-hook (lambda () (show-paren-mode 1)))
  ;; (add-hook 'cider-mode-hook #'eldoc-mode)

   ;;(add-hook 'cider-repl-mode-hook #'enable-paredit-mode)
   ;;(add-hook 'cider-mode-hook #'imenu-add-menubar-index)

  (setup (:pkg clojure-mode))
  (setup (:pkg async))
  (setup (:pkg ob-async))
  (setup (:pkg ob-clojurescript))
  ;;(setup (:pkg ob-babel-eval-in-repl))
  (setup (:pkg eval-in-repl))

#+END_SRC


**** clj templates
Insertion templates can be used to speed up project setups. This is code of my own creation, so use at your own risk. The template files are in ~.emacs.d/templates/lib.org~.

***** slurp
#+BEGIN_SRC elisp
(defun slurp (file)
  (with-temp-buffer
    (insert-file-contents file)
    (buffer-substring-no-properties
     (point-min)
     (point-max))))

#+END_SRC

***** template-reader
#+begin_src elisp
(defun template-reader (file replace)
  (let ((lines (split-string (slurp file) "\n")))
    (->> lines
         (mapcar (lambda (x) (replace-regexp-in-string "_str_" replace x)))
         (mapcar (lambda (x) (concat x "\n")))
         (-concat)
         (apply 'concat))))

#+end_src

***** clj-org-templates
I use org mode and literate programming ideas to build my clj/cljs projects. So, it is helpful to have skeletons that take .org template files that tangle into a nice clojure project setup. Currently I only have one template, but the idea is to be able to have a few which you just bind to different keys as needed. The idea is demonstrated with 'Project' and 'Library'.

#+BEGIN_SRC elisp :tangle no
(define-skeleton cljc-lib-skeleton
  "Inserts a .org template with user's project name input.
   Use in empty file and save to desired project directory.
   Tangle will create project structure on save."
  ""
  (template-reader "~/.config/emacs/templates/lib.org" (skeleton-read "Library name: ")))

(define-skeleton cljc-project-skeleton
  "Inserts a .org template with user's project name input.
   Use in empty file and save to desired project directory.
   Tangle will create project structure on save."
  ""
  (template-reader "~/.emacs.d/templates/lib.org" (skeleton-read "Project name: ")))

;;(global-set-key (kbd "C-S-L") 'cljc-lib-skeleton)
;;(global-set-key (kbd "C-S-P") 'cljc-project-skeleton)

#+END_SRC

* Keybindings
:PROPERTIES:
:header-args: :noweb-ref keybindings
:END:
Change the Mac modifiers to my liking. I also disable passing Control characters to the system, to avoid that C-M-space launches the Character viewer instead of running mark-sexp.
#+begin_src emacs-lisp
(cond (IS-MAC
       (setq mac-command-modifier      'meta
              mac-option-modifier         'alt
              mac-right-option-modifier   'alt
              mac-pass-control-to-system nil)))
#+end_src
When at the beginning of the line, make Ctrl-K remove the whole line, instead of just emptying it.
#+begin_src emacs-lisp
(setq kill-whole-line t)
#+end_src
**** Emulating Vi's % key
One of the few things I missed in Emacs from vi was the % key, which jumps to the parenthesis, bracket or brace which matches the one below the cursor. This function implements this functionality, bound to the same key. Inspired by NavigatingParentheses, but modified to use smartparens instead of the default commands, and to work on brackets and braces.
#+begin_src emacs-lisp
        (setup
          (:pkg smartparens)
          (defun zz/goto-match-paren (arg)
            "Go to the matching paren/bracket, otherwise (or if ARG is not
            nil) insert %.  vi style of % jumping to matching brace."
            (interactive "p")
            (if (not (memq last-command '(set-mark
                                          cua-set-mark
                                          zz/goto-match-paren
                                          down-list
                                          up-list
                                          end-of-defun
                                          beginning-of-defun
                                          backward-sexp
                                          forward-sexp
                                          backward-up-list
                                          forward-paragraph
                                          backward-paragraph
                                          end-of-buffer
                                          beginning-of-buffer
                                          backward-word
                                          forward-word
                                          mwheel-scroll
                                          backward-word
                                          forward-word
                                          mouse-start-secondary
                                          mouse-yank-secondary
                                          mouse-secondary-save-then-kill
                                          move-end-of-line
                                          move-beginning-of-line
                                          backward-char
                                          forward-char
                                          scroll-up
                                          scroll-down
                                          scroll-left
                                          scroll-right
                                          mouse-set-point
                                          next-buffer
                                          previous-buffer
                                          previous-line
                                          next-line
                                          back-to-indentation
                                          )))
                (self-insert-command (or arg 1))
              (cond ((looking-at "\\s\(") (sp-forward-sexp) (backward-char 1))
                    ((looking-at "\\s\)") (forward-char 1) (sp-backward-sexp))
                    (t (self-insert-command (or arg 1)))))
          )
          (:global "%" 'zz/goto-match-paren))
#+end_src

* Maybe to applied - not tangled at present
#+begin_src elisp :tangle no

  ;; enable line-numbers
   (column-number-mode)

   ;; Enable line numbers for some modes
   (dolist (mode '(text-mode-hook
                   prog-mode-hook
                   conf-mode-hook))
     (add-hook mode (lambda () (display-line-numbers-mode 1))))

   ;; Override some modes which derive from the above
   (dolist (mode '(org-mode-hook))
     (add-hook mode (lambda () (display-line-numbers-mode 0))))
   ;;undo
   (setup (:pkg undo-tree)
     (:hide-mode)
     (setq undo-tree-auto-save-history nil)
     (global-undo-tree-mode 1))

    ;; matching braces
  (setup (:require paren)
    (set-face-attribute 'show-paren-match-expression nil :background "#363e4a")
    (show-paren-mode 1))
#+end_src


* Tangling config noweb
** Header & disclaimer
:PROPERTIES:
:header-args: :noweb-ref disclaimer
:END:

#+begin_src emacs-lisp
  ;; Copyright (C) 2021 Gas

  ;; Author: Gas <gas@tuatara.red>
  ;; Created: Sometime during the Covid-19 lockdown
  ;; Keywords: configuration, emacs
  ;; URL: https://github.com/frap/emacs.d

  ;; This file is not part of GNU Emacs.

  ;;; Commentary:
  ;; This file is automatically tangled from config.org.
  ;; Hand edits will be overwritten!
  ;; Je t'ai prévenu putain!

#+end_src
** My Utility fns constants and macros
:PROPERTIES:
:header-args: :tangle lisp/enfer-util.el :noweb yes
:END:

File for my constants, macros and functions

*** Contents enfer-util

#+begin_src emacs-lisp
  ;;; enfer-util.el -*- lexical-binding: t -*-
     <<disclaimer>>
  ;;; Code:

  ;;; ============================================================================
  ;;; Constants
  ;;;
    <<constants>>
  ;;; ============================================================================
  ;;; Variables
  ;;;
    <<variables>>

 ;;; ============================================================================
 ;;; Macros
 ;;; ============================================================================

   <<macros>>

  ;;; ============================================================================
  ;;; Functions
  ;;; ============================================================================

  <<functions>>
  (provide 'enfer-util)
  ;;; enfer-util.el ends here
#+end_src

** Emacs setup package manager and configurator setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkgmgr.el :noweb yes
:END:

"Setup" of setup.el the emacs package manager and package setup to replace use-package

*** Contents enfer-setup

#+begin_src emacs-lisp
  ;;; enfer-pkgmgr.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  ;; Install setup.el. We use this to concisely perform repetitive tasks, such as
  ;; installing and loading packages.
  <<setup-pkgmgr>>

  ;;; ============================================================================
  ;;; Custom setup.el local macros
  ;;; ============================================================================

   <<setup-macros>>

  (provide 'enfer-pkgmgr)
   ;;; enfer-pkgmgr.el ends here
#+end_src
** Emacs Sanity setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-emacs-sanity.el :noweb yes
:END:

"Setup" of Emacs to some sort of sanity

*** Contents enfer-emacs-sanity

#+begin_src emacs-lisp
     ;;; enfer-emacs-sanity.el -*- lexical-binding: t -*-
     <<disclaimer>>
     ;;; Code:

    (setup appearance
    (setq blink-matching-paren nil)
    (setq display-time-default-load-average nil)
    (setq echo-keystrokes 0.1)
    (setq highlight-nonselected-windows nil)
    (setq idle-update-delay 1.0)
    (setq inhibit-startup-echo-area-message t)
    (setq inhibit-startup-screen t)
    (setq use-dialog-box nil)
    (setq use-file-dialog nil)
    (setq visible-bell nil)
    (setq x-gtk-use-system-tooltips nil)
    (setq x-stretch-cursor nil)
    (setq-default bidi-display-reordering 'left-to-right)
    (setq-default bidi-paragraph-direction 'left-to-right)
    (setq-default cursor-in-non-selected-windows nil)
    (setq-default cursor-type 'hbar)
    (setq-default display-line-numbers-widen t)
    (setq-default display-line-numbers-width 3)
    (setq-default indicate-buffer-boundaries nil)
    (setq-default truncate-lines t)
    (:with-hook (prog-mode-hook text-mode-hook conf-mode-hook)
      (:hook display-line-numbers-mode))
    (:with-hook text-mode-hook
      (:hook visual-line-mode)))

  (setup encoding
    (setq coding-system-for-read 'utf-8-unix)
    (setq coding-system-for-write 'utf-8-unix)
    (setq default-process-coding-system '(utf-8-unix utf-8-unix))
    (setq locale-coding-system 'utf-8-unix)
    (setq selection-coding-system 'utf-8)
    (setq x-select-request-type nil)
    (setq-default buffer-file-coding-system 'utf-8-unix)
    (prefer-coding-system 'utf-8-unix)
    (set-clipboard-coding-system 'utf-8)
    (set-default-coding-systems 'utf-8-unix)
    (set-keyboard-coding-system 'utf-8-unix)
    (set-language-environment "UTF-8")
    (set-selection-coding-system 'utf-8)
    (set-terminal-coding-system 'utf-8-unix))

  (setup files
    (setq auto-mode-case-fold nil)
    (setq auto-save-default nil)
    (setq auto-save-list-file-prefix nil)
    (setq backup-inhibited t)
    (setq create-lockfiles nil)
    (setq delete-by-moving-to-trash nil)
    (setq find-file-suppress-same-file-warnings t)
    (setq find-file-visit-truename t)
    (setq load-prefer-newer t)
    (setq make-backup-files nil)
    (setq require-final-newline t)
    (setq vc-follow-symlinks t))

  (setup minibuffer
    (file-name-shadow-mode 1)
    (minibuffer-depth-indicate-mode 1)
    (minibuffer-electric-default-mode 1)
    (fset #'yes-or-no-p #'y-or-n-p)
    (setq enable-recursive-minibuffers t)
    (setq file-name-shadow-properties '(invisible t intangible t))
    (setq minibuffer-eldef-shorten-default t)
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (setq read-answer-short t)
    (setq read-extended-command-predicate #'command-completion-default-include-p)
    (setq use-short-answers t)
    (:with-hook minibuffer-setup-hook
      (:hook cursor-intangible-mode)))

  (setup misc
    (setq ad-redefinition-action 'accept)
    (setq bidi-inhibit-bpa t)
    (setq command-line-ns-option-alist nil)
    (setq confirm-kill-processes nil)
    (setq custom-file (enfer/etc-file "custom.el"))
    (setq default-input-method "TeX")
    (setq ffap-machine-p-known 'reject)
    (setq inhibit-compacting-font-caches t)
    (setq inhibit-default-init t)
    (setq jit-lock-defer-time nil)
    (setq jka-compr-verbose nil)
    (setq native-comp-async-report-warnings-errors nil)
    (setq read-file-name-completion-ignore-case t)
    (setq read-process-output-max (* 64 1024))
    (setq redisplay-skip-fontification-on-input t)
    (setq ring-bell-function 'ignore)
    (setq-default fill-column 100)
    (setq-default lexical-binding t))

  (setup mouse
    (setq focus-follows-mouse t)
    (setq make-pointer-invisible t)
    (setq mouse-1-click-follows-link t)
    (setq mouse-autoselect-window t)
    (setq mouse-wheel-follow-mouse t)
    (setq mouse-wheel-progressive-speed nil)
    (setq mouse-wheel-scroll-amount '(3 ((shift) . hscroll)))
    (setq mouse-wheel-scroll-amount-horizontal 2)
    (setq mouse-yank-at-point t))

  (setup scratch
    (setq initial-major-mode 'fundamental-mode)
    (setq initial-scratch-message nil))

  (setup scrolling
    (setq auto-hscroll-mode 'current-line)
    (setq auto-window-vscroll nil)
    (setq fast-but-imprecise-scrolling t)
    (setq hscroll-margin 16)
    (setq hscroll-step 1)
    (setq scroll-conservatively 101)
    (setq scroll-margin 8)
    (setq scroll-preserve-screen-position t)
    (setq scroll-step 1))

  (setup selection
    (setq kill-do-not-save-duplicates t)
    (setq select-enable-clipboard t)
    (setq select-enable-primary t)
    (setq x-select-enable-clipboard-manager nil))

  (setup windows
    (setq split-height-threshold nil)
    (setq split-width-threshold 160)
    (setq window-divider-default-bottom-width 2)
    (setq window-divider-default-places t)
    (setq window-divider-default-right-width 2)
    (setq window-resize-pixelwise nil))

  (setup whitespace
    (setq backward-delete-char-untabify-method 'hungry)
    (setq next-line-add-newlines nil)
    (setq sentence-end-double-space nil)
    (setq-default indent-tabs-mode nil)
    (setq-default indicate-empty-lines nil)
    (setq-default tab-always-indent nil)
    (setq-default tab-width 4)
    (:with-hook before-save-hook
      (:hook delete-trailing-whitespace)))

    <<user-config>>

    (provide 'enfer-emacs-sanity)
    ;;; enfer-emacs-sanity.el ends here
#+end_src

** Emacs Startup enhancements and GC
:PROPERTIES:
:header-args: :tangle lisp/enfer-emacs-startup.el :noweb yes
:END:

Setup auto-compile, no littering and GMCH

*** Contents enfer-emacs-startup

#+begin_src emacs-lisp
  ;;; enfer-emacs-startup.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<emacs-setup>>

  (provide 'enfer-emacs-startup)
   ;;; enfer-emacs-startup.el ends here
#+end_src
** Emacs Builtins
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-builtin.el :noweb yes
:END:

Setup Emacs builtins

*** Contents enfer-pkg-builtin

#+begin_src emacs-lisp
      ;;; enfer-pkg-builtin.el -*- lexical-binding: t -*-
      <<disclaimer>>
      ;;; Code:

     (setup auto-fill
      (:with-feature simple
        (:with-mode (text-mode org-mode)
          (:hook turn-on-auto-fill))
        (:with-mode prog-mode
          (:hook (fn (setq-local comment-auto-fill-only-comments t)
                     (auto-fill-mode 1))))
        (:hide-mode auto-fill-function)))

    (setup (:require autorevert)
      (setq auto-revert-check-vc-info t)
      (setq auto-revert-remote-files t)
      (setq global-auto-revert-non-file-buffers t)
      (setq auto-revert-verbose nil)
      (global-auto-revert-mode 1)
      (:hide-mode auto-revert))

    (setup comint
      (setq ansi-color-for-comint-mode t)
      (setq comint-buffer-maximum-size 4096)
      (setq comint-prompt-read-only t))

    (setup compile
      (setq compilation-always-kill t)
      (setq compilation-ask-about-save nil)
      (setq compilation-scroll-output 'first-error))

    (setup (:require delsel)
      (delete-selection-mode 1))

    (setup dired
      (:also-load dired-x)
      (:pkg dired-collapse
            dired-git-info
            dired-single
            dired-subtree
            diredfl)
      (:with-map dired-mode-map
        (:bind
         [tab] dired-subtree-cycle
         "i" dired-subtree-toggle
         "q" quit-window))
      (:hook dired-collapse-mode)
      (setq dired-recursive-copies 'top)
      (setq dired-recursive-deletes 'top)
      (diredfl-global-mode 1))

    (setup (:require eldoc)
      (setq eldoc-echo-area-use-multiline-p nil)
      (setq eldoc-idle-delay 0.1)
      (:with-mode prog-mode
        (:hook turn-on-eldoc-mode))
      (:hide-mode))

    (setup (:require elec-pair)
      (electric-pair-mode 1))

    (setup executable
      (setq executable-prefix-env t)
      (:with-hook after-save-hook
        (:hook executable-make-buffer-file-executable-if-script-p)))

  (setup ispell
    :if (not (bound-and-true-p disable-pkg-ispell))
    :defer 15
    :config
    (progn
      (cond
       ((executable-find "aspell")
        (setq ispell-program-name "aspell")
        (setq ispell-extra-args   '("--sug-mode=ultra"
                                    "--lang=en_NZ")))
       ((executable-find "hunspell")
        (setq ispell-program-name "hunspell")
        (setq ispell-extra-args   '("-d en_NZ"))))

      ;; Save a new word to personal dictionary without asking
      (setq ispell-silently-savep t)))

    (setup flyspell
      (:hook-into text-mode-hook)
      (:when-loaded
        (:hide-mode)))

    (setup (:require goto-addr)
      (:with-mode prog-mode
        (:hook goto-address-prog-mode))
      (:with-mode text-mode
        (:hook goto-address-mode)))

    (setup (:require help-mode)
      (setq help-window-select t))

    (setup (:require recentf)
      (setq recentf-auto-cleanup 'mode)
      (setq recentf-exclude `(,#'enfer/cache-dir-p
                              "^/tmp/"
                              "COMMIT_EDITMSG$"
                              ".gz$"))
      (setq recentf-filename-handlers '(abbreviate-file-name))
      (setq recentf-max-menu-items 100)
      (setq recentf-max-saved-items nil)
      (recentf-mode 1)
      (run-at-time nil 120 (fn (quiet! (recentf-save-list))))
      (:with-hook kill-emacs-hook
        (:hook recentf-cleanup recentf-save-list)))

    (setup (:require savehist)
      (setq history-delete-duplicates t)
      (setq history-length t)
      (setq savehist-additional-variables
            '(extended-command-history
              global-mark-ring
              kill-ring
              mark-ring
              regexp-search-ring
              search-ring))
      (setq savehist-autosave-interval 60)
      (setq savehist-file (enfer/etc-file "history"))
      (setq savehist-save-minibuffer-history t)
      (savehist-mode 1))

    (setup (:require saveplace)
      (setq save-place-file (enfer/etc-file "places"))
      (setq save-place-forget-unreadable-files nil)
      (save-place-mode 1))

    (setup (:require server)
      (unless (server-running-p)
        (server-start)))

    (setup (:require subword)
      (global-subword-mode 1)
      (:hide-mode))

    (setup (:require uniquify)
      (setq uniquify-after-kill-buffer-p t)
      (setq uniquify-buffer-name-style 'forward))

    (setup (:require url)
      (setq url-cookie-file (enfer/etc-file "url-cookies")))

    (setup (:require visual-line-mode)
      (:hide-mode))

      (provide 'enfer-pkg-builtin)
       ;;; enfer-pkg-builtin.el ends here
#+end_src
** Utility package
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-util.el :noweb yes
:END:

Setup utility packages

*** Contents enfer-pkg-util

#+begin_src emacs-lisp
  ;;; enfer-pkg-util.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-utils>>

  (provide 'enfer-pkg-util)
   ;;; enfer-pkg-util.el ends here
#+end_src
** Emacs UI Appearance
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-ui.el :noweb yes
:END:

Setup

*** Contents enfer-pkg-ui

#+begin_src emacs-lisp
  ;;; enfer-pkg-ui.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-ui>>

  (provide 'enfer-pkg-ui)
   ;;; enfer-pkg-ui.el ends here
#+end_src
** Emacs Editor Setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-editor.el :noweb yes
:END:

Setup Editor functions

*** Contents enfer-pkg-editor

#+begin_src emacs-lisp
  ;;; enfer-pkg-editor.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-editor>>

  (provide 'enfer-pkg-editor)
   ;;; enfer-pkg-editor.el ends here
#+end_src
** Emacs Completion Frameworks
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-completion.el :noweb yes
:END:

Setup embark, vertico and consult

*** Contents enfer-pkg-completion

#+begin_src emacs-lisp
  ;;; enfer-pkg-completion.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-completion>>

  (provide 'enfer-pkg-completion)
   ;;; enfer-pkg-completion.el ends here
#+end_src
** Emacs Windows
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-window.el :noweb yes
:END:

windose

*** Contents enfer-pkg-window

#+begin_src emacs-lisp
  ;;; enfer-pkg-window.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-window>>

  (provide 'enfer-pkg-window)
   ;;; enfer-pkg-window.el ends here
#+end_src
** Projects
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-project.el :noweb yes
:END:

Setup projects

*** Contents enfer-pkg-project

#+begin_src emacs-lisp
  ;;; enfer-pkg-project.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-project>>

  (provide 'enfer-pkg-project)
   ;;; enfer-pkg-project.el ends here
#+end_src
** Org mode workflow
:PROPERTIES:
:header-args: :tangle lisp/enfer-pkg-org.el :noweb yes
:END:

Setup org-mode

*** Contents enfer-pkg-org

#+begin_src emacs-lisp
  ;;; enfer-pkg-org.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<pkg-org>>

  (provide 'enfer-pkg-org)
   ;;; enfer-pkg-org.el ends here
#+end_src
** Coding
Setup Coding languages

*** LISP setup
Smartparens setup here
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-lisp.el :noweb yes
:END:
#+begin_src emacs-lisp
  ;;; enfer-code-lisp.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-lisp>>

  (provide 'enfer-code-lisp)
   ;;; enfer-code-lisp.el ends here
#+end_src
*** Emacs-lisp setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-elisp.el :noweb yes
:END:
#+begin_src emacs-lisp
  ;;; enfer-code-elisp.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-elisp>>

  (provide 'enfer-code-elisp)
   ;;; enfer-code-elisp.el ends here
#+end_src
*** Common LISP setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-common-lisp.el :noweb yes
:END:
#+begin_src emacs-lisp
  ;;; enfer-code-common-lisp.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-common-lisp>>

  (provide 'enfer-code-common-lisp)
   ;;; enfer-code-common-lisp.el ends here
#+end_src
*** Clojure setup
:PROPERTIES:
:header-args: :tangle lisp/enfer-code-clojure.el :noweb yes
:END:
#+begin_src emacs-lisp
  ;;; enfer-code-clojure.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<code-clojure>>

  (provide 'enfer-code-clojure)
   ;;; enfer-code-clojure.el ends here
#+end_src

** Keybindings
:PROPERTIES:
:header-args: :tangle lisp/enfer-key-bindings.el :noweb yes
:END:
#+begin_src emacs-lisp
  ;;; enfer-key-bindings.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:

  <<keybindings>>

  (provide 'enfer-key-bindings)
   ;;; enfer-key-bindings.el ends here
#+end_src
** config.el
:PROPERTIES:
:header-args: :tangle config.el :noweb yes
:END:

While =config.el= is written above, I use Noweb references to tangle
them all together in the following block, which enables me to organise
my config here /logically/, while keeping the generated file organised
/programmatically/.

*** Enable lexical binding

#+begin_src emacs-lisp
  ;;; config.el --- personal configuration -*- lexical-binding: t -*-
#+end_src


*** The rest

#+begin_src emacs-lisp
  <<disclaimer>>
  ;;; Code:

  ;;; REQUIRES
  <<requires>>

  ;;; CONSTANTS
  <<constants>>

  ;;; VARIABLES
  <<variables>>

  ;;; FUNCTIONS
  <<functions>>

  ;;; PACKAGE SETUP
  <<pkg-setup>>

  ;;; EMACS SANITY SETTINGS
  <<sanity>>

  ;;; UI
  <<UI>>

  ;;; EDITOR WORKFLOW
  <<editor>>

  ;;; CODING
  <<coding>>

  ;;; SYSTEM-DEPENDENT SETTINGS
  ;; at home
  (eval-and-compile
    (when (memq system-type '(gnu gnu/linux darwin))
      <<linux-specific>>
      ))

  ;; at work
  (eval-and-compile
    (when (memq system-type '(ms-dos windows-nt))
      <<windows-specific>>
      ))

  ;;; MODES
  <<modes>>

  ;;; HOOKS
  <<hooks>>

  ;;; BINDINGS
  <<bindings>>
  ;;; config.el ends here
#+end_src
*** Ease of editing
:PROPERTIES:
:header-args: :tangle no
:END:

#+begin_src emacs-lisp :noweb-ref functions
  (defun enfer/find-config ()
    "Find `config.org'."
    (interactive)
    (find-file (locate-user-emacs-file "config.org")))
#+end_src

Bind it to =C-z i= because =C-z C-c= is taken for capture.

#+begin_src emacs-lisp :noweb-ref bindings
(define-key acdw/leader (kbd "i") #'acdw/find-config)
#+end_src

*** Ease of reloading
:PROPERTIES:
:header-args: :tangle no
:END:

#+begin_src emacs-lisp :noweb-ref functions
  (defun acdw/reload ()
    "Tangle and reload Emacs configuration."
    (interactive)
    (let ((config (locate-user-emacs-file "config.org")))
      ;; tangle
      (with-current-buffer (find-file-noselect config)
        (message "Tangling config.org...")
        (let ((prog-mode-hook nil)
              (inhibit-redisplay t)
              (inhibit-message t))
          (add-to-list 'load-path (locate-user-emacs-file
                                   "straight/build/org/"))
          (require 'org)
          (org-babel-tangle)))
      (message "Tangling config.org... Done.")
      ;; load init files
      (load (locate-user-emacs-file "early-init.el"))
      (load (locate-user-emacs-file "init.el"))
      (load (locate-user-emacs-file "config.el"))))
#+end_src

#+begin_src emacs-lisp :noweb-ref bindings
  (define-key acdw/leader (kbd "C-M-r") #'acdw/reload)
#+end_src

** init.el
:PROPERTIES:
:header-args: :tangle init.el :noweb yes
:END:

The classic Emacs initiation file.

*** Header

#+begin_src emacs-lisp
  ;;; init.el -*- lexical-binding: t -*-
  <<disclaimer>>
  ;;; Code:
#+end_src

*** Load enfer custom files
#+begin_src emacs-lisp
(require 'enfer-util)
(require 'enfer-pkgmgr)
(require 'enfer-emacs-sanity)
(require 'enfer-emacs-startup)
(require 'enfer-pkg-builtin)
(require 'enfer-pkg-util)
(require 'enfer-pkg-ui)
(require 'enfer-pkg-editor)
(require 'enfer-pkg-completion)
(require 'enfer-pkg-window)
(require 'enfer-pkg-project)
(require 'enfer-pkg-org)
(require 'enfer-code-lisp)
(require 'enfer-code-elisp)
(require 'enfer-code-lisp)
(require 'enfer-code-clojure)
(require 'enfer-key-bindings)
#+end_src
*** Load the config -disabled

I keep most of my config in =config.el=, which is tangled directly from
this file.  This init just loads that file, either from lisp
or directly from Org if it's newer.  /Note/ the longish comment before
the =unless= form -- it was pretty tough for me to wrap my head around
the needed boolean expression to tangle config.org.  Booleans, yall!

#+begin_src emacs-lisp :tangle no
  (let* (;; Speed up init
        ;; (gc-cons-threshold most-positive-fixnum)
         ;; (gc-cons-percentage 0.6)
         ;;(file-name-handler-alist nil)
         ;; Config file names
         (config (expand-file-name "config"
                                   user-emacs-directory))
         (config.el (concat config ".el"))
         (config.org (concat config ".org"))
         (straight-org-dir (locate-user-emacs-file "straight/build/org")))
    ;; Okay, let's figure this out.
    ;; `and' evaluates each form, and returns nil on the first that
    ;; returns nil.  `unless' only executes its body if the test
    ;; returns nil.  So.
    ;; 1. Test if config.org is newer than config.el.  If it is (t), we
    ;;    *want* to evaluate the body, so we need to negate that test.
    ;; 2. Try to load the config.  If it errors (nil), it'll bubble that
    ;;    to the `and' and the body will be evaluated.
    (unless (and (not (file-newer-than-file-p config.org config.el))
                 (load config :noerror))
      ;; A plain require here just loads the older `org'
      ;; in Emacs' install dir.  We need to add the newer
      ;; one to the `load-path', hopefully that's all.
      (when (file-exists-p straight-org-dir)
        (add-to-list 'load-path straight-org-dir))
      ;; Load config.org
      (require 'org)
      (org-babel-load-file config.org)))

  ;;; init.el ends here
#+end_src

** early-init.el
:PROPERTIES:
:header-args: :tangle early-init.el :noweb yes
:END:

Beginning with 27.1, Emacs also loads an =early-init.el= file, before
the package manager or the UI code.

#+begin_src emacs-lisp
;;; early-init.el -*- lexical-binding: t; no-byte-compile: t; -*-
<<disclaimer>>
;;; Code:

;;; ============================================================================
;;; Emacs startup optimisations
;;; ============================================================================
<<garbage-filehandler>>

;;; ============================================================================
;;; Frame parameters for faster startup
;;; ============================================================================
<<early-init-frame>>
;;; ============================================================================
;;; Specify some directory paths
;;; ============================================================================
<<early-directories>>
;;; ============================================================================
;;; Set up the package manager
;;; ============================================================================
<<early-straight>>
;;; early-init.el ends here
#+end_src

** License
:PROPERTIES:
:header-args: :tangle LICENSE
:END:

Copyright © 2021 Gas <gas@tuatara.red>

This work is free.  You can redistribute it and/or modify it under the
terms of the Do What the Fuck You Want To Public License, Version 2,
as published by Sam Hocevar.  See the =LICENSE= file, tangled from the
following source block, for details.

#+begin_src text
  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE

  Version 2, December 2004

  Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>

  Everyone is permitted to copy and distribute verbatim or modified copies of
  this license document, and changing it is allowed as long as the name is changed.

  DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE

  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. You just DO WHAT THE FUCK YOU WANT TO.
#+end_src
